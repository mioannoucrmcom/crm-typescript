/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { CrmCore } from "../core.js";
import { encodeFormQuery } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { resolveSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import { CrmError } from "../models/errors/crm-error.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/http-client-errors.js";
import { ResponseValidationError } from "../models/errors/response-validation-error.js";
import { SDKValidationError } from "../models/errors/sdk-validation-error.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Payment Form
 *
 * @remarks
 * Web API used when consumers want to perform a payment using a card on file. It's vital to study the Payment Gateway's required contact information. Make sure that this required information is already specified for contacts that use this form to make payments/top-ups since this Web API does not forward/includes such info in the request!
 *
 * @deprecated method: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export function paymentFormsComCrmPaymentFormSelfServiceResourceGeneratePaymentForm(
  client: CrmCore,
  security:
    operations.ComCrmPaymentFormSelfServiceResourceGeneratePaymentFormSecurity,
  request:
    operations.ComCrmPaymentFormSelfServiceResourceGeneratePaymentFormRequest,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.ComCrmPaymentFormSelfServiceResourceGeneratePaymentFormResponse,
    | CrmError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    security,
    request,
    options,
  ));
}

async function $do(
  client: CrmCore,
  security:
    operations.ComCrmPaymentFormSelfServiceResourceGeneratePaymentFormSecurity,
  request:
    operations.ComCrmPaymentFormSelfServiceResourceGeneratePaymentFormRequest,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.ComCrmPaymentFormSelfServiceResourceGeneratePaymentFormResponse,
      | CrmError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      z.parse(
        operations
          .ComCrmPaymentFormSelfServiceResourceGeneratePaymentFormRequest$outboundSchema,
        value,
      ),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = null;

  const path = pathToFunc("/self-service/v2/payment_forms/payment")();

  const query = encodeFormQuery({
    "amount": payload.amount,
    "back_url": payload.back_url,
    "back_url_name": payload.back_url_name,
    "currency_code": payload.currency_code,
    "device_type": payload.device_type,
    "estimation_id": payload.estimation_id,
    "integration_id": payload.integration_id,
    "payment_method_id": payload.payment_method_id,
    "redirect_url": payload.redirect_url,
    "type": payload.type,
  });

  const headers = new Headers(compactMap({
    Accept: "application/json",
  }));

  const requestSecurity = resolveSecurity(
    [
      {
        fieldName: "api_key",
        type: "apiKey:header",
        value: security?.secretAPIKey,
      },
    ],
    [
      {
        fieldName: "Authorization",
        type: "http:bearer",
        value: security?.authorizationSelfService,
      },
    ],
  );

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID: "com.crm.PaymentFormSelfServiceResource_generatePaymentForm",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "GET",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    query: query,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "4XX",
      "500",
      "502",
      "503",
      "504",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const [result] = await M.match<
    operations.ComCrmPaymentFormSelfServiceResourceGeneratePaymentFormResponse,
    | CrmError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations
        .ComCrmPaymentFormSelfServiceResourceGeneratePaymentFormResponse$inboundSchema,
    ),
    M.fail([400, 401, 403, 404, "4XX"]),
    M.fail([500, 502, 503, 504, "5XX"]),
  )(response, req);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}
