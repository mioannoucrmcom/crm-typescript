/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { CrmCore } from "../core.js";
import { encodeJSON } from "../lib/encodings.js";
import * as M from "../lib/matchers.js";
import { compactMap } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { RequestOptions } from "../lib/sdks.js";
import { resolveSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import { CrmError } from "../models/errors/crm-error.js";
import {
  ConnectionError,
  InvalidRequestError,
  RequestAbortedError,
  RequestTimeoutError,
  UnexpectedClientError,
} from "../models/errors/http-client-errors.js";
import { ResponseValidationError } from "../models/errors/response-validation-error.js";
import { SDKValidationError } from "../models/errors/sdk-validation-error.js";
import * as operations from "../models/operations/index.js";
import { APICall, APIPromise } from "../types/async.js";
import { Result } from "../types/fp.js";

/**
 * Get Gift Pass Payment Form
 *
 * @remarks
 * Web API used when consumers purchase Gift Passes from a Landing page. The Web API forwards information of the purchased pass, along with the buyer and receiver's details. In addition, the Web aPI integrates with the Payment Gateway service and request to load their payment form for an easy payment processing. To avoid any issues, it's vital to check the Payment Gateway service's mandatory information requirements, such as the buyer's email, phone, and address information, before triggering the Web API.
 *
 * @deprecated method: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export function paymentFormsComCrmPaymentFormSelfServiceResourceGeneratePassPaymentForm(
  client: CrmCore,
  security:
    operations.ComCrmPaymentFormSelfServiceResourceGeneratePassPaymentFormSecurity,
  request?:
    | operations.ComCrmPaymentFormSelfServiceResourceGeneratePassPaymentFormRequest
    | undefined,
  options?: RequestOptions,
): APIPromise<
  Result<
    operations.ComCrmPaymentFormSelfServiceResourceGeneratePassPaymentFormResponse,
    | CrmError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >
> {
  return new APIPromise($do(
    client,
    security,
    request,
    options,
  ));
}

async function $do(
  client: CrmCore,
  security:
    operations.ComCrmPaymentFormSelfServiceResourceGeneratePassPaymentFormSecurity,
  request?:
    | operations.ComCrmPaymentFormSelfServiceResourceGeneratePassPaymentFormRequest
    | undefined,
  options?: RequestOptions,
): Promise<
  [
    Result<
      operations.ComCrmPaymentFormSelfServiceResourceGeneratePassPaymentFormResponse,
      | CrmError
      | ResponseValidationError
      | ConnectionError
      | RequestAbortedError
      | RequestTimeoutError
      | InvalidRequestError
      | UnexpectedClientError
      | SDKValidationError
    >,
    APICall,
  ]
> {
  const parsed = safeParse(
    request,
    (value) =>
      z.parse(
        z.optional(
          operations
            .ComCrmPaymentFormSelfServiceResourceGeneratePassPaymentFormRequest$outboundSchema,
        ),
        value,
      ),
    "Input validation failed",
  );
  if (!parsed.ok) {
    return [parsed, { status: "invalid" }];
  }
  const payload = parsed.value;
  const body = payload === undefined
    ? null
    : encodeJSON("body", payload, { explode: true });

  const path = pathToFunc("/self-service/v2/payment_forms/pass")();

  const headers = new Headers(compactMap({
    "Content-Type": "application/json",
    Accept: "application/json",
  }));

  const requestSecurity = resolveSecurity(
    [
      {
        fieldName: "api_key",
        type: "apiKey:header",
        value: security?.secretAPIKey,
      },
    ],
    [
      {
        fieldName: "Authorization",
        type: "http:bearer",
        value: security?.authorizationSelfService,
      },
    ],
    [
      {
        fieldName: "api_key",
        type: "apiKey:header",
        value: security?.publicAPIKey,
      },
    ],
  );

  const context = {
    options: client._options,
    baseURL: options?.serverURL ?? client._baseURL ?? "",
    operationID:
      "com.crm.PaymentFormSelfServiceResource_generatePassPaymentForm",
    oAuth2Scopes: null,

    resolvedSecurity: requestSecurity,

    securitySource: security,
    retryConfig: options?.retries
      || client._options.retryConfig
      || { strategy: "none" },
    retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
  };

  const requestRes = client._createRequest(context, {
    security: requestSecurity,
    method: "POST",
    baseURL: options?.serverURL,
    path: path,
    headers: headers,
    body: body,
    userAgent: client._options.userAgent,
    timeoutMs: options?.timeoutMs || client._options.timeoutMs || -1,
  }, options);
  if (!requestRes.ok) {
    return [requestRes, { status: "invalid" }];
  }
  const req = requestRes.value;

  const doResult = await client._do(req, {
    context,
    errorCodes: [
      "400",
      "401",
      "403",
      "404",
      "4XX",
      "500",
      "502",
      "503",
      "504",
      "5XX",
    ],
    retryConfig: context.retryConfig,
    retryCodes: context.retryCodes,
  });
  if (!doResult.ok) {
    return [doResult, { status: "request-error", request: req }];
  }
  const response = doResult.value;

  const [result] = await M.match<
    operations.ComCrmPaymentFormSelfServiceResourceGeneratePassPaymentFormResponse,
    | CrmError
    | ResponseValidationError
    | ConnectionError
    | RequestAbortedError
    | RequestTimeoutError
    | InvalidRequestError
    | UnexpectedClientError
    | SDKValidationError
  >(
    M.json(
      200,
      operations
        .ComCrmPaymentFormSelfServiceResourceGeneratePassPaymentFormResponse$inboundSchema,
    ),
    M.fail([400, 401, 403, 404, "4XX"]),
    M.fail([500, 502, 503, 504, "5XX"]),
  )(response, req);
  if (!result.ok) {
    return [result, { status: "complete", request: req, response }];
  }

  return [result, { status: "complete", request: req, response }];
}
