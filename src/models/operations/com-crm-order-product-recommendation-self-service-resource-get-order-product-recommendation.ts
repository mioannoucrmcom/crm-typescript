/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 * @generated-id: 64a40d4e22ab
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

export type ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationSecurity =
  {
    secretAPIKey?: string | undefined;
    authorization?: string | undefined;
  };

export type ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationRequest =
  {
    /**
     * Recommend products based on what is included in an order estimation
     */
    estimationId: string;
    /**
     * Include recommended products creatives
     */
    includeCreatives?: boolean | undefined;
    /**
     * Include cross-sell products in the recommndation
     */
    includeCrossSells?: boolean | undefined;
    /**
     * Include promotions in the recommndation
     */
    includePromotions?: boolean | undefined;
    /**
     * Include reward offers in the recommndation
     */
    includeRewardOffers?: boolean | undefined;
    /**
     * Include up-sell products in the recommndation
     */
    includeUpsells?: boolean | undefined;
    /**
     * Recommend products based on order catalogues
     */
    orderCatalogueIds?: string | undefined;
  };

/**
 * The pricing model:
 *
 * @remarks
 *  * `FLAT`
 *  * `TIERED`
 *  * `VOLUME`
 *  * `STAIRSTEP`
 */
export const CrossSellPriceModel = {
  Flat: "FLAT",
  Tiered: "TIERED",
  Volume: "VOLUME",
  Stairstep: "STAIRSTEP",
} as const;
/**
 * The pricing model:
 *
 * @remarks
 *  * `FLAT`
 *  * `TIERED`
 *  * `VOLUME`
 *  * `STAIRSTEP`
 */
export type CrossSellPriceModel = OpenEnum<typeof CrossSellPriceModel>;

/**
 * Currency code based on ISO 4217 standard
 */
export const CrossSellCurrencyCode = {
  Aed: "AED",
  Afn: "AFN",
  All: "ALL",
  Amd: "AMD",
  Ang: "ANG",
  Aoa: "AOA",
  Ars: "ARS",
  Aud: "AUD",
  Awg: "AWG",
  Azn: "AZN",
  Bam: "BAM",
  Bbd: "BBD",
  Bdt: "BDT",
  Bgn: "BGN",
  Bhd: "BHD",
  Bif: "BIF",
  Bmd: "BMD",
  Bnd: "BND",
  Bob: "BOB",
  Brl: "BRL",
  Bsd: "BSD",
  Btn: "BTN",
  Bwp: "BWP",
  Byr: "BYR",
  Bzd: "BZD",
  Cad: "CAD",
  Cdf: "CDF",
  Chf: "CHF",
  Clp: "CLP",
  Cny: "CNY",
  Cop: "COP",
  Crc: "CRC",
  Cuc: "CUC",
  Cup: "CUP",
  Cve: "CVE",
  Czk: "CZK",
  Djf: "DJF",
  Dkk: "DKK",
  Dop: "DOP",
  Dzd: "DZD",
  Egp: "EGP",
  Ern: "ERN",
  Etb: "ETB",
  Eur: "EUR",
  Fjd: "FJD",
  Fkp: "FKP",
  Gbp: "GBP",
  Gel: "GEL",
  Ggp: "GGP",
  Ghs: "GHS",
  Gip: "GIP",
  Gmd: "GMD",
  Gnf: "GNF",
  Gtq: "GTQ",
  Gyd: "GYD",
  Hkd: "HKD",
  Hnl: "HNL",
  Hrk: "HRK",
  Htg: "HTG",
  Huf: "HUF",
  Idr: "IDR",
  Ils: "ILS",
  Imp: "IMP",
  Inr: "INR",
  Iqd: "IQD",
  Irr: "IRR",
  Isk: "ISK",
  Jep: "JEP",
  Jmd: "JMD",
  Jod: "JOD",
  Jpy: "JPY",
  Kes: "KES",
  Kgs: "KGS",
  Khr: "KHR",
  Kmf: "KMF",
  Kpw: "KPW",
  Krw: "KRW",
  Kwd: "KWD",
  Kyd: "KYD",
  Kzt: "KZT",
  Lak: "LAK",
  Lbp: "LBP",
  Lkr: "LKR",
  Lrd: "LRD",
  Lsl: "LSL",
  Lyd: "LYD",
  Mad: "MAD",
  Mdl: "MDL",
  Mga: "MGA",
  Mkd: "MKD",
  Mmk: "MMK",
  Mnt: "MNT",
  Mop: "MOP",
  Mro: "MRO",
  Mur: "MUR",
  Mvr: "MVR",
  Mwk: "MWK",
  Mxn: "MXN",
  Myr: "MYR",
  Mzn: "MZN",
  Nad: "NAD",
  Ngn: "NGN",
  Nio: "NIO",
  Nok: "NOK",
  Npr: "NPR",
  Nzd: "NZD",
  Omr: "OMR",
  Pab: "PAB",
  Pen: "PEN",
  Pgk: "PGK",
  Php: "PHP",
  Pkr: "PKR",
  Pln: "PLN",
  Pyg: "PYG",
  Qar: "QAR",
  Ron: "RON",
  Rsd: "RSD",
  Rub: "RUB",
  Rwf: "RWF",
  Sar: "SAR",
  Sbd: "SBD",
  Scr: "SCR",
  Sdg: "SDG",
  Sek: "SEK",
  Sgd: "SGD",
  Shp: "SHP",
  Sll: "SLL",
  Sos: "SOS",
  Spl: "SPL",
  Srd: "SRD",
  Std: "STD",
  Svc: "SVC",
  Syp: "SYP",
  Szl: "SZL",
  Thb: "THB",
  Tjs: "TJS",
  Tmt: "TMT",
  Tnd: "TND",
  Top: "TOP",
  Try: "TRY",
  Ttd: "TTD",
  Tvd: "TVD",
  Twd: "TWD",
  Tzs: "TZS",
  Uah: "UAH",
  Ugx: "UGX",
  Usd: "USD",
  Uyu: "UYU",
  Uzs: "UZS",
  Vef: "VEF",
  Vnd: "VND",
  Vuv: "VUV",
  Wst: "WST",
  Xaf: "XAF",
  Xcd: "XCD",
  Xdr: "XDR",
  Xof: "XOF",
  Xpf: "XPF",
  Yer: "YER",
  Zar: "ZAR",
  Zmw: "ZMW",
  Zwd: "ZWD",
  Pts: "PTS",
} as const;
/**
 * Currency code based on ISO 4217 standard
 */
export type CrossSellCurrencyCode = OpenEnum<typeof CrossSellCurrencyCode>;

/**
 * Defines whether the price is tax inclusive or not. Defaults to the system's Taxation setting
 */
export const CrossSellTaxModel = {
  TaxInclusive: "TAX_INCLUSIVE",
  TaxExclusive: "TAX_EXCLUSIVE",
} as const;
/**
 * Defines whether the price is tax inclusive or not. Defaults to the system's Taxation setting
 */
export type CrossSellTaxModel = OpenEnum<typeof CrossSellTaxModel>;

/**
 * Available only Tiered, Volume and Stairstep pricing models. Only the first tier range is returned that has the returned price
 */
export type CrossSellTiers = {
  /**
   * The upper tier of the first tiered range
   */
  upperTier?: number | undefined;
  /**
   * Tiered price lower tier
   */
  numberOfTiers?: number | undefined;
};

/**
 * Period Cycle unit of time
 */
export const CrossSellUot = {
  Second: "SECOND",
  Minute: "MINUTE",
  Hour: "HOUR",
  Day: "DAY",
  Week: "WEEK",
  Month: "MONTH",
  Year: "YEAR",
  Overall: "OVERALL",
} as const;
/**
 * Period Cycle unit of time
 */
export type CrossSellUot = OpenEnum<typeof CrossSellUot>;

/**
 * The billing period mapped to the specified price. Applicable only for termed and one-time services only.
 */
export type CrossSellBillingPeriod = {
  /**
   * Period Cycle duration
   */
  duration?: number | undefined;
  /**
   * Period Cycle unit of time
   */
  uot?: CrossSellUot | undefined;
};

/**
 * Applicable only for Usage service to show the unit per which the price is applied
 */
export type CrossSellMeasurementUnit = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * Measurement unit name
   */
  name?: string | undefined;
  /**
   * Measurement unit display name
   */
  displayName?: string | undefined;
};

/**
 * The period of time that service will be accessible. Applicable only for one-time services
 */
export type CrossSellAccessPeriod = {
  /**
   * The date that the One Time service will start
   */
  startDate?: number | undefined;
  /**
   * The date that the One Time service will end
   */
  endDate?: number | undefined;
};

/**
 * Details about the related product order queue
 */
export type CrossSellOrderQueue = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
};

export type CrossSellPricing = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The pricing model:
   *
   * @remarks
   *  * `FLAT`
   *  * `TIERED`
   *  * `VOLUME`
   *  * `STAIRSTEP`
   */
  priceModel?: CrossSellPriceModel | undefined;
  /**
   * Currency code based on ISO 4217 standard
   */
  currencyCode?: CrossSellCurrencyCode | undefined;
  /**
   * Defines whether the price is tax inclusive or not. Defaults to the system's Taxation setting
   */
  taxModel?: CrossSellTaxModel | undefined;
  /**
   * The product's price. For Tiered/Volume and Stairstep pricing models, the first range's price is returned.
   */
  price?: number | undefined;
  /**
   * Available only Tiered, Volume and Stairstep pricing models. Only the first tier range is returned that has the returned price
   */
  tiers?: CrossSellTiers | undefined;
  /**
   * The billing period mapped to the specified price. Applicable only for termed and one-time services only.
   */
  billingPeriod?: CrossSellBillingPeriod | undefined;
  /**
   * Applicable only for Usage service to show the unit per which the price is applied
   */
  measurementUnit?: CrossSellMeasurementUnit | undefined;
  /**
   * The period of time that service will be accessible. Applicable only for one-time services
   */
  accessPeriod?: CrossSellAccessPeriod | undefined;
  /**
   * Details about the related product order queue
   */
  orderQueue?: CrossSellOrderQueue | undefined;
};

/**
 * Information about the creative type
 */
export const CrossSellUsageType = {
  Logo: "LOGO",
  Background: "BACKGROUND",
  Avatar: "AVATAR",
  Hero: "HERO",
  Marketing: "MARKETING",
  Attachment: "ATTACHMENT",
  Profileimage: "PROFILEIMAGE",
  AppleLockscreenIcon: "APPLE_LOCKSCREEN_ICON",
  AppleLogoImage: "APPLE_LOGO_IMAGE",
  AppleStripImage: "APPLE_STRIP_IMAGE",
  GoogleLogoImage: "GOOGLE_LOGO_IMAGE",
  GoogleStripImage: "GOOGLE_STRIP_IMAGE",
  LandingPageLogoImage: "LANDING_PAGE_LOGO_IMAGE",
  LandingPageHeaderImage: "LANDING_PAGE_HEADER_IMAGE",
  LandingPageBackgroundImage: "LANDING_PAGE_BACKGROUND_IMAGE",
  DeliveryImage: "DELIVERY_IMAGE",
  PickupImage: "PICKUP_IMAGE",
  DirectSaleImage: "DIRECT_SALE_IMAGE",
  WalletImage: "WALLET_IMAGE",
  LandingPageImage: "LANDING_PAGE_IMAGE",
  AppLogo: "APP_LOGO",
  PartnerLogo: "PARTNER_LOGO",
  Carousel: "CAROUSEL",
  Shortcut: "SHORTCUT",
  ShortcutImage: "SHORTCUT_IMAGE",
  EmbeddedLinkImage: "EMBEDDED_LINK_IMAGE",
  Image: "IMAGE",
  AppLoaderImage: "APP_LOADER_IMAGE",
  MobileBackgroundImage: "MOBILE_BACKGROUND_IMAGE",
} as const;
/**
 * Information about the creative type
 */
export type CrossSellUsageType = OpenEnum<typeof CrossSellUsageType>;

export type CrossSellMedia = {
  /**
   * The transformed creative width
   */
  width?: number | undefined;
  /**
   * The transformed creative height
   */
  height?: number | undefined;
  /**
   * The transformed creative URL
   */
  url?: string | undefined;
};

export type CrossSellCreative = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * the identifier of media
   */
  mediaGroupId?: string | undefined;
  /**
   * Information about the creative type
   */
  usageType?: CrossSellUsageType | undefined;
  /**
   * The creative width
   */
  width?: number | undefined;
  /**
   * The creative height
   */
  height?: number | undefined;
  /**
   * The creative format
   */
  format?: string | undefined;
  /**
   * The creative content URL
   */
  url?: string | undefined;
  /**
   * The creative public identifier
   */
  publicId?: string | undefined;
  /**
   * The media identifier
   */
  mediaId?: string | undefined;
  /**
   * The creative caption used in cases where usage_type=CAROUSEL
   */
  caption?: string | undefined;
  /**
   * The creative sort order used in cases where usage_type=CAROUSEL
   */
  sortOrder?: number | undefined;
  /**
   * Information about the creative transformations
   */
  media?: Array<CrossSellMedia> | undefined;
};

export type ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationCrossSell =
  {
    id?: string | undefined;
    sku?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    pricing?: CrossSellPricing | undefined;
    creatives?: Array<CrossSellCreative> | undefined;
  };

/**
 * The pricing model:
 *
 * @remarks
 *  * `FLAT`
 *  * `TIERED`
 *  * `VOLUME`
 *  * `STAIRSTEP`
 */
export const UpsellPriceModel = {
  Flat: "FLAT",
  Tiered: "TIERED",
  Volume: "VOLUME",
  Stairstep: "STAIRSTEP",
} as const;
/**
 * The pricing model:
 *
 * @remarks
 *  * `FLAT`
 *  * `TIERED`
 *  * `VOLUME`
 *  * `STAIRSTEP`
 */
export type UpsellPriceModel = OpenEnum<typeof UpsellPriceModel>;

/**
 * Currency code based on ISO 4217 standard
 */
export const UpsellCurrencyCode = {
  Aed: "AED",
  Afn: "AFN",
  All: "ALL",
  Amd: "AMD",
  Ang: "ANG",
  Aoa: "AOA",
  Ars: "ARS",
  Aud: "AUD",
  Awg: "AWG",
  Azn: "AZN",
  Bam: "BAM",
  Bbd: "BBD",
  Bdt: "BDT",
  Bgn: "BGN",
  Bhd: "BHD",
  Bif: "BIF",
  Bmd: "BMD",
  Bnd: "BND",
  Bob: "BOB",
  Brl: "BRL",
  Bsd: "BSD",
  Btn: "BTN",
  Bwp: "BWP",
  Byr: "BYR",
  Bzd: "BZD",
  Cad: "CAD",
  Cdf: "CDF",
  Chf: "CHF",
  Clp: "CLP",
  Cny: "CNY",
  Cop: "COP",
  Crc: "CRC",
  Cuc: "CUC",
  Cup: "CUP",
  Cve: "CVE",
  Czk: "CZK",
  Djf: "DJF",
  Dkk: "DKK",
  Dop: "DOP",
  Dzd: "DZD",
  Egp: "EGP",
  Ern: "ERN",
  Etb: "ETB",
  Eur: "EUR",
  Fjd: "FJD",
  Fkp: "FKP",
  Gbp: "GBP",
  Gel: "GEL",
  Ggp: "GGP",
  Ghs: "GHS",
  Gip: "GIP",
  Gmd: "GMD",
  Gnf: "GNF",
  Gtq: "GTQ",
  Gyd: "GYD",
  Hkd: "HKD",
  Hnl: "HNL",
  Hrk: "HRK",
  Htg: "HTG",
  Huf: "HUF",
  Idr: "IDR",
  Ils: "ILS",
  Imp: "IMP",
  Inr: "INR",
  Iqd: "IQD",
  Irr: "IRR",
  Isk: "ISK",
  Jep: "JEP",
  Jmd: "JMD",
  Jod: "JOD",
  Jpy: "JPY",
  Kes: "KES",
  Kgs: "KGS",
  Khr: "KHR",
  Kmf: "KMF",
  Kpw: "KPW",
  Krw: "KRW",
  Kwd: "KWD",
  Kyd: "KYD",
  Kzt: "KZT",
  Lak: "LAK",
  Lbp: "LBP",
  Lkr: "LKR",
  Lrd: "LRD",
  Lsl: "LSL",
  Lyd: "LYD",
  Mad: "MAD",
  Mdl: "MDL",
  Mga: "MGA",
  Mkd: "MKD",
  Mmk: "MMK",
  Mnt: "MNT",
  Mop: "MOP",
  Mro: "MRO",
  Mur: "MUR",
  Mvr: "MVR",
  Mwk: "MWK",
  Mxn: "MXN",
  Myr: "MYR",
  Mzn: "MZN",
  Nad: "NAD",
  Ngn: "NGN",
  Nio: "NIO",
  Nok: "NOK",
  Npr: "NPR",
  Nzd: "NZD",
  Omr: "OMR",
  Pab: "PAB",
  Pen: "PEN",
  Pgk: "PGK",
  Php: "PHP",
  Pkr: "PKR",
  Pln: "PLN",
  Pyg: "PYG",
  Qar: "QAR",
  Ron: "RON",
  Rsd: "RSD",
  Rub: "RUB",
  Rwf: "RWF",
  Sar: "SAR",
  Sbd: "SBD",
  Scr: "SCR",
  Sdg: "SDG",
  Sek: "SEK",
  Sgd: "SGD",
  Shp: "SHP",
  Sll: "SLL",
  Sos: "SOS",
  Spl: "SPL",
  Srd: "SRD",
  Std: "STD",
  Svc: "SVC",
  Syp: "SYP",
  Szl: "SZL",
  Thb: "THB",
  Tjs: "TJS",
  Tmt: "TMT",
  Tnd: "TND",
  Top: "TOP",
  Try: "TRY",
  Ttd: "TTD",
  Tvd: "TVD",
  Twd: "TWD",
  Tzs: "TZS",
  Uah: "UAH",
  Ugx: "UGX",
  Usd: "USD",
  Uyu: "UYU",
  Uzs: "UZS",
  Vef: "VEF",
  Vnd: "VND",
  Vuv: "VUV",
  Wst: "WST",
  Xaf: "XAF",
  Xcd: "XCD",
  Xdr: "XDR",
  Xof: "XOF",
  Xpf: "XPF",
  Yer: "YER",
  Zar: "ZAR",
  Zmw: "ZMW",
  Zwd: "ZWD",
  Pts: "PTS",
} as const;
/**
 * Currency code based on ISO 4217 standard
 */
export type UpsellCurrencyCode = OpenEnum<typeof UpsellCurrencyCode>;

/**
 * Defines whether the price is tax inclusive or not. Defaults to the system's Taxation setting
 */
export const UpsellTaxModel = {
  TaxInclusive: "TAX_INCLUSIVE",
  TaxExclusive: "TAX_EXCLUSIVE",
} as const;
/**
 * Defines whether the price is tax inclusive or not. Defaults to the system's Taxation setting
 */
export type UpsellTaxModel = OpenEnum<typeof UpsellTaxModel>;

/**
 * Available only Tiered, Volume and Stairstep pricing models. Only the first tier range is returned that has the returned price
 */
export type UpsellTiers = {
  /**
   * The upper tier of the first tiered range
   */
  upperTier?: number | undefined;
  /**
   * Tiered price lower tier
   */
  numberOfTiers?: number | undefined;
};

/**
 * Period Cycle unit of time
 */
export const UpsellUot = {
  Second: "SECOND",
  Minute: "MINUTE",
  Hour: "HOUR",
  Day: "DAY",
  Week: "WEEK",
  Month: "MONTH",
  Year: "YEAR",
  Overall: "OVERALL",
} as const;
/**
 * Period Cycle unit of time
 */
export type UpsellUot = OpenEnum<typeof UpsellUot>;

/**
 * The billing period mapped to the specified price. Applicable only for termed and one-time services only.
 */
export type UpsellBillingPeriod = {
  /**
   * Period Cycle duration
   */
  duration?: number | undefined;
  /**
   * Period Cycle unit of time
   */
  uot?: UpsellUot | undefined;
};

/**
 * Applicable only for Usage service to show the unit per which the price is applied
 */
export type UpsellMeasurementUnit = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * Measurement unit name
   */
  name?: string | undefined;
  /**
   * Measurement unit display name
   */
  displayName?: string | undefined;
};

/**
 * The period of time that service will be accessible. Applicable only for one-time services
 */
export type UpsellAccessPeriod = {
  /**
   * The date that the One Time service will start
   */
  startDate?: number | undefined;
  /**
   * The date that the One Time service will end
   */
  endDate?: number | undefined;
};

/**
 * Details about the related product order queue
 */
export type UpsellOrderQueue = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
};

export type UpsellPricing = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The pricing model:
   *
   * @remarks
   *  * `FLAT`
   *  * `TIERED`
   *  * `VOLUME`
   *  * `STAIRSTEP`
   */
  priceModel?: UpsellPriceModel | undefined;
  /**
   * Currency code based on ISO 4217 standard
   */
  currencyCode?: UpsellCurrencyCode | undefined;
  /**
   * Defines whether the price is tax inclusive or not. Defaults to the system's Taxation setting
   */
  taxModel?: UpsellTaxModel | undefined;
  /**
   * The product's price. For Tiered/Volume and Stairstep pricing models, the first range's price is returned.
   */
  price?: number | undefined;
  /**
   * Available only Tiered, Volume and Stairstep pricing models. Only the first tier range is returned that has the returned price
   */
  tiers?: UpsellTiers | undefined;
  /**
   * The billing period mapped to the specified price. Applicable only for termed and one-time services only.
   */
  billingPeriod?: UpsellBillingPeriod | undefined;
  /**
   * Applicable only for Usage service to show the unit per which the price is applied
   */
  measurementUnit?: UpsellMeasurementUnit | undefined;
  /**
   * The period of time that service will be accessible. Applicable only for one-time services
   */
  accessPeriod?: UpsellAccessPeriod | undefined;
  /**
   * Details about the related product order queue
   */
  orderQueue?: UpsellOrderQueue | undefined;
};

/**
 * Information about the creative type
 */
export const UpsellUsageType = {
  Logo: "LOGO",
  Background: "BACKGROUND",
  Avatar: "AVATAR",
  Hero: "HERO",
  Marketing: "MARKETING",
  Attachment: "ATTACHMENT",
  Profileimage: "PROFILEIMAGE",
  AppleLockscreenIcon: "APPLE_LOCKSCREEN_ICON",
  AppleLogoImage: "APPLE_LOGO_IMAGE",
  AppleStripImage: "APPLE_STRIP_IMAGE",
  GoogleLogoImage: "GOOGLE_LOGO_IMAGE",
  GoogleStripImage: "GOOGLE_STRIP_IMAGE",
  LandingPageLogoImage: "LANDING_PAGE_LOGO_IMAGE",
  LandingPageHeaderImage: "LANDING_PAGE_HEADER_IMAGE",
  LandingPageBackgroundImage: "LANDING_PAGE_BACKGROUND_IMAGE",
  DeliveryImage: "DELIVERY_IMAGE",
  PickupImage: "PICKUP_IMAGE",
  DirectSaleImage: "DIRECT_SALE_IMAGE",
  WalletImage: "WALLET_IMAGE",
  LandingPageImage: "LANDING_PAGE_IMAGE",
  AppLogo: "APP_LOGO",
  PartnerLogo: "PARTNER_LOGO",
  Carousel: "CAROUSEL",
  Shortcut: "SHORTCUT",
  ShortcutImage: "SHORTCUT_IMAGE",
  EmbeddedLinkImage: "EMBEDDED_LINK_IMAGE",
  Image: "IMAGE",
  AppLoaderImage: "APP_LOADER_IMAGE",
  MobileBackgroundImage: "MOBILE_BACKGROUND_IMAGE",
} as const;
/**
 * Information about the creative type
 */
export type UpsellUsageType = OpenEnum<typeof UpsellUsageType>;

export type UpsellMedia = {
  /**
   * The transformed creative width
   */
  width?: number | undefined;
  /**
   * The transformed creative height
   */
  height?: number | undefined;
  /**
   * The transformed creative URL
   */
  url?: string | undefined;
};

export type UpsellCreative = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * the identifier of media
   */
  mediaGroupId?: string | undefined;
  /**
   * Information about the creative type
   */
  usageType?: UpsellUsageType | undefined;
  /**
   * The creative width
   */
  width?: number | undefined;
  /**
   * The creative height
   */
  height?: number | undefined;
  /**
   * The creative format
   */
  format?: string | undefined;
  /**
   * The creative content URL
   */
  url?: string | undefined;
  /**
   * The creative public identifier
   */
  publicId?: string | undefined;
  /**
   * The media identifier
   */
  mediaId?: string | undefined;
  /**
   * The creative caption used in cases where usage_type=CAROUSEL
   */
  caption?: string | undefined;
  /**
   * The creative sort order used in cases where usage_type=CAROUSEL
   */
  sortOrder?: number | undefined;
  /**
   * Information about the creative transformations
   */
  media?: Array<UpsellMedia> | undefined;
};

export type ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationUpsell =
  {
    id?: string | undefined;
    sku?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    pricing?: UpsellPricing | undefined;
    creatives?: Array<UpsellCreative> | undefined;
  };

/**
 * Information about the creative type
 */
export const RewardOfferUsageType = {
  Logo: "LOGO",
  Background: "BACKGROUND",
  Avatar: "AVATAR",
  Hero: "HERO",
  Marketing: "MARKETING",
  Attachment: "ATTACHMENT",
  Profileimage: "PROFILEIMAGE",
  AppleLockscreenIcon: "APPLE_LOCKSCREEN_ICON",
  AppleLogoImage: "APPLE_LOGO_IMAGE",
  AppleStripImage: "APPLE_STRIP_IMAGE",
  GoogleLogoImage: "GOOGLE_LOGO_IMAGE",
  GoogleStripImage: "GOOGLE_STRIP_IMAGE",
  LandingPageLogoImage: "LANDING_PAGE_LOGO_IMAGE",
  LandingPageHeaderImage: "LANDING_PAGE_HEADER_IMAGE",
  LandingPageBackgroundImage: "LANDING_PAGE_BACKGROUND_IMAGE",
  DeliveryImage: "DELIVERY_IMAGE",
  PickupImage: "PICKUP_IMAGE",
  DirectSaleImage: "DIRECT_SALE_IMAGE",
  WalletImage: "WALLET_IMAGE",
  LandingPageImage: "LANDING_PAGE_IMAGE",
  AppLogo: "APP_LOGO",
  PartnerLogo: "PARTNER_LOGO",
  Carousel: "CAROUSEL",
  Shortcut: "SHORTCUT",
  ShortcutImage: "SHORTCUT_IMAGE",
  EmbeddedLinkImage: "EMBEDDED_LINK_IMAGE",
  Image: "IMAGE",
  AppLoaderImage: "APP_LOADER_IMAGE",
  MobileBackgroundImage: "MOBILE_BACKGROUND_IMAGE",
} as const;
/**
 * Information about the creative type
 */
export type RewardOfferUsageType = OpenEnum<typeof RewardOfferUsageType>;

export type RewardOfferMedia = {
  /**
   * The transformed creative width
   */
  width?: number | undefined;
  /**
   * The transformed creative height
   */
  height?: number | undefined;
  /**
   * The transformed creative URL
   */
  url?: string | undefined;
};

export type RewardOfferCreative = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * the identifier of media
   */
  mediaGroupId?: string | undefined;
  /**
   * Information about the creative type
   */
  usageType?: RewardOfferUsageType | undefined;
  /**
   * The creative width
   */
  width?: number | undefined;
  /**
   * The creative height
   */
  height?: number | undefined;
  /**
   * The creative format
   */
  format?: string | undefined;
  /**
   * The creative content URL
   */
  url?: string | undefined;
  /**
   * The creative public identifier
   */
  publicId?: string | undefined;
  /**
   * The media identifier
   */
  mediaId?: string | undefined;
  /**
   * The creative caption used in cases where usage_type=CAROUSEL
   */
  caption?: string | undefined;
  /**
   * The creative sort order used in cases where usage_type=CAROUSEL
   */
  sortOrder?: number | undefined;
  /**
   * Information about the creative transformations
   */
  media?: Array<RewardOfferMedia> | undefined;
};

export type ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationRewardOffer =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    name?: string | undefined;
    creatives?: Array<RewardOfferCreative> | undefined;
  };

/**
 * Information about the creative type
 */
export const PromotionUsageType = {
  Logo: "LOGO",
  Background: "BACKGROUND",
  Avatar: "AVATAR",
  Hero: "HERO",
  Marketing: "MARKETING",
  Attachment: "ATTACHMENT",
  Profileimage: "PROFILEIMAGE",
  AppleLockscreenIcon: "APPLE_LOCKSCREEN_ICON",
  AppleLogoImage: "APPLE_LOGO_IMAGE",
  AppleStripImage: "APPLE_STRIP_IMAGE",
  GoogleLogoImage: "GOOGLE_LOGO_IMAGE",
  GoogleStripImage: "GOOGLE_STRIP_IMAGE",
  LandingPageLogoImage: "LANDING_PAGE_LOGO_IMAGE",
  LandingPageHeaderImage: "LANDING_PAGE_HEADER_IMAGE",
  LandingPageBackgroundImage: "LANDING_PAGE_BACKGROUND_IMAGE",
  DeliveryImage: "DELIVERY_IMAGE",
  PickupImage: "PICKUP_IMAGE",
  DirectSaleImage: "DIRECT_SALE_IMAGE",
  WalletImage: "WALLET_IMAGE",
  LandingPageImage: "LANDING_PAGE_IMAGE",
  AppLogo: "APP_LOGO",
  PartnerLogo: "PARTNER_LOGO",
  Carousel: "CAROUSEL",
  Shortcut: "SHORTCUT",
  ShortcutImage: "SHORTCUT_IMAGE",
  EmbeddedLinkImage: "EMBEDDED_LINK_IMAGE",
  Image: "IMAGE",
  AppLoaderImage: "APP_LOADER_IMAGE",
  MobileBackgroundImage: "MOBILE_BACKGROUND_IMAGE",
} as const;
/**
 * Information about the creative type
 */
export type PromotionUsageType = OpenEnum<typeof PromotionUsageType>;

export type PromotionMedia = {
  /**
   * The transformed creative width
   */
  width?: number | undefined;
  /**
   * The transformed creative height
   */
  height?: number | undefined;
  /**
   * The transformed creative URL
   */
  url?: string | undefined;
};

export type PromotionCreative = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * the identifier of media
   */
  mediaGroupId?: string | undefined;
  /**
   * Information about the creative type
   */
  usageType?: PromotionUsageType | undefined;
  /**
   * The creative width
   */
  width?: number | undefined;
  /**
   * The creative height
   */
  height?: number | undefined;
  /**
   * The creative format
   */
  format?: string | undefined;
  /**
   * The creative content URL
   */
  url?: string | undefined;
  /**
   * The creative public identifier
   */
  publicId?: string | undefined;
  /**
   * The media identifier
   */
  mediaId?: string | undefined;
  /**
   * The creative caption used in cases where usage_type=CAROUSEL
   */
  caption?: string | undefined;
  /**
   * The creative sort order used in cases where usage_type=CAROUSEL
   */
  sortOrder?: number | undefined;
  /**
   * Information about the creative transformations
   */
  media?: Array<PromotionMedia> | undefined;
};

export type ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationPromotion =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    name?: string | undefined;
    creatives?: Array<PromotionCreative> | undefined;
  };

/**
 * OK
 */
export type ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationResponse =
  {
    crossSells?:
      | Array<
        ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationCrossSell
      >
      | undefined;
    upsells?:
      | Array<
        ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationUpsell
      >
      | undefined;
    rewardOffers?:
      | Array<
        ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationRewardOffer
      >
      | undefined;
    promotions?:
      | Array<
        ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationPromotion
      >
      | undefined;
  };

/** @internal */
export type ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationSecurity$Outbound =
  {
    Secret_API_key?: string | undefined;
    authorization?: string | undefined;
  };

/** @internal */
export const ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationSecurity$outboundSchema:
  z.ZodMiniType<
    ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationSecurity$Outbound,
    ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationSecurity
  > = z.pipe(
    z.object({
      secretAPIKey: z.optional(z.string()),
      authorization: z.optional(z.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        secretAPIKey: "Secret_API_key",
      });
    }),
  );

export function comCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationSecurityToJSON(
  comCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationSecurity:
    ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationSecurity,
): string {
  return JSON.stringify(
    ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationSecurity$outboundSchema
      .parse(
        comCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationSecurity,
      ),
  );
}

/** @internal */
export type ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationRequest$Outbound =
  {
    estimation_id: string;
    include_creatives?: boolean | undefined;
    include_cross_sells?: boolean | undefined;
    include_promotions?: boolean | undefined;
    include_reward_offers?: boolean | undefined;
    include_upsells?: boolean | undefined;
    order_catalogue_ids?: string | undefined;
  };

/** @internal */
export const ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationRequest$outboundSchema:
  z.ZodMiniType<
    ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationRequest$Outbound,
    ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationRequest
  > = z.pipe(
    z.object({
      estimationId: z.string(),
      includeCreatives: z.optional(z.boolean()),
      includeCrossSells: z.optional(z.boolean()),
      includePromotions: z.optional(z.boolean()),
      includeRewardOffers: z.optional(z.boolean()),
      includeUpsells: z.optional(z.boolean()),
      orderCatalogueIds: z.optional(z.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        estimationId: "estimation_id",
        includeCreatives: "include_creatives",
        includeCrossSells: "include_cross_sells",
        includePromotions: "include_promotions",
        includeRewardOffers: "include_reward_offers",
        includeUpsells: "include_upsells",
        orderCatalogueIds: "order_catalogue_ids",
      });
    }),
  );

export function comCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationRequestToJSON(
  comCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationRequest:
    ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationRequest,
): string {
  return JSON.stringify(
    ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationRequest$outboundSchema
      .parse(
        comCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationRequest,
      ),
  );
}

/** @internal */
export const CrossSellPriceModel$inboundSchema: z.ZodMiniType<
  CrossSellPriceModel,
  unknown
> = openEnums.inboundSchema(CrossSellPriceModel);

/** @internal */
export const CrossSellCurrencyCode$inboundSchema: z.ZodMiniType<
  CrossSellCurrencyCode,
  unknown
> = openEnums.inboundSchema(CrossSellCurrencyCode);

/** @internal */
export const CrossSellTaxModel$inboundSchema: z.ZodMiniType<
  CrossSellTaxModel,
  unknown
> = openEnums.inboundSchema(CrossSellTaxModel);

/** @internal */
export const CrossSellTiers$inboundSchema: z.ZodMiniType<
  CrossSellTiers,
  unknown
> = z.pipe(
  z.object({
    upper_tier: types.optional(types.number()),
    number_of_tiers: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "upper_tier": "upperTier",
      "number_of_tiers": "numberOfTiers",
    });
  }),
);

export function crossSellTiersFromJSON(
  jsonString: string,
): SafeParseResult<CrossSellTiers, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CrossSellTiers$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CrossSellTiers' from JSON`,
  );
}

/** @internal */
export const CrossSellUot$inboundSchema: z.ZodMiniType<CrossSellUot, unknown> =
  openEnums.inboundSchema(CrossSellUot);

/** @internal */
export const CrossSellBillingPeriod$inboundSchema: z.ZodMiniType<
  CrossSellBillingPeriod,
  unknown
> = z.object({
  duration: types.optional(types.number()),
  uot: types.optional(CrossSellUot$inboundSchema),
});

export function crossSellBillingPeriodFromJSON(
  jsonString: string,
): SafeParseResult<CrossSellBillingPeriod, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CrossSellBillingPeriod$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CrossSellBillingPeriod' from JSON`,
  );
}

/** @internal */
export const CrossSellMeasurementUnit$inboundSchema: z.ZodMiniType<
  CrossSellMeasurementUnit,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    display_name: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "display_name": "displayName",
    });
  }),
);

export function crossSellMeasurementUnitFromJSON(
  jsonString: string,
): SafeParseResult<CrossSellMeasurementUnit, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CrossSellMeasurementUnit$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CrossSellMeasurementUnit' from JSON`,
  );
}

/** @internal */
export const CrossSellAccessPeriod$inboundSchema: z.ZodMiniType<
  CrossSellAccessPeriod,
  unknown
> = z.pipe(
  z.object({
    start_date: types.optional(types.number()),
    end_date: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "start_date": "startDate",
      "end_date": "endDate",
    });
  }),
);

export function crossSellAccessPeriodFromJSON(
  jsonString: string,
): SafeParseResult<CrossSellAccessPeriod, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CrossSellAccessPeriod$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CrossSellAccessPeriod' from JSON`,
  );
}

/** @internal */
export const CrossSellOrderQueue$inboundSchema: z.ZodMiniType<
  CrossSellOrderQueue,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
});

export function crossSellOrderQueueFromJSON(
  jsonString: string,
): SafeParseResult<CrossSellOrderQueue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CrossSellOrderQueue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CrossSellOrderQueue' from JSON`,
  );
}

/** @internal */
export const CrossSellPricing$inboundSchema: z.ZodMiniType<
  CrossSellPricing,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    price_model: types.optional(CrossSellPriceModel$inboundSchema),
    currency_code: types.optional(CrossSellCurrencyCode$inboundSchema),
    tax_model: types.optional(CrossSellTaxModel$inboundSchema),
    price: types.optional(types.number()),
    tiers: types.optional(z.lazy(() => CrossSellTiers$inboundSchema)),
    billing_period: types.optional(
      z.lazy(() => CrossSellBillingPeriod$inboundSchema),
    ),
    measurement_unit: types.optional(
      z.lazy(() => CrossSellMeasurementUnit$inboundSchema),
    ),
    access_period: types.optional(
      z.lazy(() => CrossSellAccessPeriod$inboundSchema),
    ),
    order_queue: types.optional(
      z.lazy(() => CrossSellOrderQueue$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "price_model": "priceModel",
      "currency_code": "currencyCode",
      "tax_model": "taxModel",
      "billing_period": "billingPeriod",
      "measurement_unit": "measurementUnit",
      "access_period": "accessPeriod",
      "order_queue": "orderQueue",
    });
  }),
);

export function crossSellPricingFromJSON(
  jsonString: string,
): SafeParseResult<CrossSellPricing, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CrossSellPricing$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CrossSellPricing' from JSON`,
  );
}

/** @internal */
export const CrossSellUsageType$inboundSchema: z.ZodMiniType<
  CrossSellUsageType,
  unknown
> = openEnums.inboundSchema(CrossSellUsageType);

/** @internal */
export const CrossSellMedia$inboundSchema: z.ZodMiniType<
  CrossSellMedia,
  unknown
> = z.object({
  width: types.optional(types.number()),
  height: types.optional(types.number()),
  url: types.optional(types.string()),
});

export function crossSellMediaFromJSON(
  jsonString: string,
): SafeParseResult<CrossSellMedia, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CrossSellMedia$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CrossSellMedia' from JSON`,
  );
}

/** @internal */
export const CrossSellCreative$inboundSchema: z.ZodMiniType<
  CrossSellCreative,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    media_group_id: types.optional(types.string()),
    usage_type: types.optional(CrossSellUsageType$inboundSchema),
    width: types.optional(types.number()),
    height: types.optional(types.number()),
    format: types.optional(types.string()),
    url: types.optional(types.string()),
    public_id: types.optional(types.string()),
    media_id: types.optional(types.string()),
    caption: types.optional(types.string()),
    sort_order: types.optional(types.number()),
    media: types.optional(z.array(z.lazy(() => CrossSellMedia$inboundSchema))),
  }),
  z.transform((v) => {
    return remap$(v, {
      "media_group_id": "mediaGroupId",
      "usage_type": "usageType",
      "public_id": "publicId",
      "media_id": "mediaId",
      "sort_order": "sortOrder",
    });
  }),
);

export function crossSellCreativeFromJSON(
  jsonString: string,
): SafeParseResult<CrossSellCreative, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CrossSellCreative$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CrossSellCreative' from JSON`,
  );
}

/** @internal */
export const ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationCrossSell$inboundSchema:
  z.ZodMiniType<
    ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationCrossSell,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    sku: types.optional(types.string()),
    name: types.optional(types.string()),
    description: types.optional(types.string()),
    pricing: types.optional(z.lazy(() => CrossSellPricing$inboundSchema)),
    creatives: types.optional(
      z.array(z.lazy(() => CrossSellCreative$inboundSchema)),
    ),
  });

export function comCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationCrossSellFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationCrossSell,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationCrossSell$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationCrossSell' from JSON`,
  );
}

/** @internal */
export const UpsellPriceModel$inboundSchema: z.ZodMiniType<
  UpsellPriceModel,
  unknown
> = openEnums.inboundSchema(UpsellPriceModel);

/** @internal */
export const UpsellCurrencyCode$inboundSchema: z.ZodMiniType<
  UpsellCurrencyCode,
  unknown
> = openEnums.inboundSchema(UpsellCurrencyCode);

/** @internal */
export const UpsellTaxModel$inboundSchema: z.ZodMiniType<
  UpsellTaxModel,
  unknown
> = openEnums.inboundSchema(UpsellTaxModel);

/** @internal */
export const UpsellTiers$inboundSchema: z.ZodMiniType<UpsellTiers, unknown> = z
  .pipe(
    z.object({
      upper_tier: types.optional(types.number()),
      number_of_tiers: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "upper_tier": "upperTier",
        "number_of_tiers": "numberOfTiers",
      });
    }),
  );

export function upsellTiersFromJSON(
  jsonString: string,
): SafeParseResult<UpsellTiers, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpsellTiers$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpsellTiers' from JSON`,
  );
}

/** @internal */
export const UpsellUot$inboundSchema: z.ZodMiniType<UpsellUot, unknown> =
  openEnums.inboundSchema(UpsellUot);

/** @internal */
export const UpsellBillingPeriod$inboundSchema: z.ZodMiniType<
  UpsellBillingPeriod,
  unknown
> = z.object({
  duration: types.optional(types.number()),
  uot: types.optional(UpsellUot$inboundSchema),
});

export function upsellBillingPeriodFromJSON(
  jsonString: string,
): SafeParseResult<UpsellBillingPeriod, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpsellBillingPeriod$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpsellBillingPeriod' from JSON`,
  );
}

/** @internal */
export const UpsellMeasurementUnit$inboundSchema: z.ZodMiniType<
  UpsellMeasurementUnit,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    display_name: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "display_name": "displayName",
    });
  }),
);

export function upsellMeasurementUnitFromJSON(
  jsonString: string,
): SafeParseResult<UpsellMeasurementUnit, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpsellMeasurementUnit$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpsellMeasurementUnit' from JSON`,
  );
}

/** @internal */
export const UpsellAccessPeriod$inboundSchema: z.ZodMiniType<
  UpsellAccessPeriod,
  unknown
> = z.pipe(
  z.object({
    start_date: types.optional(types.number()),
    end_date: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "start_date": "startDate",
      "end_date": "endDate",
    });
  }),
);

export function upsellAccessPeriodFromJSON(
  jsonString: string,
): SafeParseResult<UpsellAccessPeriod, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpsellAccessPeriod$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpsellAccessPeriod' from JSON`,
  );
}

/** @internal */
export const UpsellOrderQueue$inboundSchema: z.ZodMiniType<
  UpsellOrderQueue,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
});

export function upsellOrderQueueFromJSON(
  jsonString: string,
): SafeParseResult<UpsellOrderQueue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpsellOrderQueue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpsellOrderQueue' from JSON`,
  );
}

/** @internal */
export const UpsellPricing$inboundSchema: z.ZodMiniType<
  UpsellPricing,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    price_model: types.optional(UpsellPriceModel$inboundSchema),
    currency_code: types.optional(UpsellCurrencyCode$inboundSchema),
    tax_model: types.optional(UpsellTaxModel$inboundSchema),
    price: types.optional(types.number()),
    tiers: types.optional(z.lazy(() => UpsellTiers$inboundSchema)),
    billing_period: types.optional(
      z.lazy(() => UpsellBillingPeriod$inboundSchema),
    ),
    measurement_unit: types.optional(
      z.lazy(() => UpsellMeasurementUnit$inboundSchema),
    ),
    access_period: types.optional(
      z.lazy(() => UpsellAccessPeriod$inboundSchema),
    ),
    order_queue: types.optional(z.lazy(() => UpsellOrderQueue$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "price_model": "priceModel",
      "currency_code": "currencyCode",
      "tax_model": "taxModel",
      "billing_period": "billingPeriod",
      "measurement_unit": "measurementUnit",
      "access_period": "accessPeriod",
      "order_queue": "orderQueue",
    });
  }),
);

export function upsellPricingFromJSON(
  jsonString: string,
): SafeParseResult<UpsellPricing, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpsellPricing$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpsellPricing' from JSON`,
  );
}

/** @internal */
export const UpsellUsageType$inboundSchema: z.ZodMiniType<
  UpsellUsageType,
  unknown
> = openEnums.inboundSchema(UpsellUsageType);

/** @internal */
export const UpsellMedia$inboundSchema: z.ZodMiniType<UpsellMedia, unknown> = z
  .object({
    width: types.optional(types.number()),
    height: types.optional(types.number()),
    url: types.optional(types.string()),
  });

export function upsellMediaFromJSON(
  jsonString: string,
): SafeParseResult<UpsellMedia, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpsellMedia$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpsellMedia' from JSON`,
  );
}

/** @internal */
export const UpsellCreative$inboundSchema: z.ZodMiniType<
  UpsellCreative,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    media_group_id: types.optional(types.string()),
    usage_type: types.optional(UpsellUsageType$inboundSchema),
    width: types.optional(types.number()),
    height: types.optional(types.number()),
    format: types.optional(types.string()),
    url: types.optional(types.string()),
    public_id: types.optional(types.string()),
    media_id: types.optional(types.string()),
    caption: types.optional(types.string()),
    sort_order: types.optional(types.number()),
    media: types.optional(z.array(z.lazy(() => UpsellMedia$inboundSchema))),
  }),
  z.transform((v) => {
    return remap$(v, {
      "media_group_id": "mediaGroupId",
      "usage_type": "usageType",
      "public_id": "publicId",
      "media_id": "mediaId",
      "sort_order": "sortOrder",
    });
  }),
);

export function upsellCreativeFromJSON(
  jsonString: string,
): SafeParseResult<UpsellCreative, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpsellCreative$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpsellCreative' from JSON`,
  );
}

/** @internal */
export const ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationUpsell$inboundSchema:
  z.ZodMiniType<
    ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationUpsell,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    sku: types.optional(types.string()),
    name: types.optional(types.string()),
    description: types.optional(types.string()),
    pricing: types.optional(z.lazy(() => UpsellPricing$inboundSchema)),
    creatives: types.optional(
      z.array(z.lazy(() => UpsellCreative$inboundSchema)),
    ),
  });

export function comCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationUpsellFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationUpsell,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationUpsell$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationUpsell' from JSON`,
  );
}

/** @internal */
export const RewardOfferUsageType$inboundSchema: z.ZodMiniType<
  RewardOfferUsageType,
  unknown
> = openEnums.inboundSchema(RewardOfferUsageType);

/** @internal */
export const RewardOfferMedia$inboundSchema: z.ZodMiniType<
  RewardOfferMedia,
  unknown
> = z.object({
  width: types.optional(types.number()),
  height: types.optional(types.number()),
  url: types.optional(types.string()),
});

export function rewardOfferMediaFromJSON(
  jsonString: string,
): SafeParseResult<RewardOfferMedia, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RewardOfferMedia$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RewardOfferMedia' from JSON`,
  );
}

/** @internal */
export const RewardOfferCreative$inboundSchema: z.ZodMiniType<
  RewardOfferCreative,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    media_group_id: types.optional(types.string()),
    usage_type: types.optional(RewardOfferUsageType$inboundSchema),
    width: types.optional(types.number()),
    height: types.optional(types.number()),
    format: types.optional(types.string()),
    url: types.optional(types.string()),
    public_id: types.optional(types.string()),
    media_id: types.optional(types.string()),
    caption: types.optional(types.string()),
    sort_order: types.optional(types.number()),
    media: types.optional(
      z.array(z.lazy(() => RewardOfferMedia$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "media_group_id": "mediaGroupId",
      "usage_type": "usageType",
      "public_id": "publicId",
      "media_id": "mediaId",
      "sort_order": "sortOrder",
    });
  }),
);

export function rewardOfferCreativeFromJSON(
  jsonString: string,
): SafeParseResult<RewardOfferCreative, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RewardOfferCreative$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RewardOfferCreative' from JSON`,
  );
}

/** @internal */
export const ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationRewardOffer$inboundSchema:
  z.ZodMiniType<
    ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationRewardOffer,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    creatives: types.optional(
      z.array(z.lazy(() => RewardOfferCreative$inboundSchema)),
    ),
  });

export function comCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationRewardOfferFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationRewardOffer,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationRewardOffer$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationRewardOffer' from JSON`,
  );
}

/** @internal */
export const PromotionUsageType$inboundSchema: z.ZodMiniType<
  PromotionUsageType,
  unknown
> = openEnums.inboundSchema(PromotionUsageType);

/** @internal */
export const PromotionMedia$inboundSchema: z.ZodMiniType<
  PromotionMedia,
  unknown
> = z.object({
  width: types.optional(types.number()),
  height: types.optional(types.number()),
  url: types.optional(types.string()),
});

export function promotionMediaFromJSON(
  jsonString: string,
): SafeParseResult<PromotionMedia, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PromotionMedia$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PromotionMedia' from JSON`,
  );
}

/** @internal */
export const PromotionCreative$inboundSchema: z.ZodMiniType<
  PromotionCreative,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    media_group_id: types.optional(types.string()),
    usage_type: types.optional(PromotionUsageType$inboundSchema),
    width: types.optional(types.number()),
    height: types.optional(types.number()),
    format: types.optional(types.string()),
    url: types.optional(types.string()),
    public_id: types.optional(types.string()),
    media_id: types.optional(types.string()),
    caption: types.optional(types.string()),
    sort_order: types.optional(types.number()),
    media: types.optional(z.array(z.lazy(() => PromotionMedia$inboundSchema))),
  }),
  z.transform((v) => {
    return remap$(v, {
      "media_group_id": "mediaGroupId",
      "usage_type": "usageType",
      "public_id": "publicId",
      "media_id": "mediaId",
      "sort_order": "sortOrder",
    });
  }),
);

export function promotionCreativeFromJSON(
  jsonString: string,
): SafeParseResult<PromotionCreative, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PromotionCreative$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PromotionCreative' from JSON`,
  );
}

/** @internal */
export const ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationPromotion$inboundSchema:
  z.ZodMiniType<
    ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationPromotion,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    creatives: types.optional(
      z.array(z.lazy(() => PromotionCreative$inboundSchema)),
    ),
  });

export function comCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationPromotionFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationPromotion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationPromotion$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationPromotion' from JSON`,
  );
}

/** @internal */
export const ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationResponse$inboundSchema:
  z.ZodMiniType<
    ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationResponse,
    unknown
  > = z.pipe(
    z.object({
      cross_sells: types.optional(z.array(z.lazy(() =>
        ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationCrossSell$inboundSchema
      ))),
      upsells: types.optional(z.array(z.lazy(() =>
        ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationUpsell$inboundSchema
      ))),
      reward_offers: types.optional(z.array(z.lazy(() =>
        ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationRewardOffer$inboundSchema
      ))),
      promotions: types.optional(z.array(z.lazy(() =>
        ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationPromotion$inboundSchema
      ))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "cross_sells": "crossSells",
        "reward_offers": "rewardOffers",
      });
    }),
  );

export function comCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationResponse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmOrderProductRecommendationSelfServiceResourceGetOrderProductRecommendationResponse' from JSON`,
  );
}
