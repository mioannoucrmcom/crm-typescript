/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

/**
 * The intent for which such token is requested
 */
export const AddContactTokenSSIntent = {
  ApprovePurchase: "APPROVE_PURCHASE",
  RejectPurchase: "REJECT_PURCHASE",
  Spend: "SPEND",
} as const;
/**
 * The intent for which such token is requested
 */
export type AddContactTokenSSIntent = ClosedEnum<
  typeof AddContactTokenSSIntent
>;

/**
 * The purchase that will be approved (applicable if intent = APPROVE_PURCHASE)
 */
export type AddContactTokenSSPurchase = {
  /**
   * The purchase estimate (identifier) that will be approved
   */
  estimateId: string;
};

export type AddContactTokenSSRequestBody = {
  /**
   * The intent for which such token is requested
   */
  intent: AddContactTokenSSIntent;
  /**
   * The amount requested to be spent. If not specified, then spend as much as possible (applicable if intent = SPEND)
   */
  spendAmount?: number | null | undefined;
  /**
   * The purchase that will be approved (applicable if intent = APPROVE_PURCHASE)
   */
  purchase?: AddContactTokenSSPurchase | undefined;
  /**
   * The community owner (contact identifier) that the contact performed such purchase is a member to and has wallet allowance to spend (applicable and required when the contact of the purchase is a member to multiple communities and wants to use wallet allowance from a specific community)
   */
  communityId?: string | undefined;
};

export type AddContactTokenSSRequest = {
  /**
   * The id of the contact to create a token for
   */
  id: string;
  body?: AddContactTokenSSRequestBody | undefined;
};

/**
 * OK
 */
export type AddContactTokenSSResponse = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The requested token
   */
  value?: string | undefined;
  /**
   * A 16-digit numeric code that can be used instead of the token value
   */
  alternativeToken?: string | undefined;
  /**
   * The token expiration date
   */
  expiration?: number | undefined;
  /**
   * The amount requested to be spent
   */
  spendAmount?: number | undefined;
};

/** @internal */
export const AddContactTokenSSIntent$outboundSchema: z.ZodMiniEnum<
  typeof AddContactTokenSSIntent
> = z.enum(AddContactTokenSSIntent);

/** @internal */
export type AddContactTokenSSPurchase$Outbound = {
  estimate_id: string;
};

/** @internal */
export const AddContactTokenSSPurchase$outboundSchema: z.ZodMiniType<
  AddContactTokenSSPurchase$Outbound,
  AddContactTokenSSPurchase
> = z.pipe(
  z.object({
    estimateId: z.string(),
  }),
  z.transform((v) => {
    return remap$(v, {
      estimateId: "estimate_id",
    });
  }),
);

export function addContactTokenSSPurchaseToJSON(
  addContactTokenSSPurchase: AddContactTokenSSPurchase,
): string {
  return JSON.stringify(
    AddContactTokenSSPurchase$outboundSchema.parse(addContactTokenSSPurchase),
  );
}

/** @internal */
export type AddContactTokenSSRequestBody$Outbound = {
  intent: string;
  spend_amount?: number | null | undefined;
  purchase?: AddContactTokenSSPurchase$Outbound | undefined;
  community_id?: string | undefined;
};

/** @internal */
export const AddContactTokenSSRequestBody$outboundSchema: z.ZodMiniType<
  AddContactTokenSSRequestBody$Outbound,
  AddContactTokenSSRequestBody
> = z.pipe(
  z.object({
    intent: AddContactTokenSSIntent$outboundSchema,
    spendAmount: z.optional(z.nullable(z.number())),
    purchase: z.optional(
      z.lazy(() => AddContactTokenSSPurchase$outboundSchema),
    ),
    communityId: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      spendAmount: "spend_amount",
      communityId: "community_id",
    });
  }),
);

export function addContactTokenSSRequestBodyToJSON(
  addContactTokenSSRequestBody: AddContactTokenSSRequestBody,
): string {
  return JSON.stringify(
    AddContactTokenSSRequestBody$outboundSchema.parse(
      addContactTokenSSRequestBody,
    ),
  );
}

/** @internal */
export type AddContactTokenSSRequest$Outbound = {
  id: string;
  body?: AddContactTokenSSRequestBody$Outbound | undefined;
};

/** @internal */
export const AddContactTokenSSRequest$outboundSchema: z.ZodMiniType<
  AddContactTokenSSRequest$Outbound,
  AddContactTokenSSRequest
> = z.object({
  id: z.string(),
  body: z.optional(z.lazy(() => AddContactTokenSSRequestBody$outboundSchema)),
});

export function addContactTokenSSRequestToJSON(
  addContactTokenSSRequest: AddContactTokenSSRequest,
): string {
  return JSON.stringify(
    AddContactTokenSSRequest$outboundSchema.parse(addContactTokenSSRequest),
  );
}

/** @internal */
export const AddContactTokenSSResponse$inboundSchema: z.ZodMiniType<
  AddContactTokenSSResponse,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    value: types.optional(types.string()),
    alternative_token: types.optional(types.string()),
    expiration: types.optional(types.number()),
    spend_amount: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "alternative_token": "alternativeToken",
      "spend_amount": "spendAmount",
    });
  }),
);

export function addContactTokenSSResponseFromJSON(
  jsonString: string,
): SafeParseResult<AddContactTokenSSResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AddContactTokenSSResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AddContactTokenSSResponse' from JSON`,
  );
}
