/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 * @generated-id: 72569f3de68c
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

export type ComCrmContactSelfServiceResourceAuthenticateSecurity = {
  publicAPIKey: string;
};

/**
 * The contact’s identity provider
 */
export const ComCrmContactSelfServiceResourceAuthenticateProvider = {
  Email: "EMAIL",
  Phone: "PHONE",
  Facebook: "FACEBOOK",
  Apple: "APPLE",
  Google: "GOOGLE",
  MacAddress: "MAC_ADDRESS",
  OidcOauth: "OIDC_OAUTH",
} as const;
/**
 * The contact’s identity provider
 */
export type ComCrmContactSelfServiceResourceAuthenticateProvider = ClosedEnum<
  typeof ComCrmContactSelfServiceResourceAuthenticateProvider
>;

/**
 * The contact’s phone country code
 */
export const ComCrmContactSelfServiceResourceAuthenticateCountryCode = {
  Abw: "ABW",
  Afg: "AFG",
  Ago: "AGO",
  Aia: "AIA",
  Ala: "ALA",
  Alb: "ALB",
  And: "AND",
  Ant: "ANT",
  Are: "ARE",
  Arg: "ARG",
  Arm: "ARM",
  Asm: "ASM",
  Ata: "ATA",
  Atf: "ATF",
  Atg: "ATG",
  Aus: "AUS",
  Aut: "AUT",
  Aze: "AZE",
  Bdi: "BDI",
  Bel: "BEL",
  Ben: "BEN",
  Bes: "BES",
  Bfa: "BFA",
  Bgd: "BGD",
  Bgr: "BGR",
  Bhr: "BHR",
  Bhs: "BHS",
  Bih: "BIH",
  Blm: "BLM",
  Blr: "BLR",
  Blz: "BLZ",
  Bmu: "BMU",
  Bol: "BOL",
  Bra: "BRA",
  Brb: "BRB",
  Brn: "BRN",
  Btn: "BTN",
  Bvt: "BVT",
  Bwa: "BWA",
  Caf: "CAF",
  Can: "CAN",
  Cck: "CCK",
  Che: "CHE",
  Chl: "CHL",
  Chn: "CHN",
  Civ: "CIV",
  Cmr: "CMR",
  Cod: "COD",
  Cog: "COG",
  Cok: "COK",
  Col: "COL",
  Com: "COM",
  Cpv: "CPV",
  Cri: "CRI",
  Cub: "CUB",
  Cuw: "CUW",
  Cxr: "CXR",
  Cym: "CYM",
  Cyp: "CYP",
  Cze: "CZE",
  Deu: "DEU",
  Dji: "DJI",
  Dma: "DMA",
  Dnk: "DNK",
  Dom: "DOM",
  Dza: "DZA",
  Ecu: "ECU",
  Egy: "EGY",
  Eri: "ERI",
  Esh: "ESH",
  Esp: "ESP",
  Est: "EST",
  Eth: "ETH",
  Fin: "FIN",
  Fji: "FJI",
  Flk: "FLK",
  Fra: "FRA",
  Fro: "FRO",
  Fsm: "FSM",
  Gab: "GAB",
  Gbr: "GBR",
  Geo: "GEO",
  Ggy: "GGY",
  Gha: "GHA",
  Gib: "GIB",
  Gin: "GIN",
  Glp: "GLP",
  Gmb: "GMB",
  Gnb: "GNB",
  Gnq: "GNQ",
  Grc: "GRC",
  Grd: "GRD",
  Grl: "GRL",
  Gtm: "GTM",
  Guf: "GUF",
  Gum: "GUM",
  Guy: "GUY",
  Hkg: "HKG",
  Hmd: "HMD",
  Hnd: "HND",
  Hrv: "HRV",
  Hti: "HTI",
  Hun: "HUN",
  Idn: "IDN",
  Imn: "IMN",
  Ind: "IND",
  Iot: "IOT",
  Irl: "IRL",
  Irn: "IRN",
  Irq: "IRQ",
  Isl: "ISL",
  Isr: "ISR",
  Ita: "ITA",
  Jam: "JAM",
  Jey: "JEY",
  Jor: "JOR",
  Jpn: "JPN",
  Kaz: "KAZ",
  Ken: "KEN",
  Kgz: "KGZ",
  Khm: "KHM",
  Kir: "KIR",
  Kna: "KNA",
  Kor: "KOR",
  Kwt: "KWT",
  Lao: "LAO",
  Lbn: "LBN",
  Lbr: "LBR",
  Lby: "LBY",
  Lca: "LCA",
  Lie: "LIE",
  Lka: "LKA",
  Lso: "LSO",
  Ltu: "LTU",
  Lux: "LUX",
  Lva: "LVA",
  Mac: "MAC",
  Maf: "MAF",
  Mar: "MAR",
  Mco: "MCO",
  Mda: "MDA",
  Mdg: "MDG",
  Mdv: "MDV",
  Mex: "MEX",
  Mhl: "MHL",
  Mkd: "MKD",
  Mli: "MLI",
  Mlt: "MLT",
  Mmr: "MMR",
  Mne: "MNE",
  Mng: "MNG",
  Mnp: "MNP",
  Moz: "MOZ",
  Mrt: "MRT",
  Msr: "MSR",
  Mtq: "MTQ",
  Mus: "MUS",
  Mwi: "MWI",
  Mys: "MYS",
  Myt: "MYT",
  Nam: "NAM",
  Ncl: "NCL",
  Ner: "NER",
  Nfk: "NFK",
  Nga: "NGA",
  Nic: "NIC",
  Niu: "NIU",
  Nld: "NLD",
  Nor: "NOR",
  Npl: "NPL",
  Nru: "NRU",
  Nzl: "NZL",
  Omn: "OMN",
  Pak: "PAK",
  Pan: "PAN",
  Pcn: "PCN",
  Per: "PER",
  Phl: "PHL",
  Plw: "PLW",
  Png: "PNG",
  Pol: "POL",
  Pri: "PRI",
  Prk: "PRK",
  Prt: "PRT",
  Pry: "PRY",
  Pse: "PSE",
  Pyf: "PYF",
  Qat: "QAT",
  Reu: "REU",
  Rks: "RKS",
  Rou: "ROU",
  Rus: "RUS",
  Rwa: "RWA",
  Sau: "SAU",
  Sdn: "SDN",
  Sen: "SEN",
  Sgp: "SGP",
  Sgs: "SGS",
  Shn: "SHN",
  Sjm: "SJM",
  Slb: "SLB",
  Sle: "SLE",
  Slv: "SLV",
  Smr: "SMR",
  Som: "SOM",
  Spm: "SPM",
  Srb: "SRB",
  Ssd: "SSD",
  Stp: "STP",
  Sur: "SUR",
  Svk: "SVK",
  Svn: "SVN",
  Swe: "SWE",
  Swz: "SWZ",
  Sxm: "SXM",
  Syc: "SYC",
  Syr: "SYR",
  Tca: "TCA",
  Tcd: "TCD",
  Tgo: "TGO",
  Tha: "THA",
  Tjk: "TJK",
  Tkl: "TKL",
  Tkm: "TKM",
  Tls: "TLS",
  Ton: "TON",
  Tto: "TTO",
  Tun: "TUN",
  Tur: "TUR",
  Tuv: "TUV",
  Twn: "TWN",
  Tza: "TZA",
  Uga: "UGA",
  Ukr: "UKR",
  Umi: "UMI",
  Ury: "URY",
  Usa: "USA",
  Uzb: "UZB",
  Vat: "VAT",
  Vct: "VCT",
  Ven: "VEN",
  Vgb: "VGB",
  Vir: "VIR",
  Vnm: "VNM",
  Vut: "VUT",
  Wlf: "WLF",
  Wsm: "WSM",
  Yem: "YEM",
  Zaf: "ZAF",
  Zmb: "ZMB",
  Zwe: "ZWE",
} as const;
/**
 * The contact’s phone country code
 */
export type ComCrmContactSelfServiceResourceAuthenticateCountryCode =
  ClosedEnum<typeof ComCrmContactSelfServiceResourceAuthenticateCountryCode>;

/**
 * The contact’s phone
 */
export type ComCrmContactSelfServiceResourceAuthenticatePhone = {
  /**
   * The contact’s phone number
   */
  number: string;
  /**
   * The contact’s phone country code
   */
  countryCode: ComCrmContactSelfServiceResourceAuthenticateCountryCode;
};

export type ComCrmContactSelfServiceResourceAuthenticateRequestBody = {
  /**
   * The contact’s identity provider
   */
  provider: ComCrmContactSelfServiceResourceAuthenticateProvider;
  /**
   * The contact’s username (applicable for EMAIL providers). If password not provided then OTP request is triggered.
   */
  username: string | null;
  /**
   * The contact’s password (applicable for EMAIL providers)
   */
  password: string | null;
  /**
   * The token taken from the oAUTH service provider (applicable for Facebook/Google/MW4 providers)
   */
  token: string | null;
  /**
   * The application (identifier), used for app stores verification (i.e. Apple Store requests a demo contact for verifying CRM.COM applications before publishing it over to their store; demo contacts can be specified from the CRM.COM application configuration settings)
   */
  applicationId?: string | null | undefined;
  /**
   * The contact’s phone
   */
  phone: ComCrmContactSelfServiceResourceAuthenticatePhone | null;
  /**
   * The contact’s device mac address (applicable for MAC_ADDRESS providers)
   */
  macAddress: string | null;
  /**
   * When set to true, the authentication endpoint will bypass traditional user‐credential checks and instead initiate a temporary “guest” session. This allows anonymous users to interact with the platform
   */
  loginAsGuest?: boolean | null | undefined;
  /**
   * Code returned by OIDC Provider
   */
  code?: string | undefined;
  /**
   * State returned by OIDC Provider. Applicable for single-sign-on authentications only
   */
  state?: string | undefined;
};

export type ComCrmContactSelfServiceResourceAuthenticateRequest = {
  apiKey?: string | undefined;
  body: ComCrmContactSelfServiceResourceAuthenticateRequestBody;
};

/**
 * Contact type - can be PERSON or COMPANY
 */
export const ComCrmContactSelfServiceResourceAuthenticateContactType = {
  Person: "PERSON",
  Company: "COMPANY",
} as const;
/**
 * Contact type - can be PERSON or COMPANY
 */
export type ComCrmContactSelfServiceResourceAuthenticateContactType = OpenEnum<
  typeof ComCrmContactSelfServiceResourceAuthenticateContactType
>;

/**
 * The authorised contact details
 */
export type ComCrmContactSelfServiceResourceAuthenticateContact = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * Contact type - can be PERSON or COMPANY
   */
  type?: ComCrmContactSelfServiceResourceAuthenticateContactType | undefined;
  /**
   * The contact’s first name
   */
  firstName?: string | undefined;
  /**
   * The contact’s last name
   */
  lastName?: string | undefined;
  /**
   * Defines whether the used identity is verified
   */
  isVerified?: boolean | undefined;
  /**
   * The company name if the contact type is 'COMPANY'
   */
  companyName?: string | undefined;
};

/**
 * The organisation type
 */
export const ComCrmContactSelfServiceResourceAuthenticateOrganisationType = {
  Operator: "OPERATOR",
  ServiceOwner: "SERVICE_OWNER",
  TransactionProcessor: "TRANSACTION_PROCESSOR",
  Business: "BUSINESS",
  Organisation: "ORGANISATION",
  Merchant: "MERCHANT",
  Venue: "VENUE",
} as const;
/**
 * The organisation type
 */
export type ComCrmContactSelfServiceResourceAuthenticateOrganisationType =
  OpenEnum<typeof ComCrmContactSelfServiceResourceAuthenticateOrganisationType>;

export type ComCrmContactSelfServiceResourceAuthenticateOrganisation = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The organisation type
   */
  type?:
    | ComCrmContactSelfServiceResourceAuthenticateOrganisationType
    | undefined;
  /**
   * The organisation name
   */
  name?: string | undefined;
};

export type ComCrmContactSelfServiceResourceAuthenticateCommunity = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
};

/**
 * OK
 */
export type ComCrmContactSelfServiceResourceAuthenticateResponse = {
  /**
   * The access token that can be used in subsequent API calls
   */
  accessToken?: string | undefined;
  /**
   * The token that can be used to generate a new access token (when previous is expired)
   */
  refreshToken?: string | undefined;
  /**
   * The token expiration date
   */
  expirationDate?: number | undefined;
  /**
   * The authorised contact details
   */
  contact?: ComCrmContactSelfServiceResourceAuthenticateContact | undefined;
  /**
   * Details about the organisations that the contact has joined
   */
  organisations?:
    | Array<ComCrmContactSelfServiceResourceAuthenticateOrganisation>
    | undefined;
  /**
   * Details about the contact communities that the contact is a member of
   */
  communities?:
    | Array<ComCrmContactSelfServiceResourceAuthenticateCommunity>
    | undefined;
  /**
   * The obfuscated send method value (applicable only when provider is EMAIL or PHONE and an OTP is generated)
   */
  obfuscatedValue?: string | undefined;
  /**
   * The one time password auth id (applicable only when provider is EMAIL or PHONE and an OTP is generated)
   */
  authOtp?: string | undefined;
  /**
   * The contact exists in the business
   */
  existingContact?: boolean | undefined;
};

/** @internal */
export type ComCrmContactSelfServiceResourceAuthenticateSecurity$Outbound = {
  Public_API_key: string;
};

/** @internal */
export const ComCrmContactSelfServiceResourceAuthenticateSecurity$outboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceAuthenticateSecurity$Outbound,
    ComCrmContactSelfServiceResourceAuthenticateSecurity
  > = z.pipe(
    z.object({
      publicAPIKey: z.string(),
    }),
    z.transform((v) => {
      return remap$(v, {
        publicAPIKey: "Public_API_key",
      });
    }),
  );

export function comCrmContactSelfServiceResourceAuthenticateSecurityToJSON(
  comCrmContactSelfServiceResourceAuthenticateSecurity:
    ComCrmContactSelfServiceResourceAuthenticateSecurity,
): string {
  return JSON.stringify(
    ComCrmContactSelfServiceResourceAuthenticateSecurity$outboundSchema.parse(
      comCrmContactSelfServiceResourceAuthenticateSecurity,
    ),
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceAuthenticateProvider$outboundSchema:
  z.ZodMiniEnum<typeof ComCrmContactSelfServiceResourceAuthenticateProvider> = z
    .enum(ComCrmContactSelfServiceResourceAuthenticateProvider);

/** @internal */
export const ComCrmContactSelfServiceResourceAuthenticateCountryCode$outboundSchema:
  z.ZodMiniEnum<
    typeof ComCrmContactSelfServiceResourceAuthenticateCountryCode
  > = z.enum(ComCrmContactSelfServiceResourceAuthenticateCountryCode);

/** @internal */
export type ComCrmContactSelfServiceResourceAuthenticatePhone$Outbound = {
  number: string;
  country_code: string;
};

/** @internal */
export const ComCrmContactSelfServiceResourceAuthenticatePhone$outboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceAuthenticatePhone$Outbound,
    ComCrmContactSelfServiceResourceAuthenticatePhone
  > = z.pipe(
    z.object({
      number: z.string(),
      countryCode:
        ComCrmContactSelfServiceResourceAuthenticateCountryCode$outboundSchema,
    }),
    z.transform((v) => {
      return remap$(v, {
        countryCode: "country_code",
      });
    }),
  );

export function comCrmContactSelfServiceResourceAuthenticatePhoneToJSON(
  comCrmContactSelfServiceResourceAuthenticatePhone:
    ComCrmContactSelfServiceResourceAuthenticatePhone,
): string {
  return JSON.stringify(
    ComCrmContactSelfServiceResourceAuthenticatePhone$outboundSchema.parse(
      comCrmContactSelfServiceResourceAuthenticatePhone,
    ),
  );
}

/** @internal */
export type ComCrmContactSelfServiceResourceAuthenticateRequestBody$Outbound = {
  provider: string;
  username: string | null;
  password: string | null;
  token: string | null;
  application_id?: string | null | undefined;
  phone: ComCrmContactSelfServiceResourceAuthenticatePhone$Outbound | null;
  mac_address: string | null;
  login_as_guest?: boolean | null | undefined;
  code?: string | undefined;
  state?: string | undefined;
};

/** @internal */
export const ComCrmContactSelfServiceResourceAuthenticateRequestBody$outboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceAuthenticateRequestBody$Outbound,
    ComCrmContactSelfServiceResourceAuthenticateRequestBody
  > = z.pipe(
    z.object({
      provider:
        ComCrmContactSelfServiceResourceAuthenticateProvider$outboundSchema,
      username: z.nullable(z.string()),
      password: z.nullable(z.string()),
      token: z.nullable(z.string()),
      applicationId: z.optional(z.nullable(z.string())),
      phone: z.nullable(z.lazy(() =>
        ComCrmContactSelfServiceResourceAuthenticatePhone$outboundSchema
      )),
      macAddress: z.nullable(z.string()),
      loginAsGuest: z.optional(z.nullable(z.boolean())),
      code: z.optional(z.string()),
      state: z.optional(z.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        applicationId: "application_id",
        macAddress: "mac_address",
        loginAsGuest: "login_as_guest",
      });
    }),
  );

export function comCrmContactSelfServiceResourceAuthenticateRequestBodyToJSON(
  comCrmContactSelfServiceResourceAuthenticateRequestBody:
    ComCrmContactSelfServiceResourceAuthenticateRequestBody,
): string {
  return JSON.stringify(
    ComCrmContactSelfServiceResourceAuthenticateRequestBody$outboundSchema
      .parse(comCrmContactSelfServiceResourceAuthenticateRequestBody),
  );
}

/** @internal */
export type ComCrmContactSelfServiceResourceAuthenticateRequest$Outbound = {
  api_key?: string | undefined;
  body: ComCrmContactSelfServiceResourceAuthenticateRequestBody$Outbound;
};

/** @internal */
export const ComCrmContactSelfServiceResourceAuthenticateRequest$outboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceAuthenticateRequest$Outbound,
    ComCrmContactSelfServiceResourceAuthenticateRequest
  > = z.pipe(
    z.object({
      apiKey: z.optional(z.string()),
      body: z.lazy(() =>
        ComCrmContactSelfServiceResourceAuthenticateRequestBody$outboundSchema
      ),
    }),
    z.transform((v) => {
      return remap$(v, {
        apiKey: "api_key",
      });
    }),
  );

export function comCrmContactSelfServiceResourceAuthenticateRequestToJSON(
  comCrmContactSelfServiceResourceAuthenticateRequest:
    ComCrmContactSelfServiceResourceAuthenticateRequest,
): string {
  return JSON.stringify(
    ComCrmContactSelfServiceResourceAuthenticateRequest$outboundSchema.parse(
      comCrmContactSelfServiceResourceAuthenticateRequest,
    ),
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceAuthenticateContactType$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceAuthenticateContactType,
    unknown
  > = openEnums.inboundSchema(
    ComCrmContactSelfServiceResourceAuthenticateContactType,
  );

/** @internal */
export const ComCrmContactSelfServiceResourceAuthenticateContact$inboundSchema:
  z.ZodMiniType<ComCrmContactSelfServiceResourceAuthenticateContact, unknown> =
    z.pipe(
      z.object({
        id: types.optional(types.string()),
        type: types.optional(
          ComCrmContactSelfServiceResourceAuthenticateContactType$inboundSchema,
        ),
        first_name: types.optional(types.string()),
        last_name: types.optional(types.string()),
        is_verified: types.optional(types.boolean()),
        company_name: types.optional(types.string()),
      }),
      z.transform((v) => {
        return remap$(v, {
          "first_name": "firstName",
          "last_name": "lastName",
          "is_verified": "isVerified",
          "company_name": "companyName",
        });
      }),
    );

export function comCrmContactSelfServiceResourceAuthenticateContactFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceAuthenticateContact,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceAuthenticateContact$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmContactSelfServiceResourceAuthenticateContact' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceAuthenticateOrganisationType$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceAuthenticateOrganisationType,
    unknown
  > = openEnums.inboundSchema(
    ComCrmContactSelfServiceResourceAuthenticateOrganisationType,
  );

/** @internal */
export const ComCrmContactSelfServiceResourceAuthenticateOrganisation$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceAuthenticateOrganisation,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    type: types.optional(
      ComCrmContactSelfServiceResourceAuthenticateOrganisationType$inboundSchema,
    ),
    name: types.optional(types.string()),
  });

export function comCrmContactSelfServiceResourceAuthenticateOrganisationFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceAuthenticateOrganisation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceAuthenticateOrganisation$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceAuthenticateOrganisation' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceAuthenticateCommunity$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceAuthenticateCommunity,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
  });

export function comCrmContactSelfServiceResourceAuthenticateCommunityFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceAuthenticateCommunity,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceAuthenticateCommunity$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmContactSelfServiceResourceAuthenticateCommunity' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceAuthenticateResponse$inboundSchema:
  z.ZodMiniType<ComCrmContactSelfServiceResourceAuthenticateResponse, unknown> =
    z.pipe(
      z.object({
        access_token: types.optional(types.string()),
        refresh_token: types.optional(types.string()),
        expiration_date: types.optional(types.number()),
        contact: types.optional(z.lazy(() =>
          ComCrmContactSelfServiceResourceAuthenticateContact$inboundSchema
        )),
        organisations: types.optional(z.array(z.lazy(() =>
          ComCrmContactSelfServiceResourceAuthenticateOrganisation$inboundSchema
        ))),
        communities: types.optional(z.array(z.lazy(() =>
          ComCrmContactSelfServiceResourceAuthenticateCommunity$inboundSchema
        ))),
        obfuscated_value: types.optional(types.string()),
        auth_otp: types.optional(types.string()),
        existing_contact: types.optional(types.boolean()),
      }),
      z.transform((v) => {
        return remap$(v, {
          "access_token": "accessToken",
          "refresh_token": "refreshToken",
          "expiration_date": "expirationDate",
          "obfuscated_value": "obfuscatedValue",
          "auth_otp": "authOtp",
          "existing_contact": "existingContact",
        });
      }),
    );

export function comCrmContactSelfServiceResourceAuthenticateResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceAuthenticateResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceAuthenticateResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmContactSelfServiceResourceAuthenticateResponse' from JSON`,
  );
}
