/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

export type ComCrmWalletSelfServiceResourceGetBalancesRequest = {
  /**
   * The unique identification of the wallet whose balance commerce pools will be retrieved.
   */
  id: string;
  /**
   * The id of a specific commerce pool (optional). If not provided then all commerce pools are retrieved
   */
  commercePoolId?: string | undefined;
  /**
   * If set to true, then the expiration information will also be retrieved
   */
  includeExpiration?: boolean | undefined;
  /**
   * If set to true, then only active commerce pools will be retrieved. By default will bring all commerce pools
   */
  isActive?: boolean | undefined;
};

export type ComCrmWalletSelfServiceResourceGetBalancesPaging = {
  /**
   * The page number
   */
  page?: number | undefined;
  /**
   * The number of records per page
   */
  size?: number | undefined;
  /**
   * The total number of records. If "include_total" is not specified, then this total is null. If "include_total" is specified, total has a value but it is accurate up to 10K records.
   */
  total?: number | undefined;
  /**
   * Shows if there are more records available to fetch
   */
  hasMore?: boolean | undefined;
};

/**
 * Defines the amounts expiring in periods. Available only if the parameter include_expiration is set to true
 */
export type Expiration = {
  /**
   * The amount that will expire in up to 30 days
   */
  zeroToThirty?: number | undefined;
  /**
   * The amount that will expire from 30 to 60 days
   */
  thirtyToSixty?: number | undefined;
  /**
   * The amount that will expire from 60 to 90 days
   */
  sixtyToNinety?: number | undefined;
  /**
   * The amount that will expire in more than 90 days
   */
  ninetyPlus?: number | undefined;
};

/**
 * The organisation type
 */
export const ComCrmWalletSelfServiceResourceGetBalancesType = {
  Operator: "OPERATOR",
  ServiceOwner: "SERVICE_OWNER",
  TransactionProcessor: "TRANSACTION_PROCESSOR",
  Business: "BUSINESS",
  Organisation: "ORGANISATION",
  Merchant: "MERCHANT",
  Venue: "VENUE",
} as const;
/**
 * The organisation type
 */
export type ComCrmWalletSelfServiceResourceGetBalancesType = OpenEnum<
  typeof ComCrmWalletSelfServiceResourceGetBalancesType
>;

/**
 * The country code of the location
 */
export const ComCrmWalletSelfServiceResourceGetBalancesCountryCode = {
  Abw: "ABW",
  Afg: "AFG",
  Ago: "AGO",
  Aia: "AIA",
  Ala: "ALA",
  Alb: "ALB",
  And: "AND",
  Ant: "ANT",
  Are: "ARE",
  Arg: "ARG",
  Arm: "ARM",
  Asm: "ASM",
  Ata: "ATA",
  Atf: "ATF",
  Atg: "ATG",
  Aus: "AUS",
  Aut: "AUT",
  Aze: "AZE",
  Bdi: "BDI",
  Bel: "BEL",
  Ben: "BEN",
  Bes: "BES",
  Bfa: "BFA",
  Bgd: "BGD",
  Bgr: "BGR",
  Bhr: "BHR",
  Bhs: "BHS",
  Bih: "BIH",
  Blm: "BLM",
  Blr: "BLR",
  Blz: "BLZ",
  Bmu: "BMU",
  Bol: "BOL",
  Bra: "BRA",
  Brb: "BRB",
  Brn: "BRN",
  Btn: "BTN",
  Bvt: "BVT",
  Bwa: "BWA",
  Caf: "CAF",
  Can: "CAN",
  Cck: "CCK",
  Che: "CHE",
  Chl: "CHL",
  Chn: "CHN",
  Civ: "CIV",
  Cmr: "CMR",
  Cod: "COD",
  Cog: "COG",
  Cok: "COK",
  Col: "COL",
  Com: "COM",
  Cpv: "CPV",
  Cri: "CRI",
  Cub: "CUB",
  Cuw: "CUW",
  Cxr: "CXR",
  Cym: "CYM",
  Cyp: "CYP",
  Cze: "CZE",
  Deu: "DEU",
  Dji: "DJI",
  Dma: "DMA",
  Dnk: "DNK",
  Dom: "DOM",
  Dza: "DZA",
  Ecu: "ECU",
  Egy: "EGY",
  Eri: "ERI",
  Esh: "ESH",
  Esp: "ESP",
  Est: "EST",
  Eth: "ETH",
  Fin: "FIN",
  Fji: "FJI",
  Flk: "FLK",
  Fra: "FRA",
  Fro: "FRO",
  Fsm: "FSM",
  Gab: "GAB",
  Gbr: "GBR",
  Geo: "GEO",
  Ggy: "GGY",
  Gha: "GHA",
  Gib: "GIB",
  Gin: "GIN",
  Glp: "GLP",
  Gmb: "GMB",
  Gnb: "GNB",
  Gnq: "GNQ",
  Grc: "GRC",
  Grd: "GRD",
  Grl: "GRL",
  Gtm: "GTM",
  Guf: "GUF",
  Gum: "GUM",
  Guy: "GUY",
  Hkg: "HKG",
  Hmd: "HMD",
  Hnd: "HND",
  Hrv: "HRV",
  Hti: "HTI",
  Hun: "HUN",
  Idn: "IDN",
  Imn: "IMN",
  Ind: "IND",
  Iot: "IOT",
  Irl: "IRL",
  Irn: "IRN",
  Irq: "IRQ",
  Isl: "ISL",
  Isr: "ISR",
  Ita: "ITA",
  Jam: "JAM",
  Jey: "JEY",
  Jor: "JOR",
  Jpn: "JPN",
  Kaz: "KAZ",
  Ken: "KEN",
  Kgz: "KGZ",
  Khm: "KHM",
  Kir: "KIR",
  Kna: "KNA",
  Kor: "KOR",
  Kwt: "KWT",
  Lao: "LAO",
  Lbn: "LBN",
  Lbr: "LBR",
  Lby: "LBY",
  Lca: "LCA",
  Lie: "LIE",
  Lka: "LKA",
  Lso: "LSO",
  Ltu: "LTU",
  Lux: "LUX",
  Lva: "LVA",
  Mac: "MAC",
  Maf: "MAF",
  Mar: "MAR",
  Mco: "MCO",
  Mda: "MDA",
  Mdg: "MDG",
  Mdv: "MDV",
  Mex: "MEX",
  Mhl: "MHL",
  Mkd: "MKD",
  Mli: "MLI",
  Mlt: "MLT",
  Mmr: "MMR",
  Mne: "MNE",
  Mng: "MNG",
  Mnp: "MNP",
  Moz: "MOZ",
  Mrt: "MRT",
  Msr: "MSR",
  Mtq: "MTQ",
  Mus: "MUS",
  Mwi: "MWI",
  Mys: "MYS",
  Myt: "MYT",
  Nam: "NAM",
  Ncl: "NCL",
  Ner: "NER",
  Nfk: "NFK",
  Nga: "NGA",
  Nic: "NIC",
  Niu: "NIU",
  Nld: "NLD",
  Nor: "NOR",
  Npl: "NPL",
  Nru: "NRU",
  Nzl: "NZL",
  Omn: "OMN",
  Pak: "PAK",
  Pan: "PAN",
  Pcn: "PCN",
  Per: "PER",
  Phl: "PHL",
  Plw: "PLW",
  Png: "PNG",
  Pol: "POL",
  Pri: "PRI",
  Prk: "PRK",
  Prt: "PRT",
  Pry: "PRY",
  Pse: "PSE",
  Pyf: "PYF",
  Qat: "QAT",
  Reu: "REU",
  Rks: "RKS",
  Rou: "ROU",
  Rus: "RUS",
  Rwa: "RWA",
  Sau: "SAU",
  Sdn: "SDN",
  Sen: "SEN",
  Sgp: "SGP",
  Sgs: "SGS",
  Shn: "SHN",
  Sjm: "SJM",
  Slb: "SLB",
  Sle: "SLE",
  Slv: "SLV",
  Smr: "SMR",
  Som: "SOM",
  Spm: "SPM",
  Srb: "SRB",
  Ssd: "SSD",
  Stp: "STP",
  Sur: "SUR",
  Svk: "SVK",
  Svn: "SVN",
  Swe: "SWE",
  Swz: "SWZ",
  Sxm: "SXM",
  Syc: "SYC",
  Syr: "SYR",
  Tca: "TCA",
  Tcd: "TCD",
  Tgo: "TGO",
  Tha: "THA",
  Tjk: "TJK",
  Tkl: "TKL",
  Tkm: "TKM",
  Tls: "TLS",
  Ton: "TON",
  Tto: "TTO",
  Tun: "TUN",
  Tur: "TUR",
  Tuv: "TUV",
  Twn: "TWN",
  Tza: "TZA",
  Uga: "UGA",
  Ukr: "UKR",
  Umi: "UMI",
  Ury: "URY",
  Usa: "USA",
  Uzb: "UZB",
  Vat: "VAT",
  Vct: "VCT",
  Ven: "VEN",
  Vgb: "VGB",
  Vir: "VIR",
  Vnm: "VNM",
  Vut: "VUT",
  Wlf: "WLF",
  Wsm: "WSM",
  Yem: "YEM",
  Zaf: "ZAF",
  Zmb: "ZMB",
  Zwe: "ZWE",
} as const;
/**
 * The country code of the location
 */
export type ComCrmWalletSelfServiceResourceGetBalancesCountryCode = OpenEnum<
  typeof ComCrmWalletSelfServiceResourceGetBalancesCountryCode
>;

/**
 * Information about the organisationâ€™s location
 */
export type ComCrmWalletSelfServiceResourceGetBalancesLocation = {
  /**
   * The name of the location
   */
  name?: string | undefined;
  /**
   * The address of the location
   */
  addressLine1?: string | undefined;
  /**
   * Additional address information about the location
   */
  addressLine2?: string | undefined;
  /**
   * The state/province/county of the location
   */
  stateProvinceCounty?: string | undefined;
  /**
   * The town/city of the location
   */
  townCity?: string | undefined;
  /**
   * The postal code of the location
   */
  postalCode?: string | undefined;
  /**
   * The country code of the location
   */
  countryCode?:
    | ComCrmWalletSelfServiceResourceGetBalancesCountryCode
    | undefined;
  /**
   * The latitude of the location
   */
  lat?: number | undefined;
  /**
   * The longitude of the location
   */
  lon?: number | undefined;
  /**
   * The Google textual identifier that uniquely identifies a location
   */
  googlePlaceId?: string | undefined;
};

export type ComCrmWalletSelfServiceResourceGetBalancesOrganisation = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The organisation name
   */
  name?: string | undefined;
  /**
   * The organisation type
   */
  type?: ComCrmWalletSelfServiceResourceGetBalancesType | undefined;
  /**
   * The locations of the organisation
   */
  locations?:
    | Array<ComCrmWalletSelfServiceResourceGetBalancesLocation>
    | undefined;
};

/**
 * The type of the ID to be provided
 */
export const IdType = {
  Product: "PRODUCT",
  Type: "TYPE",
  Family: "FAMILY",
  Brand: "BRAND",
} as const;
/**
 * The type of the ID to be provided
 */
export type IdType = OpenEnum<typeof IdType>;

export type ComCrmWalletSelfServiceResourceGetBalancesProduct = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The type of the ID to be provided
   */
  idType?: IdType | undefined;
  /**
   * The name of the product
   */
  name?: string | undefined;
  /**
   * The description of the product
   */
  description?: string | undefined;
  /**
   * The product sku
   */
  sku?: string | undefined;
};

export type Timing = {
  /**
   * The day of the week as condition (1-7), 1 is Sunday
   */
  day?: number | undefined;
  /**
   * The month as a condition (1-12), 1 is January
   */
  month?: number | undefined;
  /**
   * The start time of the day in 24 Hour format
   */
  startTime?: string | undefined;
  /**
   * The end time of the day in 24 Hour format
   */
  endTime?: string | undefined;
};

/**
 * The organisation from which the commerce pool was published
 */
export type PromotedOrganisation = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
};

/**
 * Details about commerce pool promote & join information
 */
export type B2bDetails = {
  /**
   * Defines whether the commerce pool is published to other organisations or not
   */
  isPublished?: boolean | undefined;
  /**
   * Defines whether the commerce pool is promoted from other organisations or not
   */
  isPromoted?: boolean | undefined;
  /**
   * The organisation from which the commerce pool was published
   */
  promotedOrganisation?: PromotedOrganisation | undefined;
};

export type ComCrmWalletSelfServiceResourceGetBalancesContent = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The name of the commerce pools group
   */
  name?: string | undefined;
  /**
   * The description of the commerce pools group
   */
  description?: string | undefined;
  /**
   * The amount that is allocated to the specified commerce pool
   */
  amount?: number | undefined;
  /**
   * Currency code based on ISO 4217 standard
   */
  currencyCode?: string | undefined;
  /**
   * Defines the amounts expiring in periods. Available only if the parameter include_expiration is set to true
   */
  expiration?: Expiration | undefined;
  /**
   * The organisations where the amount can be spent at
   */
  organisations?:
    | Array<ComCrmWalletSelfServiceResourceGetBalancesOrganisation>
    | undefined;
  /**
   * The products that the amount can be spent for
   */
  products?:
    | Array<ComCrmWalletSelfServiceResourceGetBalancesProduct>
    | undefined;
  /**
   * The time when the amount can be spent
   */
  timings?: Array<Timing> | undefined;
  /**
   * Indicates if the commerce pool can be activated by the contact
   */
  applicableForActivation?: boolean | undefined;
  /**
   * Indicates if the commerce pool has been activated
   */
  isActive?: boolean | undefined;
  /**
   * Details about commerce pool promote & join information
   */
  b2bDetails?: B2bDetails | undefined;
};

/**
 * OK
 */
export type ComCrmWalletSelfServiceResourceGetBalancesResponse = {
  paging?: ComCrmWalletSelfServiceResourceGetBalancesPaging | undefined;
  content?:
    | Array<ComCrmWalletSelfServiceResourceGetBalancesContent>
    | undefined;
};

/** @internal */
export type ComCrmWalletSelfServiceResourceGetBalancesRequest$Outbound = {
  id: string;
  commerce_pool_id?: string | undefined;
  include_expiration?: boolean | undefined;
  is_active?: boolean | undefined;
};

/** @internal */
export const ComCrmWalletSelfServiceResourceGetBalancesRequest$outboundSchema:
  z.ZodMiniType<
    ComCrmWalletSelfServiceResourceGetBalancesRequest$Outbound,
    ComCrmWalletSelfServiceResourceGetBalancesRequest
  > = z.pipe(
    z.object({
      id: z.string(),
      commercePoolId: z.optional(z.string()),
      includeExpiration: z.optional(z.boolean()),
      isActive: z.optional(z.boolean()),
    }),
    z.transform((v) => {
      return remap$(v, {
        commercePoolId: "commerce_pool_id",
        includeExpiration: "include_expiration",
        isActive: "is_active",
      });
    }),
  );

export function comCrmWalletSelfServiceResourceGetBalancesRequestToJSON(
  comCrmWalletSelfServiceResourceGetBalancesRequest:
    ComCrmWalletSelfServiceResourceGetBalancesRequest,
): string {
  return JSON.stringify(
    ComCrmWalletSelfServiceResourceGetBalancesRequest$outboundSchema.parse(
      comCrmWalletSelfServiceResourceGetBalancesRequest,
    ),
  );
}

/** @internal */
export const ComCrmWalletSelfServiceResourceGetBalancesPaging$inboundSchema:
  z.ZodMiniType<ComCrmWalletSelfServiceResourceGetBalancesPaging, unknown> = z
    .pipe(
      z.object({
        page: types.optional(types.number()),
        size: types.optional(types.number()),
        total: types.optional(types.number()),
        has_more: types.optional(types.boolean()),
      }),
      z.transform((v) => {
        return remap$(v, {
          "has_more": "hasMore",
        });
      }),
    );

export function comCrmWalletSelfServiceResourceGetBalancesPagingFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmWalletSelfServiceResourceGetBalancesPaging,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmWalletSelfServiceResourceGetBalancesPaging$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmWalletSelfServiceResourceGetBalancesPaging' from JSON`,
  );
}

/** @internal */
export const Expiration$inboundSchema: z.ZodMiniType<Expiration, unknown> = z
  .pipe(
    z.object({
      zero_to_thirty: types.optional(types.number()),
      thirty_to_sixty: types.optional(types.number()),
      sixty_to_ninety: types.optional(types.number()),
      ninety_plus: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "zero_to_thirty": "zeroToThirty",
        "thirty_to_sixty": "thirtyToSixty",
        "sixty_to_ninety": "sixtyToNinety",
        "ninety_plus": "ninetyPlus",
      });
    }),
  );

export function expirationFromJSON(
  jsonString: string,
): SafeParseResult<Expiration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Expiration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Expiration' from JSON`,
  );
}

/** @internal */
export const ComCrmWalletSelfServiceResourceGetBalancesType$inboundSchema:
  z.ZodMiniType<ComCrmWalletSelfServiceResourceGetBalancesType, unknown> =
    openEnums.inboundSchema(ComCrmWalletSelfServiceResourceGetBalancesType);

/** @internal */
export const ComCrmWalletSelfServiceResourceGetBalancesCountryCode$inboundSchema:
  z.ZodMiniType<
    ComCrmWalletSelfServiceResourceGetBalancesCountryCode,
    unknown
  > = openEnums.inboundSchema(
    ComCrmWalletSelfServiceResourceGetBalancesCountryCode,
  );

/** @internal */
export const ComCrmWalletSelfServiceResourceGetBalancesLocation$inboundSchema:
  z.ZodMiniType<ComCrmWalletSelfServiceResourceGetBalancesLocation, unknown> = z
    .pipe(
      z.object({
        name: types.optional(types.string()),
        address_line_1: types.optional(types.string()),
        address_line_2: types.optional(types.string()),
        state_province_county: types.optional(types.string()),
        town_city: types.optional(types.string()),
        postal_code: types.optional(types.string()),
        country_code: types.optional(
          ComCrmWalletSelfServiceResourceGetBalancesCountryCode$inboundSchema,
        ),
        lat: types.optional(types.number()),
        lon: types.optional(types.number()),
        google_place_id: types.optional(types.string()),
      }),
      z.transform((v) => {
        return remap$(v, {
          "address_line_1": "addressLine1",
          "address_line_2": "addressLine2",
          "state_province_county": "stateProvinceCounty",
          "town_city": "townCity",
          "postal_code": "postalCode",
          "country_code": "countryCode",
          "google_place_id": "googlePlaceId",
        });
      }),
    );

export function comCrmWalletSelfServiceResourceGetBalancesLocationFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmWalletSelfServiceResourceGetBalancesLocation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmWalletSelfServiceResourceGetBalancesLocation$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmWalletSelfServiceResourceGetBalancesLocation' from JSON`,
  );
}

/** @internal */
export const ComCrmWalletSelfServiceResourceGetBalancesOrganisation$inboundSchema:
  z.ZodMiniType<
    ComCrmWalletSelfServiceResourceGetBalancesOrganisation,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    type: types.optional(
      ComCrmWalletSelfServiceResourceGetBalancesType$inboundSchema,
    ),
    locations: types.optional(
      z.array(z.lazy(() =>
        ComCrmWalletSelfServiceResourceGetBalancesLocation$inboundSchema
      )),
    ),
  });

export function comCrmWalletSelfServiceResourceGetBalancesOrganisationFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmWalletSelfServiceResourceGetBalancesOrganisation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmWalletSelfServiceResourceGetBalancesOrganisation$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmWalletSelfServiceResourceGetBalancesOrganisation' from JSON`,
  );
}

/** @internal */
export const IdType$inboundSchema: z.ZodMiniType<IdType, unknown> = openEnums
  .inboundSchema(IdType);

/** @internal */
export const ComCrmWalletSelfServiceResourceGetBalancesProduct$inboundSchema:
  z.ZodMiniType<ComCrmWalletSelfServiceResourceGetBalancesProduct, unknown> = z
    .pipe(
      z.object({
        id: types.optional(types.string()),
        id_type: types.optional(IdType$inboundSchema),
        name: types.optional(types.string()),
        description: types.optional(types.string()),
        sku: types.optional(types.string()),
      }),
      z.transform((v) => {
        return remap$(v, {
          "id_type": "idType",
        });
      }),
    );

export function comCrmWalletSelfServiceResourceGetBalancesProductFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmWalletSelfServiceResourceGetBalancesProduct,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmWalletSelfServiceResourceGetBalancesProduct$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmWalletSelfServiceResourceGetBalancesProduct' from JSON`,
  );
}

/** @internal */
export const Timing$inboundSchema: z.ZodMiniType<Timing, unknown> = z.pipe(
  z.object({
    day: types.optional(types.number()),
    month: types.optional(types.number()),
    start_time: types.optional(types.string()),
    end_time: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "start_time": "startTime",
      "end_time": "endTime",
    });
  }),
);

export function timingFromJSON(
  jsonString: string,
): SafeParseResult<Timing, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Timing$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Timing' from JSON`,
  );
}

/** @internal */
export const PromotedOrganisation$inboundSchema: z.ZodMiniType<
  PromotedOrganisation,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
});

export function promotedOrganisationFromJSON(
  jsonString: string,
): SafeParseResult<PromotedOrganisation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PromotedOrganisation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PromotedOrganisation' from JSON`,
  );
}

/** @internal */
export const B2bDetails$inboundSchema: z.ZodMiniType<B2bDetails, unknown> = z
  .pipe(
    z.object({
      is_published: types.optional(types.boolean()),
      is_promoted: types.optional(types.boolean()),
      promoted_organisation: types.optional(
        z.lazy(() => PromotedOrganisation$inboundSchema),
      ),
    }),
    z.transform((v) => {
      return remap$(v, {
        "is_published": "isPublished",
        "is_promoted": "isPromoted",
        "promoted_organisation": "promotedOrganisation",
      });
    }),
  );

export function b2bDetailsFromJSON(
  jsonString: string,
): SafeParseResult<B2bDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => B2bDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'B2bDetails' from JSON`,
  );
}

/** @internal */
export const ComCrmWalletSelfServiceResourceGetBalancesContent$inboundSchema:
  z.ZodMiniType<ComCrmWalletSelfServiceResourceGetBalancesContent, unknown> = z
    .pipe(
      z.object({
        id: types.optional(types.string()),
        name: types.optional(types.string()),
        description: types.optional(types.string()),
        amount: types.optional(types.number()),
        currency_code: types.optional(types.string()),
        expiration: types.optional(z.lazy(() => Expiration$inboundSchema)),
        organisations: types.optional(z.array(z.lazy(() =>
          ComCrmWalletSelfServiceResourceGetBalancesOrganisation$inboundSchema
        ))),
        products: types.optional(z.array(z.lazy(() =>
          ComCrmWalletSelfServiceResourceGetBalancesProduct$inboundSchema
        ))),
        timings: types.optional(z.array(z.lazy(() =>
          Timing$inboundSchema
        ))),
        applicable_for_activation: types.optional(types.boolean()),
        is_active: types.optional(types.boolean()),
        b2b_details: types.optional(z.lazy(() =>
          B2bDetails$inboundSchema
        )),
      }),
      z.transform((v) => {
        return remap$(v, {
          "currency_code": "currencyCode",
          "applicable_for_activation": "applicableForActivation",
          "is_active": "isActive",
          "b2b_details": "b2bDetails",
        });
      }),
    );

export function comCrmWalletSelfServiceResourceGetBalancesContentFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmWalletSelfServiceResourceGetBalancesContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmWalletSelfServiceResourceGetBalancesContent$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmWalletSelfServiceResourceGetBalancesContent' from JSON`,
  );
}

/** @internal */
export const ComCrmWalletSelfServiceResourceGetBalancesResponse$inboundSchema:
  z.ZodMiniType<ComCrmWalletSelfServiceResourceGetBalancesResponse, unknown> = z
    .object({
      paging: types.optional(
        z.lazy(() =>
          ComCrmWalletSelfServiceResourceGetBalancesPaging$inboundSchema
        ),
      ),
      content: types.optional(
        z.array(z.lazy(() =>
          ComCrmWalletSelfServiceResourceGetBalancesContent$inboundSchema
        )),
      ),
    });

export function comCrmWalletSelfServiceResourceGetBalancesResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmWalletSelfServiceResourceGetBalancesResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmWalletSelfServiceResourceGetBalancesResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmWalletSelfServiceResourceGetBalancesResponse' from JSON`,
  );
}
