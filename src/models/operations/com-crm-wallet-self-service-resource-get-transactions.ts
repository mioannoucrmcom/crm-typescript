/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 * @generated-id: 57eb88b045de
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

/**
 * Filter transactions by pocket: CRM.COM = CRM.COM pocket, BUSINESS = business open pocket, BUSINESS_COMMERCE = business commerce pocket. If not specified then transactions for all business pockets are retrieved.
 */
export const QueryParamPocket = {
  Crmcom: "CRMCOM",
  Business: "BUSINESS",
  BusinessCommerce: "BUSINESS_COMMERCE",
} as const;
/**
 * Filter transactions by pocket: CRM.COM = CRM.COM pocket, BUSINESS = business open pocket, BUSINESS_COMMERCE = business commerce pocket. If not specified then transactions for all business pockets are retrieved.
 */
export type QueryParamPocket = ClosedEnum<typeof QueryParamPocket>;

/**
 * Filters wallet transactions based on the transaction type
 */
export const ComCrmWalletSelfServiceResourceGetTransactionsQueryParamType = {
  Credit: "CREDIT",
  Debit: "DEBIT",
} as const;
/**
 * Filters wallet transactions based on the transaction type
 */
export type ComCrmWalletSelfServiceResourceGetTransactionsQueryParamType =
  ClosedEnum<
    typeof ComCrmWalletSelfServiceResourceGetTransactionsQueryParamType
  >;

/**
 * Defines how the results will be ordered
 */
export const ComCrmWalletSelfServiceResourceGetTransactionsOrderEnum = {
  Asc: "ASC",
  Desc: "DESC",
} as const;
/**
 * Defines how the results will be ordered
 */
export type ComCrmWalletSelfServiceResourceGetTransactionsOrderEnum =
  ClosedEnum<typeof ComCrmWalletSelfServiceResourceGetTransactionsOrderEnum>;

export type ComCrmWalletSelfServiceResourceGetTransactionsRequest = {
  /**
   * The wallet (identifier) whose wallet transactions will be retrieved
   */
  id: string;
  /**
   * Filters wallet transactions based on the community member identifier
   */
  communityMemberId?: string | undefined;
  /**
   * If set to true, then retrieve wallet journal entries related to wallet fees
   */
  isWalletFee?: boolean | undefined;
  /**
   * Filter transactions by pocket: CRM.COM = CRM.COM pocket, BUSINESS = business open pocket, BUSINESS_COMMERCE = business commerce pocket. If not specified then transactions for all business pockets are retrieved.
   */
  pocket?: QueryParamPocket | undefined;
  /**
   * Filter based on the posted date, which may fall within a given date range. The value can be a string with a date in epoch format. Each option must also include an operator. Use up to two options based on the required search
   */
  postedOn?: number | undefined;
  /**
   * Returns results where the posted date is greater than this value
   */
  postedOnGt?: number | undefined;
  /**
   * Returns results where the posted date is greater than or equal to this value
   */
  postedOnGte?: number | undefined;
  /**
   * Returns results where the posted date is less than this value
   */
  postedOnLt?: number | undefined;
  /**
   * Returns results where the posted date is less than or equal to this value
   */
  postedOnLte?: number | undefined;
  /**
   * Filters wallet transactions based on the transaction type
   */
  type?:
    | ComCrmWalletSelfServiceResourceGetTransactionsQueryParamType
    | undefined;
  /**
   * Determine if a "total" will be returned in paging reference. If set to True, then "total" is also returned but it will return up to 10K value. If set to False, then the "total" in paging is null.
   */
  includeTotal?: boolean | undefined;
  /**
   * Defines how the results will be ordered
   */
  order?: ComCrmWalletSelfServiceResourceGetTransactionsOrderEnum | undefined;
  /**
   * The page number that should be retrieved
   */
  page?: number | undefined;
  /**
   * The size (total records) of each page
   */
  size?: number | undefined;
  /**
   * Defines on which attribute the results should be sorted
   */
  sort?: string | undefined;
};

export type ComCrmWalletSelfServiceResourceGetTransactionsPaging = {
  /**
   * The page number
   */
  page?: number | undefined;
  /**
   * The number of records per page
   */
  size?: number | undefined;
  /**
   * The total number of records. If "include_total" is not specified, then this total is null. If "include_total" is specified, total has a value but it is accurate up to 10K records.
   */
  total?: number | undefined;
  /**
   * Shows if there are more records available to fetch
   */
  hasMore?: boolean | undefined;
};

/**
 * The wallet journal type
 */
export const ComCrmWalletSelfServiceResourceGetTransactionsContentType = {
  Credit: "CREDIT",
  Debit: "DEBIT",
} as const;
/**
 * The wallet journal type
 */
export type ComCrmWalletSelfServiceResourceGetTransactionsContentType =
  OpenEnum<typeof ComCrmWalletSelfServiceResourceGetTransactionsContentType>;

/**
 * Define how awards can be/were spent (for SPEND transactions only)
 *
 * @remarks
 *  * `INSTANT` - Instant Discount
 *  * `AUTOMATIC_SPEND` - Automatic Spend Requests
 *  * `ON_REQUEST` - Spend on Customer Request
 */
export const SpendMethod = {
  OnRequest: "ON_REQUEST",
  Instant: "INSTANT",
  Deferred: "DEFERRED",
  AutoSpend: "AUTO_SPEND",
  Voucher: "VOUCHER",
} as const;
/**
 * Define how awards can be/were spent (for SPEND transactions only)
 *
 * @remarks
 *  * `INSTANT` - Instant Discount
 *  * `AUTOMATIC_SPEND` - Automatic Spend Requests
 *  * `ON_REQUEST` - Spend on Customer Request
 */
export type SpendMethod = OpenEnum<typeof SpendMethod>;

/**
 * Details of reward offer that triggered the award/spend (spend is related to an offer when it’s an instant discount)
 */
export type ComCrmWalletSelfServiceResourceGetTransactionsRewardOffer = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
};

/**
 * Details of the location where the purchase took place resulting in an AWARD or SPEND event
 */
export type PerformedBy = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
};

/**
 * Details about the reward event related to the wallet journal transaction
 */
export type RewardEvent = {
  /**
   * The type of the event
   */
  type?: string | undefined;
  /**
   * The event (unique) code
   */
  code?: string | undefined;
  /**
   * The amount that was awarded or spent
   */
  amount?: number | undefined;
  /**
   * Define how awards can be/were spent (for SPEND transactions only)
   *
   * @remarks
   *  * `INSTANT` - Instant Discount
   *  * `AUTOMATIC_SPEND` - Automatic Spend Requests
   *  * `ON_REQUEST` - Spend on Customer Request
   */
  spendMethod?: SpendMethod | undefined;
  /**
   * The event state
   *
   * @remarks
   *  * `POSTED`
   *  * `CANCELLED`
   *  * `EXPIRED` - Applicable only for Award Transactions
   */
  state?: string | undefined;
  /**
   * The date on which such event was posted
   */
  date?: number | undefined;
  /**
   * Expiry date of awarded amount
   */
  expiryDate?: number | undefined;
  /**
   * Details of reward offer that triggered the award/spend (spend is related to an offer when it’s an instant discount)
   */
  rewardOffer?:
    | ComCrmWalletSelfServiceResourceGetTransactionsRewardOffer
    | undefined;
  /**
   * Details of the location where the purchase took place resulting in an AWARD or SPEND event
   */
  performedBy?: PerformedBy | undefined;
  referenceNumber?: string | undefined;
  purchaseId?: string | undefined;
};

/**
 * Details about the financial event related to the wallet journal transaction
 */
export type FinancialEvent = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The event type
   */
  type?: string | undefined;
  /**
   * The event number (e.g. entity number, like invoice number, credit note number, refund number)
   */
  number?: string | undefined;
  /**
   * The event reference number, which can be: a) Reference Number, if the transaction is of type payment, invoice, credit note, payment cancellation, refund. OR b) Code, if the transaction is a top-up or a transfer
   */
  referenceNumber?: string | undefined;
  /**
   * The event life cycle state
   */
  lifeCycleState?: string | undefined;
  /**
   * A note regarding the financial transaction.
   */
  notes?: string | undefined;
  /**
   * The event amount
   */
  amount?: number | undefined;
  /**
   * The date on which such event was posted
   */
  date?: number | undefined;
};

/**
 * Details about the wallet fee related to the wallet journal transaction
 */
export type WalletFee = {
  /**
   * Defines the reason for which the fee was applied on wallet
   *
   * @remarks
   *  * `CREDIT` - On Credit Wallet Transactions
   *  * `DEBIT` - On Debit Wallet Transactions
   */
  type?: string | undefined;
  /**
   * The fee rule name
   */
  name?: string | undefined;
};

/**
 * The organisation that fulfilled the order
 */
export type ComCrmWalletSelfServiceResourceGetTransactionsFulfilledBy = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  name?: any | undefined;
};

/**
 * Details about the order related to the wallet journal transaction
 */
export type ComCrmWalletSelfServiceResourceGetTransactionsContentOrder = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The order number
   */
  number?: string | undefined;
  /**
   * The order total cost
   */
  totalCost?: number | undefined;
  /**
   * The date on which the order was submitted
   */
  submittedOn?: number | undefined;
  /**
   * The organisation that fulfilled the order
   */
  fulfilledBy?:
    | ComCrmWalletSelfServiceResourceGetTransactionsFulfilledBy
    | undefined;
};

/**
 * Specifies which pocket the transaction was logged against. CRMCOM = CRM.COM pocket, BUSINESS = business open pocket, BUSINESS_COMMERCE = business commerce pocket
 */
export const PocketResponse = {
  Crmcom: "CRMCOM",
  Business: "BUSINESS",
  BusinessCommerce: "BUSINESS_COMMERCE",
} as const;
/**
 * Specifies which pocket the transaction was logged against. CRMCOM = CRM.COM pocket, BUSINESS = business open pocket, BUSINESS_COMMERCE = business commerce pocket
 */
export type PocketResponse = OpenEnum<typeof PocketResponse>;

/**
 * Details of Commerce Pool
 */
export type WalletExpirationCommercePool = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
  /**
   * The entity description
   */
  description?: string | undefined;
};

/**
 * Details of expired Business Commerce funds
 */
export type WalletExpiration = {
  /**
   * Expiry date of Commerce funds
   */
  date?: number | undefined;
  /**
   * Details of Commerce Pool
   */
  commercePool?: WalletExpirationCommercePool | undefined;
};

/**
 * Details of the contact involved in the transfer transaction. If it's a 'debit' transfer, these details pertain to the receiver contact, if it's a 'credit' transfer, these details relate to the sender contact
 */
export type ComCrmWalletSelfServiceResourceGetTransactionsContact = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
  /**
   * The entity code
   */
  code?: string | undefined;
};

/**
 * If the transfer includes spending conditions, then the commerce pool details are provided too. Applicable only for transfers to the Business Commerce Pocket.
 */
export type ComCrmWalletSelfServiceResourceGetTransactionsTransferCommercePool =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The entity name
     */
    name?: string | undefined;
  };

/**
 * Details of the contact's wallet involved in the transfer transaction. If it's a 'debit' transfer, these details correspond to the receiving wallet, if it's a 'credit' transfer, these details relate to the sending wallet
 */
export type ComCrmWalletSelfServiceResourceGetTransactionsWallet = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity code
   */
  code?: string | undefined;
};

/**
 * Details of the contact's account involved in the transfer transaction. If it's a 'debit' transfer, these details correspond to the receiving account, if it's a 'credit' transfer, these details relate to the sending account
 */
export type ComCrmWalletSelfServiceResourceGetTransactionsAccount = {
  /**
   * the entity identifier
   */
  id?: string | undefined;
  /**
   * the entity number
   */
  number?: string | undefined;
};

/**
 * Transfer transaction details
 */
export type ComCrmWalletSelfServiceResourceGetTransactionsTransfer = {
  /**
   * Details of the contact involved in the transfer transaction. If it's a 'debit' transfer, these details pertain to the receiver contact, if it's a 'credit' transfer, these details relate to the sender contact
   */
  contact?: ComCrmWalletSelfServiceResourceGetTransactionsContact | undefined;
  /**
   * If the transfer includes spending conditions, then the commerce pool details are provided too. Applicable only for transfers to the Business Commerce Pocket.
   */
  commercePool?:
    | ComCrmWalletSelfServiceResourceGetTransactionsTransferCommercePool
    | undefined;
  /**
   * Details of the contact's wallet involved in the transfer transaction. If it's a 'debit' transfer, these details correspond to the receiving wallet, if it's a 'credit' transfer, these details relate to the sending wallet
   */
  wallet?: ComCrmWalletSelfServiceResourceGetTransactionsWallet | undefined;
  /**
   * Details of the contact's account involved in the transfer transaction. If it's a 'debit' transfer, these details correspond to the receiving account, if it's a 'credit' transfer, these details relate to the sending account
   */
  account?: ComCrmWalletSelfServiceResourceGetTransactionsAccount | undefined;
};

/**
 * The type of the entity that blocked the item
 */
export const ComCrmWalletSelfServiceResourceGetTransactionsEntity = {
  Purchase: "PURCHASE",
  Order: "ORDER",
} as const;
/**
 * The type of the entity that blocked the item
 */
export type ComCrmWalletSelfServiceResourceGetTransactionsEntity = OpenEnum<
  typeof ComCrmWalletSelfServiceResourceGetTransactionsEntity
>;

/**
 * The block details if the transaction is blocked
 */
export type BlockedBy = {
  /**
   * The identifier of the entity that blocked the item
   */
  id?: string | undefined;
  /**
   * The type of the entity that blocked the item
   */
  entity?: ComCrmWalletSelfServiceResourceGetTransactionsEntity | undefined;
  /**
   * The expiration date of the block
   */
  expirationDate?: number | undefined;
};

export type ComCrmWalletSelfServiceResourceGetTransactionsContent = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The wallet journal amount
   */
  amount?: number | undefined;
  /**
   * The wallet’s journal currency
   */
  currency?: string | undefined;
  /**
   * The wallet journal type
   */
  type?: ComCrmWalletSelfServiceResourceGetTransactionsContentType | undefined;
  /**
   * The date that the wallet journal was posted
   */
  postedOn?: number | undefined;
  /**
   * Details about the reward event related to the wallet journal transaction
   */
  rewardEvent?: RewardEvent | undefined;
  /**
   * Details about the financial event related to the wallet journal transaction
   */
  financialEvent?: FinancialEvent | undefined;
  /**
   * Details about the wallet fee related to the wallet journal transaction
   */
  walletFee?: WalletFee | undefined;
  /**
   * Details about the order related to the wallet journal transaction
   */
  order?:
    | ComCrmWalletSelfServiceResourceGetTransactionsContentOrder
    | undefined;
  /**
   * Specifies which pocket the transaction was logged against. CRMCOM = CRM.COM pocket, BUSINESS = business open pocket, BUSINESS_COMMERCE = business commerce pocket
   */
  pocket?: PocketResponse | undefined;
  /**
   * The exchange rate
   */
  exchangeRate?: number | undefined;
  /**
   * The total in default currency
   */
  totalDefaultCurrency?: number | undefined;
  /**
   * The default currency code based on ISO 4217 standard
   */
  defaultCurrencyCode?: string | undefined;
  /**
   * Details of expired Business Commerce funds
   */
  walletExpiration?: WalletExpiration | undefined;
  /**
   * Transfer transaction details
   */
  transfer?: ComCrmWalletSelfServiceResourceGetTransactionsTransfer | undefined;
  /**
   * The block details if the transaction is blocked
   */
  blockedBy?: BlockedBy | undefined;
};

/**
 * OK
 */
export type ComCrmWalletSelfServiceResourceGetTransactionsResponse = {
  paging?: ComCrmWalletSelfServiceResourceGetTransactionsPaging | undefined;
  content?:
    | Array<ComCrmWalletSelfServiceResourceGetTransactionsContent>
    | undefined;
};

/** @internal */
export const QueryParamPocket$outboundSchema: z.ZodMiniEnum<
  typeof QueryParamPocket
> = z.enum(QueryParamPocket);

/** @internal */
export const ComCrmWalletSelfServiceResourceGetTransactionsQueryParamType$outboundSchema:
  z.ZodMiniEnum<
    typeof ComCrmWalletSelfServiceResourceGetTransactionsQueryParamType
  > = z.enum(ComCrmWalletSelfServiceResourceGetTransactionsQueryParamType);

/** @internal */
export const ComCrmWalletSelfServiceResourceGetTransactionsOrderEnum$outboundSchema:
  z.ZodMiniEnum<
    typeof ComCrmWalletSelfServiceResourceGetTransactionsOrderEnum
  > = z.enum(ComCrmWalletSelfServiceResourceGetTransactionsOrderEnum);

/** @internal */
export type ComCrmWalletSelfServiceResourceGetTransactionsRequest$Outbound = {
  id: string;
  community_member_id?: string | undefined;
  is_wallet_fee?: boolean | undefined;
  pocket?: string | undefined;
  posted_on?: number | undefined;
  "posted_on[gt]"?: number | undefined;
  "posted_on[gte]"?: number | undefined;
  "posted_on[lt]"?: number | undefined;
  "posted_on[lte]"?: number | undefined;
  type?: string | undefined;
  include_total: boolean;
  order: string;
  page: number;
  size: number;
  sort: string;
};

/** @internal */
export const ComCrmWalletSelfServiceResourceGetTransactionsRequest$outboundSchema:
  z.ZodMiniType<
    ComCrmWalletSelfServiceResourceGetTransactionsRequest$Outbound,
    ComCrmWalletSelfServiceResourceGetTransactionsRequest
  > = z.pipe(
    z.object({
      id: z.string(),
      communityMemberId: z.optional(z.string()),
      isWalletFee: z.optional(z.boolean()),
      pocket: z.optional(QueryParamPocket$outboundSchema),
      postedOn: z.optional(z.int()),
      postedOnGt: z.optional(z.int()),
      postedOnGte: z.optional(z.int()),
      postedOnLt: z.optional(z.int()),
      postedOnLte: z.optional(z.int()),
      type: z.optional(
        ComCrmWalletSelfServiceResourceGetTransactionsQueryParamType$outboundSchema,
      ),
      includeTotal: z._default(z.boolean(), false),
      order: z._default(
        ComCrmWalletSelfServiceResourceGetTransactionsOrderEnum$outboundSchema,
        "DESC",
      ),
      page: z._default(z.int(), 1),
      size: z._default(z.int(), 10),
      sort: z._default(z.string(), "CREATED_DATE"),
    }),
    z.transform((v) => {
      return remap$(v, {
        communityMemberId: "community_member_id",
        isWalletFee: "is_wallet_fee",
        postedOn: "posted_on",
        postedOnGt: "posted_on[gt]",
        postedOnGte: "posted_on[gte]",
        postedOnLt: "posted_on[lt]",
        postedOnLte: "posted_on[lte]",
        includeTotal: "include_total",
      });
    }),
  );

export function comCrmWalletSelfServiceResourceGetTransactionsRequestToJSON(
  comCrmWalletSelfServiceResourceGetTransactionsRequest:
    ComCrmWalletSelfServiceResourceGetTransactionsRequest,
): string {
  return JSON.stringify(
    ComCrmWalletSelfServiceResourceGetTransactionsRequest$outboundSchema.parse(
      comCrmWalletSelfServiceResourceGetTransactionsRequest,
    ),
  );
}

/** @internal */
export const ComCrmWalletSelfServiceResourceGetTransactionsPaging$inboundSchema:
  z.ZodMiniType<ComCrmWalletSelfServiceResourceGetTransactionsPaging, unknown> =
    z.pipe(
      z.object({
        page: types.optional(types.number()),
        size: types.optional(types.number()),
        total: types.optional(types.number()),
        has_more: types.optional(types.boolean()),
      }),
      z.transform((v) => {
        return remap$(v, {
          "has_more": "hasMore",
        });
      }),
    );

export function comCrmWalletSelfServiceResourceGetTransactionsPagingFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmWalletSelfServiceResourceGetTransactionsPaging,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmWalletSelfServiceResourceGetTransactionsPaging$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmWalletSelfServiceResourceGetTransactionsPaging' from JSON`,
  );
}

/** @internal */
export const ComCrmWalletSelfServiceResourceGetTransactionsContentType$inboundSchema:
  z.ZodMiniType<
    ComCrmWalletSelfServiceResourceGetTransactionsContentType,
    unknown
  > = openEnums.inboundSchema(
    ComCrmWalletSelfServiceResourceGetTransactionsContentType,
  );

/** @internal */
export const SpendMethod$inboundSchema: z.ZodMiniType<SpendMethod, unknown> =
  openEnums.inboundSchema(SpendMethod);

/** @internal */
export const ComCrmWalletSelfServiceResourceGetTransactionsRewardOffer$inboundSchema:
  z.ZodMiniType<
    ComCrmWalletSelfServiceResourceGetTransactionsRewardOffer,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
  });

export function comCrmWalletSelfServiceResourceGetTransactionsRewardOfferFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmWalletSelfServiceResourceGetTransactionsRewardOffer,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmWalletSelfServiceResourceGetTransactionsRewardOffer$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmWalletSelfServiceResourceGetTransactionsRewardOffer' from JSON`,
  );
}

/** @internal */
export const PerformedBy$inboundSchema: z.ZodMiniType<PerformedBy, unknown> = z
  .object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
  });

export function performedByFromJSON(
  jsonString: string,
): SafeParseResult<PerformedBy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PerformedBy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PerformedBy' from JSON`,
  );
}

/** @internal */
export const RewardEvent$inboundSchema: z.ZodMiniType<RewardEvent, unknown> = z
  .pipe(
    z.object({
      type: types.optional(types.string()),
      code: types.optional(types.string()),
      amount: types.optional(types.number()),
      spend_method: types.optional(SpendMethod$inboundSchema),
      state: types.optional(types.string()),
      date: types.optional(types.number()),
      expiry_date: types.optional(types.number()),
      reward_offer: types.optional(z.lazy(() =>
        ComCrmWalletSelfServiceResourceGetTransactionsRewardOffer$inboundSchema
      )),
      performed_by: types.optional(z.lazy(() =>
        PerformedBy$inboundSchema
      )),
      reference_number: types.optional(types.string()),
      purchase_id: types.optional(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "spend_method": "spendMethod",
        "expiry_date": "expiryDate",
        "reward_offer": "rewardOffer",
        "performed_by": "performedBy",
        "reference_number": "referenceNumber",
        "purchase_id": "purchaseId",
      });
    }),
  );

export function rewardEventFromJSON(
  jsonString: string,
): SafeParseResult<RewardEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RewardEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RewardEvent' from JSON`,
  );
}

/** @internal */
export const FinancialEvent$inboundSchema: z.ZodMiniType<
  FinancialEvent,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    type: types.optional(types.string()),
    number: types.optional(types.string()),
    reference_number: types.optional(types.string()),
    life_cycle_state: types.optional(types.string()),
    notes: types.optional(types.string()),
    amount: types.optional(types.number()),
    date: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "reference_number": "referenceNumber",
      "life_cycle_state": "lifeCycleState",
    });
  }),
);

export function financialEventFromJSON(
  jsonString: string,
): SafeParseResult<FinancialEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FinancialEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FinancialEvent' from JSON`,
  );
}

/** @internal */
export const WalletFee$inboundSchema: z.ZodMiniType<WalletFee, unknown> = z
  .object({
    type: types.optional(types.string()),
    name: types.optional(types.string()),
  });

export function walletFeeFromJSON(
  jsonString: string,
): SafeParseResult<WalletFee, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WalletFee$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WalletFee' from JSON`,
  );
}

/** @internal */
export const ComCrmWalletSelfServiceResourceGetTransactionsFulfilledBy$inboundSchema:
  z.ZodMiniType<
    ComCrmWalletSelfServiceResourceGetTransactionsFulfilledBy,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(z.any()),
  });

export function comCrmWalletSelfServiceResourceGetTransactionsFulfilledByFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmWalletSelfServiceResourceGetTransactionsFulfilledBy,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmWalletSelfServiceResourceGetTransactionsFulfilledBy$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmWalletSelfServiceResourceGetTransactionsFulfilledBy' from JSON`,
  );
}

/** @internal */
export const ComCrmWalletSelfServiceResourceGetTransactionsContentOrder$inboundSchema:
  z.ZodMiniType<
    ComCrmWalletSelfServiceResourceGetTransactionsContentOrder,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      number: types.optional(types.string()),
      total_cost: types.optional(types.number()),
      submitted_on: types.optional(types.number()),
      fulfilled_by: types.optional(z.lazy(() =>
        ComCrmWalletSelfServiceResourceGetTransactionsFulfilledBy$inboundSchema
      )),
    }),
    z.transform((v) => {
      return remap$(v, {
        "total_cost": "totalCost",
        "submitted_on": "submittedOn",
        "fulfilled_by": "fulfilledBy",
      });
    }),
  );

export function comCrmWalletSelfServiceResourceGetTransactionsContentOrderFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmWalletSelfServiceResourceGetTransactionsContentOrder,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmWalletSelfServiceResourceGetTransactionsContentOrder$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmWalletSelfServiceResourceGetTransactionsContentOrder' from JSON`,
  );
}

/** @internal */
export const PocketResponse$inboundSchema: z.ZodMiniType<
  PocketResponse,
  unknown
> = openEnums.inboundSchema(PocketResponse);

/** @internal */
export const WalletExpirationCommercePool$inboundSchema: z.ZodMiniType<
  WalletExpirationCommercePool,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
  description: types.optional(types.string()),
});

export function walletExpirationCommercePoolFromJSON(
  jsonString: string,
): SafeParseResult<WalletExpirationCommercePool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WalletExpirationCommercePool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WalletExpirationCommercePool' from JSON`,
  );
}

/** @internal */
export const WalletExpiration$inboundSchema: z.ZodMiniType<
  WalletExpiration,
  unknown
> = z.pipe(
  z.object({
    date: types.optional(types.number()),
    commerce_pool: types.optional(
      z.lazy(() => WalletExpirationCommercePool$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "commerce_pool": "commercePool",
    });
  }),
);

export function walletExpirationFromJSON(
  jsonString: string,
): SafeParseResult<WalletExpiration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WalletExpiration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WalletExpiration' from JSON`,
  );
}

/** @internal */
export const ComCrmWalletSelfServiceResourceGetTransactionsContact$inboundSchema:
  z.ZodMiniType<
    ComCrmWalletSelfServiceResourceGetTransactionsContact,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    code: types.optional(types.string()),
  });

export function comCrmWalletSelfServiceResourceGetTransactionsContactFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmWalletSelfServiceResourceGetTransactionsContact,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmWalletSelfServiceResourceGetTransactionsContact$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmWalletSelfServiceResourceGetTransactionsContact' from JSON`,
  );
}

/** @internal */
export const ComCrmWalletSelfServiceResourceGetTransactionsTransferCommercePool$inboundSchema:
  z.ZodMiniType<
    ComCrmWalletSelfServiceResourceGetTransactionsTransferCommercePool,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
  });

export function comCrmWalletSelfServiceResourceGetTransactionsTransferCommercePoolFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmWalletSelfServiceResourceGetTransactionsTransferCommercePool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmWalletSelfServiceResourceGetTransactionsTransferCommercePool$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmWalletSelfServiceResourceGetTransactionsTransferCommercePool' from JSON`,
  );
}

/** @internal */
export const ComCrmWalletSelfServiceResourceGetTransactionsWallet$inboundSchema:
  z.ZodMiniType<ComCrmWalletSelfServiceResourceGetTransactionsWallet, unknown> =
    z.object({
      id: types.optional(types.string()),
      code: types.optional(types.string()),
    });

export function comCrmWalletSelfServiceResourceGetTransactionsWalletFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmWalletSelfServiceResourceGetTransactionsWallet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmWalletSelfServiceResourceGetTransactionsWallet$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmWalletSelfServiceResourceGetTransactionsWallet' from JSON`,
  );
}

/** @internal */
export const ComCrmWalletSelfServiceResourceGetTransactionsAccount$inboundSchema:
  z.ZodMiniType<
    ComCrmWalletSelfServiceResourceGetTransactionsAccount,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    number: types.optional(types.string()),
  });

export function comCrmWalletSelfServiceResourceGetTransactionsAccountFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmWalletSelfServiceResourceGetTransactionsAccount,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmWalletSelfServiceResourceGetTransactionsAccount$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmWalletSelfServiceResourceGetTransactionsAccount' from JSON`,
  );
}

/** @internal */
export const ComCrmWalletSelfServiceResourceGetTransactionsTransfer$inboundSchema:
  z.ZodMiniType<
    ComCrmWalletSelfServiceResourceGetTransactionsTransfer,
    unknown
  > = z.pipe(
    z.object({
      contact: types.optional(z.lazy(() =>
        ComCrmWalletSelfServiceResourceGetTransactionsContact$inboundSchema
      )),
      commerce_pool: types.optional(z.lazy(() =>
        ComCrmWalletSelfServiceResourceGetTransactionsTransferCommercePool$inboundSchema
      )),
      wallet: types.optional(z.lazy(() =>
        ComCrmWalletSelfServiceResourceGetTransactionsWallet$inboundSchema
      )),
      account: types.optional(z.lazy(() =>
        ComCrmWalletSelfServiceResourceGetTransactionsAccount$inboundSchema
      )),
    }),
    z.transform((v) => {
      return remap$(v, {
        "commerce_pool": "commercePool",
      });
    }),
  );

export function comCrmWalletSelfServiceResourceGetTransactionsTransferFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmWalletSelfServiceResourceGetTransactionsTransfer,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmWalletSelfServiceResourceGetTransactionsTransfer$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmWalletSelfServiceResourceGetTransactionsTransfer' from JSON`,
  );
}

/** @internal */
export const ComCrmWalletSelfServiceResourceGetTransactionsEntity$inboundSchema:
  z.ZodMiniType<ComCrmWalletSelfServiceResourceGetTransactionsEntity, unknown> =
    openEnums.inboundSchema(
      ComCrmWalletSelfServiceResourceGetTransactionsEntity,
    );

/** @internal */
export const BlockedBy$inboundSchema: z.ZodMiniType<BlockedBy, unknown> = z
  .pipe(
    z.object({
      id: types.optional(types.string()),
      entity: types.optional(
        ComCrmWalletSelfServiceResourceGetTransactionsEntity$inboundSchema,
      ),
      expiration_date: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "expiration_date": "expirationDate",
      });
    }),
  );

export function blockedByFromJSON(
  jsonString: string,
): SafeParseResult<BlockedBy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BlockedBy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BlockedBy' from JSON`,
  );
}

/** @internal */
export const ComCrmWalletSelfServiceResourceGetTransactionsContent$inboundSchema:
  z.ZodMiniType<
    ComCrmWalletSelfServiceResourceGetTransactionsContent,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      amount: types.optional(types.number()),
      currency: types.optional(types.string()),
      type: types.optional(
        ComCrmWalletSelfServiceResourceGetTransactionsContentType$inboundSchema,
      ),
      posted_on: types.optional(types.number()),
      reward_event: types.optional(z.lazy(() => RewardEvent$inboundSchema)),
      financial_event: types.optional(
        z.lazy(() => FinancialEvent$inboundSchema),
      ),
      wallet_fee: types.optional(z.lazy(() => WalletFee$inboundSchema)),
      order: types.optional(
        z.lazy(() =>
          ComCrmWalletSelfServiceResourceGetTransactionsContentOrder$inboundSchema
        ),
      ),
      pocket: types.optional(PocketResponse$inboundSchema),
      exchange_rate: types.optional(types.number()),
      total_default_currency: types.optional(types.number()),
      default_currency_code: types.optional(types.string()),
      wallet_expiration: types.optional(
        z.lazy(() => WalletExpiration$inboundSchema),
      ),
      transfer: types.optional(
        z.lazy(() =>
          ComCrmWalletSelfServiceResourceGetTransactionsTransfer$inboundSchema
        ),
      ),
      blocked_by: types.optional(z.lazy(() => BlockedBy$inboundSchema)),
    }),
    z.transform((v) => {
      return remap$(v, {
        "posted_on": "postedOn",
        "reward_event": "rewardEvent",
        "financial_event": "financialEvent",
        "wallet_fee": "walletFee",
        "exchange_rate": "exchangeRate",
        "total_default_currency": "totalDefaultCurrency",
        "default_currency_code": "defaultCurrencyCode",
        "wallet_expiration": "walletExpiration",
        "blocked_by": "blockedBy",
      });
    }),
  );

export function comCrmWalletSelfServiceResourceGetTransactionsContentFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmWalletSelfServiceResourceGetTransactionsContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmWalletSelfServiceResourceGetTransactionsContent$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmWalletSelfServiceResourceGetTransactionsContent' from JSON`,
  );
}

/** @internal */
export const ComCrmWalletSelfServiceResourceGetTransactionsResponse$inboundSchema:
  z.ZodMiniType<
    ComCrmWalletSelfServiceResourceGetTransactionsResponse,
    unknown
  > = z.object({
    paging: types.optional(
      z.lazy(() =>
        ComCrmWalletSelfServiceResourceGetTransactionsPaging$inboundSchema
      ),
    ),
    content: types.optional(
      z.array(z.lazy(() =>
        ComCrmWalletSelfServiceResourceGetTransactionsContent$inboundSchema
      )),
    ),
  });

export function comCrmWalletSelfServiceResourceGetTransactionsResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmWalletSelfServiceResourceGetTransactionsResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmWalletSelfServiceResourceGetTransactionsResponse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmWalletSelfServiceResourceGetTransactionsResponse' from JSON`,
  );
}
