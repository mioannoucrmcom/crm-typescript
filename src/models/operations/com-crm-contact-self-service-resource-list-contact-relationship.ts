/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 * @generated-id: 4e5221b053e9
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

/**
 * Defines how the results will be ordered</br>Default:DESC
 */
export const ComCrmContactSelfServiceResourceListContactRelationshipOrder = {
  Asc: "ASC",
  Desc: "DESC",
} as const;
/**
 * Defines how the results will be ordered</br>Default:DESC
 */
export type ComCrmContactSelfServiceResourceListContactRelationshipOrder =
  ClosedEnum<
    typeof ComCrmContactSelfServiceResourceListContactRelationshipOrder
  >;

export type ComCrmContactSelfServiceResourceListContactRelationshipRequest = {
  /**
   * The contact identifier whose relationships will be retrieved
   */
  id: string;
  /**
   * The group name that the contact person belongs to
   */
  group?: string | undefined;
  /**
   * Defaults to false. If set to true, the member’s assigned devices are included in the response.
   */
  includeDevices?: boolean | undefined;
  /**
   * Defaults to false. If set to true, the member's usage allowance per product-related item is included in the response.
   */
  includeProductAllowance?: boolean | undefined;
  /**
   * Defaults to false. If set to true, the member’s remaining accumulated amounts are included in the response.
   */
  includeRemainingAllowance?: boolean | undefined;
  /**
   * If set to true, the community member’s termed transfer details will be included in the response. Default is false.
   */
  includeTermedTransfers?: boolean | undefined;
  /**
   *  Determine if a "total" will be returned in paging reference. If set to True, then "total" is also returned but it will return up to 10K value. If set to False, then the "total" in paging is null.
   */
  includeTotal?: boolean | undefined;
  /**
   * Defines how the results will be ordered</br>Default:DESC
   */
  order?:
    | ComCrmContactSelfServiceResourceListContactRelationshipOrder
    | undefined;
  /**
   * The page number that should be retrieved</br>Default:1
   */
  page?: number | undefined;
  /**
   * The size (total records) of each page</br>Default:10
   */
  size?: number | undefined;
  /**
   * Defines on which attribute the results should be sorted</br>Default:CREATED_DATE
   */
  sort?: string | undefined;
};

export type ComCrmContactSelfServiceResourceListContactRelationshipPaging = {
  /**
   * The page number
   */
  page?: number | undefined;
  /**
   * The number of records per page
   */
  size?: number | undefined;
  /**
   * The total number of records. If "include_total" is not specified, then this total is null. If "include_total" is specified, total has a value but it is accurate up to 10K records.
   */
  total?: number | undefined;
  /**
   * Shows if there are more records available to fetch
   */
  hasMore?: boolean | undefined;
};

/**
 * The community relation that the contact has
 */
export type ComCrmContactSelfServiceResourceListContactRelationshipRelation = {
  /**
   * The community relation identifier
   */
  id?: string | undefined;
  /**
   * The community relation name
   */
  name?: string | undefined;
};

export const ComCrmContactSelfServiceResourceListContactRelationshipPermission =
  {
    ContactManagement: "CONTACT_MANAGEMENT",
    ServiceRequestsManagement: "SERVICE_REQUESTS_MANAGEMENT",
    OrdersManagement: "ORDERS_MANAGEMENT",
    FullAccess: "FULL_ACCESS",
  } as const;
export type ComCrmContactSelfServiceResourceListContactRelationshipPermission =
  OpenEnum<
    typeof ComCrmContactSelfServiceResourceListContactRelationshipPermission
  >;

/**
 * A list of custom fields whose values can be set when creating or updating entities
 */
export type ComCrmContactSelfServiceResourceListContactRelationshipCustomField =
  {
    /**
     * The custom field’s unique key
     */
    key?: string | undefined;
    /**
     * The custom field’s value
     */
    value?: string | undefined;
  };

export type ComCrmContactSelfServiceResourceListContactRelationshipDevice = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The device serial number
   */
  serialNumber?: string | undefined;
  /**
   * The device custom fields
   */
  customFields?:
    | Array<ComCrmContactSelfServiceResourceListContactRelationshipCustomField>
    | undefined;
};

/**
 * The phone country code
 */
export const ComCrmContactSelfServiceResourceListContactRelationshipCountryCode =
  {
    Abw: "ABW",
    Afg: "AFG",
    Ago: "AGO",
    Aia: "AIA",
    Ala: "ALA",
    Alb: "ALB",
    And: "AND",
    Ant: "ANT",
    Are: "ARE",
    Arg: "ARG",
    Arm: "ARM",
    Asm: "ASM",
    Ata: "ATA",
    Atf: "ATF",
    Atg: "ATG",
    Aus: "AUS",
    Aut: "AUT",
    Aze: "AZE",
    Bdi: "BDI",
    Bel: "BEL",
    Ben: "BEN",
    Bes: "BES",
    Bfa: "BFA",
    Bgd: "BGD",
    Bgr: "BGR",
    Bhr: "BHR",
    Bhs: "BHS",
    Bih: "BIH",
    Blm: "BLM",
    Blr: "BLR",
    Blz: "BLZ",
    Bmu: "BMU",
    Bol: "BOL",
    Bra: "BRA",
    Brb: "BRB",
    Brn: "BRN",
    Btn: "BTN",
    Bvt: "BVT",
    Bwa: "BWA",
    Caf: "CAF",
    Can: "CAN",
    Cck: "CCK",
    Che: "CHE",
    Chl: "CHL",
    Chn: "CHN",
    Civ: "CIV",
    Cmr: "CMR",
    Cod: "COD",
    Cog: "COG",
    Cok: "COK",
    Col: "COL",
    Com: "COM",
    Cpv: "CPV",
    Cri: "CRI",
    Cub: "CUB",
    Cuw: "CUW",
    Cxr: "CXR",
    Cym: "CYM",
    Cyp: "CYP",
    Cze: "CZE",
    Deu: "DEU",
    Dji: "DJI",
    Dma: "DMA",
    Dnk: "DNK",
    Dom: "DOM",
    Dza: "DZA",
    Ecu: "ECU",
    Egy: "EGY",
    Eri: "ERI",
    Esh: "ESH",
    Esp: "ESP",
    Est: "EST",
    Eth: "ETH",
    Fin: "FIN",
    Fji: "FJI",
    Flk: "FLK",
    Fra: "FRA",
    Fro: "FRO",
    Fsm: "FSM",
    Gab: "GAB",
    Gbr: "GBR",
    Geo: "GEO",
    Ggy: "GGY",
    Gha: "GHA",
    Gib: "GIB",
    Gin: "GIN",
    Glp: "GLP",
    Gmb: "GMB",
    Gnb: "GNB",
    Gnq: "GNQ",
    Grc: "GRC",
    Grd: "GRD",
    Grl: "GRL",
    Gtm: "GTM",
    Guf: "GUF",
    Gum: "GUM",
    Guy: "GUY",
    Hkg: "HKG",
    Hmd: "HMD",
    Hnd: "HND",
    Hrv: "HRV",
    Hti: "HTI",
    Hun: "HUN",
    Idn: "IDN",
    Imn: "IMN",
    Ind: "IND",
    Iot: "IOT",
    Irl: "IRL",
    Irn: "IRN",
    Irq: "IRQ",
    Isl: "ISL",
    Isr: "ISR",
    Ita: "ITA",
    Jam: "JAM",
    Jey: "JEY",
    Jor: "JOR",
    Jpn: "JPN",
    Kaz: "KAZ",
    Ken: "KEN",
    Kgz: "KGZ",
    Khm: "KHM",
    Kir: "KIR",
    Kna: "KNA",
    Kor: "KOR",
    Kwt: "KWT",
    Lao: "LAO",
    Lbn: "LBN",
    Lbr: "LBR",
    Lby: "LBY",
    Lca: "LCA",
    Lie: "LIE",
    Lka: "LKA",
    Lso: "LSO",
    Ltu: "LTU",
    Lux: "LUX",
    Lva: "LVA",
    Mac: "MAC",
    Maf: "MAF",
    Mar: "MAR",
    Mco: "MCO",
    Mda: "MDA",
    Mdg: "MDG",
    Mdv: "MDV",
    Mex: "MEX",
    Mhl: "MHL",
    Mkd: "MKD",
    Mli: "MLI",
    Mlt: "MLT",
    Mmr: "MMR",
    Mne: "MNE",
    Mng: "MNG",
    Mnp: "MNP",
    Moz: "MOZ",
    Mrt: "MRT",
    Msr: "MSR",
    Mtq: "MTQ",
    Mus: "MUS",
    Mwi: "MWI",
    Mys: "MYS",
    Myt: "MYT",
    Nam: "NAM",
    Ncl: "NCL",
    Ner: "NER",
    Nfk: "NFK",
    Nga: "NGA",
    Nic: "NIC",
    Niu: "NIU",
    Nld: "NLD",
    Nor: "NOR",
    Npl: "NPL",
    Nru: "NRU",
    Nzl: "NZL",
    Omn: "OMN",
    Pak: "PAK",
    Pan: "PAN",
    Pcn: "PCN",
    Per: "PER",
    Phl: "PHL",
    Plw: "PLW",
    Png: "PNG",
    Pol: "POL",
    Pri: "PRI",
    Prk: "PRK",
    Prt: "PRT",
    Pry: "PRY",
    Pse: "PSE",
    Pyf: "PYF",
    Qat: "QAT",
    Reu: "REU",
    Rks: "RKS",
    Rou: "ROU",
    Rus: "RUS",
    Rwa: "RWA",
    Sau: "SAU",
    Sdn: "SDN",
    Sen: "SEN",
    Sgp: "SGP",
    Sgs: "SGS",
    Shn: "SHN",
    Sjm: "SJM",
    Slb: "SLB",
    Sle: "SLE",
    Slv: "SLV",
    Smr: "SMR",
    Som: "SOM",
    Spm: "SPM",
    Srb: "SRB",
    Ssd: "SSD",
    Stp: "STP",
    Sur: "SUR",
    Svk: "SVK",
    Svn: "SVN",
    Swe: "SWE",
    Swz: "SWZ",
    Sxm: "SXM",
    Syc: "SYC",
    Syr: "SYR",
    Tca: "TCA",
    Tcd: "TCD",
    Tgo: "TGO",
    Tha: "THA",
    Tjk: "TJK",
    Tkl: "TKL",
    Tkm: "TKM",
    Tls: "TLS",
    Ton: "TON",
    Tto: "TTO",
    Tun: "TUN",
    Tur: "TUR",
    Tuv: "TUV",
    Twn: "TWN",
    Tza: "TZA",
    Uga: "UGA",
    Ukr: "UKR",
    Umi: "UMI",
    Ury: "URY",
    Usa: "USA",
    Uzb: "UZB",
    Vat: "VAT",
    Vct: "VCT",
    Ven: "VEN",
    Vgb: "VGB",
    Vir: "VIR",
    Vnm: "VNM",
    Vut: "VUT",
    Wlf: "WLF",
    Wsm: "WSM",
    Yem: "YEM",
    Zaf: "ZAF",
    Zmb: "ZMB",
    Zwe: "ZWE",
  } as const;
/**
 * The phone country code
 */
export type ComCrmContactSelfServiceResourceListContactRelationshipCountryCode =
  OpenEnum<
    typeof ComCrmContactSelfServiceResourceListContactRelationshipCountryCode
  >;

/**
 * The contact phone number
 */
export type ComCrmContactSelfServiceResourceListContactRelationshipPhone = {
  /**
   * The phone country code
   */
  countryCode?:
    | ComCrmContactSelfServiceResourceListContactRelationshipCountryCode
    | undefined;
  /**
   * The phone number.
   */
  number?: string | undefined;
};

/**
 * The contact's wallet details
 */
export type ComCrmContactSelfServiceResourceListContactRelationshipWallet = {
  /**
   * The wallet identifier
   */
  id?: string | undefined;
};

/**
 * The contact (parent or member in the respective community)
 */
export type ComCrmContactSelfServiceResourceListContactRelationshipContact = {
  /**
   * The contact identifier
   */
  id?: string | undefined;
  /**
   * The contact first name
   */
  firstName?: string | undefined;
  /**
   * The contact last name
   */
  lastName?: string | undefined;
  /**
   * The contact phone number
   */
  phone?:
    | ComCrmContactSelfServiceResourceListContactRelationshipPhone
    | undefined;
  /**
   * The contact email address
   */
  email?: string | undefined;
  /**
   * The contact's wallet details
   */
  wallet?:
    | ComCrmContactSelfServiceResourceListContactRelationshipWallet
    | undefined;
};

export type ComCrmContactSelfServiceResourceListContactRelationshipWalletSharingCommercePool =
  {
    /**
     * The commerce pool identifier
     */
    id?: string | undefined;
    /**
     * The commerce pool name
     */
    name?: string | undefined;
    /**
     * The commerce pool description
     */
    description?: string | undefined;
  };

/**
 * Defines whether money requests will require an acceptance from the community owner or will be automatically applied
 */
export const ComCrmContactSelfServiceResourceListContactRelationshipMethod = {
  Auto: "AUTO",
  Manual: "MANUAL",
} as const;
/**
 * Defines whether money requests will require an acceptance from the community owner or will be automatically applied
 */
export type ComCrmContactSelfServiceResourceListContactRelationshipMethod =
  OpenEnum<
    typeof ComCrmContactSelfServiceResourceListContactRelationshipMethod
  >;

/**
 * Defines whether the community person will be able to use/request money from community owner wallet
 */
export type ComCrmContactSelfServiceResourceListContactRelationshipWalletSharing =
  {
    /**
     * Defines if wallet sharing is enabled
     */
    isEnabled?: boolean | undefined;
    /**
     * Defines the commerce pools that the community person is allowed to use/transfer wallet money
     */
    commercePools?:
      | Array<
        ComCrmContactSelfServiceResourceListContactRelationshipWalletSharingCommercePool
      >
      | undefined;
    /**
     * Defines whether money requests will require an acceptance from the community owner or will be automatically applied
     */
    method?:
      | ComCrmContactSelfServiceResourceListContactRelationshipMethod
      | undefined;
    /**
     * Defines the maximum amount that can be transferred per calendar month
     */
    maxAmount?: number | undefined;
    /**
     * Defines the remaining amount that can be transferred per calendar month
     */
    remainingAmount?: number | undefined;
  };

/**
 * How much can be consumed
 */
export type ComCrmContactSelfServiceResourceListContactRelationshipAccumulatedAllowanceCashLimits =
  {
    /**
     * Allowance per transaction
     */
    perTransaction?: number | undefined;
    /**
     * Allowance per day
     */
    perDay?: number | undefined;
    /**
     * Allowance per billing cycle
     */
    perBillingCycle?: number | undefined;
  };

/**
 * The community's accumulated cash allowance, i.e. how much can be consumed among all products which are consumed through the community. This allowance is defined only in amount of money and it's evaluated based on the usage's rating (how much it costs)
 */
export type ComCrmContactSelfServiceResourceListContactRelationshipAccumulatedAllowance =
  {
    /**
     * Currency code based on ISO 4217 standard
     */
    currency?: string | undefined;
    /**
     * How much can be consumed
     */
    cashLimits?:
      | ComCrmContactSelfServiceResourceListContactRelationshipAccumulatedAllowanceCashLimits
      | undefined;
  };

/**
 * Product setting. Allow usage to either a specific product or to products of a specific type or to products of a specific family or to products of a specific category
 */
export const ComCrmContactSelfServiceResourceListContactRelationshipItemType = {
  Product: "PRODUCT",
  Type: "TYPE",
  Family: "FAMILY",
  Category: "CATEGORY",
} as const;
/**
 * Product setting. Allow usage to either a specific product or to products of a specific type or to products of a specific family or to products of a specific category
 */
export type ComCrmContactSelfServiceResourceListContactRelationshipItemType =
  OpenEnum<
    typeof ComCrmContactSelfServiceResourceListContactRelationshipItemType
  >;

/**
 * Measurement unit. Applicable only when a specific usage product is included in the allowance
 */
export type ComCrmContactSelfServiceResourceListContactRelationshipMeasurementUnit =
  {
    /**
     * Measurement unit name
     */
    name?: string | undefined;
    /**
     * Measurement unit display name
     */
    displayName?: string | undefined;
  };

/**
 * How much rated usage can be consumed
 */
export type ComCrmContactSelfServiceResourceListContactRelationshipProductsAllowanceCashLimits =
  {
    /**
     * Allowance per transaction
     */
    perTransaction?: number | undefined;
    /**
     * Allowance per day
     */
    perDay?: number | undefined;
    /**
     * Allowance per billing cycle
     */
    perBillingCycle?: number | undefined;
  };

/**
 * Actual allowed and remaining usage (based on measurement units)
 */
export type ComCrmContactSelfServiceResourceListContactRelationshipUsageLimits =
  {
    /**
     * Allowance per transaction
     */
    perTransaction?: number | undefined;
    /**
     * Allowance per day
     */
    perDay?: number | undefined;
    /**
     * Allowance per billing cycle
     */
    perBillingCycle?: number | undefined;
  };

export type ComCrmContactSelfServiceResourceListContactRelationshipProductsAllowance =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    groupId?: string | undefined;
    /**
     * Currency code based on ISO 4217 standard
     */
    currency?: string | undefined;
    /**
     * Product setting. Allow usage to either a specific product or to products of a specific type or to products of a specific family or to products of a specific category
     */
    itemType?:
      | ComCrmContactSelfServiceResourceListContactRelationshipItemType
      | undefined;
    /**
     * The identifier of the item (the product or the product type or the product family or the product category)
     */
    itemId?: string | undefined;
    /**
     * The product name or product type name or product family name or product category name depending on item_type
     */
    name?: string | undefined;
    sku?: string | undefined;
    /**
     * Measurement unit. Applicable only when a specific usage product is included in the allowance
     */
    measurementUnit?:
      | ComCrmContactSelfServiceResourceListContactRelationshipMeasurementUnit
      | undefined;
    /**
     * How much rated usage can be consumed
     */
    cashLimits?:
      | ComCrmContactSelfServiceResourceListContactRelationshipProductsAllowanceCashLimits
      | undefined;
    /**
     * Actual allowed and remaining usage (based on measurement units)
     */
    usageLimits?:
      | ComCrmContactSelfServiceResourceListContactRelationshipUsageLimits
      | undefined;
  };

export type ComCrmContactSelfServiceResourceListContactRelationshipOrganisation =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The entity name
     */
    name?: string | undefined;
  };

/**
 * Defines the usage allowance
 */
export type ComCrmContactSelfServiceResourceListContactRelationshipUsageAllowance =
  {
    /**
     * The community's accumulated cash allowance, i.e. how much can be consumed among all products which are consumed through the community. This allowance is defined only in amount of money and it's evaluated based on the usage's rating (how much it costs)
     */
    accumulatedAllowance?:
      | ComCrmContactSelfServiceResourceListContactRelationshipAccumulatedAllowance
      | undefined;
    /**
     * If set to true, the member has the same usage allowance per product as the owner’s termed/one-time service.
     */
    sameAsOwner?: boolean | undefined;
    /**
     * List of items which can be consumed through the community. This set of items includes usage and non-traceable physical goods. If nothing is specified, then usage is allowed among all usage services/non-traceable physical goods that the business is selling
     */
    productsAllowance?:
      | Array<
        ComCrmContactSelfServiceResourceListContactRelationshipProductsAllowance
      >
      | undefined;
    /**
     * The allowed organisations to consume allowance
     */
    organisations?:
      | Array<
        ComCrmContactSelfServiceResourceListContactRelationshipOrganisation
      >
      | undefined;
  };

/**
 * The community member’s relation state. A person is considered as a valid community person only after they accept the invitation to join the community.
 */
export const ComCrmContactSelfServiceResourceListContactRelationshipState = {
  Pending: "PENDING",
  Accepted: "ACCEPTED",
  Rejected: "REJECTED",
} as const;
/**
 * The community member’s relation state. A person is considered as a valid community person only after they accept the invitation to join the community.
 */
export type ComCrmContactSelfServiceResourceListContactRelationshipState =
  OpenEnum<typeof ComCrmContactSelfServiceResourceListContactRelationshipState>;

/**
 * The currency code used for the transfer
 */
export const ComCrmContactSelfServiceResourceListContactRelationshipCurrencyCode =
  {
    Aed: "AED",
    Afn: "AFN",
    All: "ALL",
    Amd: "AMD",
    Ang: "ANG",
    Aoa: "AOA",
    Ars: "ARS",
    Aud: "AUD",
    Awg: "AWG",
    Azn: "AZN",
    Bam: "BAM",
    Bbd: "BBD",
    Bdt: "BDT",
    Bgn: "BGN",
    Bhd: "BHD",
    Bif: "BIF",
    Bmd: "BMD",
    Bnd: "BND",
    Bob: "BOB",
    Brl: "BRL",
    Bsd: "BSD",
    Btn: "BTN",
    Bwp: "BWP",
    Byr: "BYR",
    Bzd: "BZD",
    Cad: "CAD",
    Cdf: "CDF",
    Chf: "CHF",
    Clp: "CLP",
    Cny: "CNY",
    Cop: "COP",
    Crc: "CRC",
    Cuc: "CUC",
    Cup: "CUP",
    Cve: "CVE",
    Czk: "CZK",
    Djf: "DJF",
    Dkk: "DKK",
    Dop: "DOP",
    Dzd: "DZD",
    Egp: "EGP",
    Ern: "ERN",
    Etb: "ETB",
    Eur: "EUR",
    Fjd: "FJD",
    Fkp: "FKP",
    Gbp: "GBP",
    Gel: "GEL",
    Ggp: "GGP",
    Ghs: "GHS",
    Gip: "GIP",
    Gmd: "GMD",
    Gnf: "GNF",
    Gtq: "GTQ",
    Gyd: "GYD",
    Hkd: "HKD",
    Hnl: "HNL",
    Hrk: "HRK",
    Htg: "HTG",
    Huf: "HUF",
    Idr: "IDR",
    Ils: "ILS",
    Imp: "IMP",
    Inr: "INR",
    Iqd: "IQD",
    Irr: "IRR",
    Isk: "ISK",
    Jep: "JEP",
    Jmd: "JMD",
    Jod: "JOD",
    Jpy: "JPY",
    Kes: "KES",
    Kgs: "KGS",
    Khr: "KHR",
    Kmf: "KMF",
    Kpw: "KPW",
    Krw: "KRW",
    Kwd: "KWD",
    Kyd: "KYD",
    Kzt: "KZT",
    Lak: "LAK",
    Lbp: "LBP",
    Lkr: "LKR",
    Lrd: "LRD",
    Lsl: "LSL",
    Lyd: "LYD",
    Mad: "MAD",
    Mdl: "MDL",
    Mga: "MGA",
    Mkd: "MKD",
    Mmk: "MMK",
    Mnt: "MNT",
    Mop: "MOP",
    Mro: "MRO",
    Mur: "MUR",
    Mvr: "MVR",
    Mwk: "MWK",
    Mxn: "MXN",
    Myr: "MYR",
    Mzn: "MZN",
    Nad: "NAD",
    Ngn: "NGN",
    Nio: "NIO",
    Nok: "NOK",
    Npr: "NPR",
    Nzd: "NZD",
    Omr: "OMR",
    Pab: "PAB",
    Pen: "PEN",
    Pgk: "PGK",
    Php: "PHP",
    Pkr: "PKR",
    Pln: "PLN",
    Pyg: "PYG",
    Qar: "QAR",
    Ron: "RON",
    Rsd: "RSD",
    Rub: "RUB",
    Rwf: "RWF",
    Sar: "SAR",
    Sbd: "SBD",
    Scr: "SCR",
    Sdg: "SDG",
    Sek: "SEK",
    Sgd: "SGD",
    Shp: "SHP",
    Sll: "SLL",
    Sos: "SOS",
    Spl: "SPL",
    Srd: "SRD",
    Std: "STD",
    Svc: "SVC",
    Syp: "SYP",
    Szl: "SZL",
    Thb: "THB",
    Tjs: "TJS",
    Tmt: "TMT",
    Tnd: "TND",
    Top: "TOP",
    Try: "TRY",
    Ttd: "TTD",
    Tvd: "TVD",
    Twd: "TWD",
    Tzs: "TZS",
    Uah: "UAH",
    Ugx: "UGX",
    Usd: "USD",
    Uyu: "UYU",
    Uzs: "UZS",
    Vef: "VEF",
    Vnd: "VND",
    Vuv: "VUV",
    Wst: "WST",
    Xaf: "XAF",
    Xcd: "XCD",
    Xdr: "XDR",
    Xof: "XOF",
    Xpf: "XPF",
    Yer: "YER",
    Zar: "ZAR",
    Zmw: "ZMW",
    Zwd: "ZWD",
    Pts: "PTS",
  } as const;
/**
 * The currency code used for the transfer
 */
export type ComCrmContactSelfServiceResourceListContactRelationshipCurrencyCode =
  OpenEnum<
    typeof ComCrmContactSelfServiceResourceListContactRelationshipCurrencyCode
  >;

export type ComCrmContactSelfServiceResourceListContactRelationshipTermedTransferCommercePool =
  {
    /**
     * Unique identifier of the commerce pool associated with the transfer (optional). If specified, the transferred funds are credited to the community member’s Commerce Pocket, if not, they are credited to the Business Pocket.
     */
    id?: string | undefined;
    /**
     * The commerce pool name
     */
    name?: string | undefined;
  };

/**
 * Transfers can be scheduled either weekly or monthly
 */
export const ComCrmContactSelfServiceResourceListContactRelationshipFrequency =
  {
    Weekly: "WEEKLY",
    Monthly: "MONTHLY",
  } as const;
/**
 * Transfers can be scheduled either weekly or monthly
 */
export type ComCrmContactSelfServiceResourceListContactRelationshipFrequency =
  OpenEnum<
    typeof ComCrmContactSelfServiceResourceListContactRelationshipFrequency
  >;

/**
 * Day of the week when the transfer will occur
 */
export const ComCrmContactSelfServiceResourceListContactRelationshipDayOfWeek =
  {
    Monday: "MONDAY",
    Tuesday: "TUESDAY",
    Wednesday: "WEDNESDAY",
    Thursday: "THURSDAY",
    Friday: "FRIDAY",
    Saturday: "SATURDAY",
    Sunday: "SUNDAY",
  } as const;
/**
 * Day of the week when the transfer will occur
 */
export type ComCrmContactSelfServiceResourceListContactRelationshipDayOfWeek =
  ClosedEnum<
    typeof ComCrmContactSelfServiceResourceListContactRelationshipDayOfWeek
  >;

/**
 * How often the transfer will occur
 */
export type ComCrmContactSelfServiceResourceListContactRelationshipSchedule = {
  /**
   * Transfers can be scheduled either weekly or monthly
   */
  frequency?:
    | ComCrmContactSelfServiceResourceListContactRelationshipFrequency
    | undefined;
  /**
   * Day of the week when the transfer will occur
   */
  dayOfWeek?:
    | ComCrmContactSelfServiceResourceListContactRelationshipDayOfWeek
    | undefined;
  /**
   * The day of the month when the transfer occurs, if the specified day doesn’t exist in a month, the transfer occurs on the last day of the month
   */
  dayOfMonth?: number | undefined;
};

/**
 * The termed transfers set up by the community owner for the community member
 */
export type ComCrmContactSelfServiceResourceListContactRelationshipTermedTransfer =
  {
    /**
     * Indicates whether the recurring transfer is enabled, if disabled, the transfer will not be performed
     */
    isEnabled?: boolean | undefined;
    /**
     * The amount to be transferred
     */
    amount?: number | undefined;
    /**
     * The currency code used for the transfer
     */
    currencyCode?:
      | ComCrmContactSelfServiceResourceListContactRelationshipCurrencyCode
      | undefined;
    commercePool?:
      | ComCrmContactSelfServiceResourceListContactRelationshipTermedTransferCommercePool
      | undefined;
    /**
     * How often the transfer will occur
     */
    schedule?:
      | ComCrmContactSelfServiceResourceListContactRelationshipSchedule
      | undefined;
  };

export type ComCrmContactSelfServiceResourceListContactRelationshipContent = {
  /**
   * The contact relationship identifier
   */
  id?: string | undefined;
  /**
   * The community relation that the contact has
   */
  relation?:
    | ComCrmContactSelfServiceResourceListContactRelationshipRelation
    | undefined;
  /**
   * A name that groups together community members
   */
  group?: string | undefined;
  /**
   * Defines whether the contact member has full permissions. Applicable only for communities of a Contact Company.
   */
  isAdmin?: boolean | undefined;
  /**
   * Defines the (explicit) allowed permissions that the new contact member will have
   */
  permissions?:
    | Array<ComCrmContactSelfServiceResourceListContactRelationshipPermission>
    | undefined;
  /**
   * Defines the devices that have been assigned to the community member
   */
  devices?:
    | Array<ComCrmContactSelfServiceResourceListContactRelationshipDevice>
    | undefined;
  /**
   * The contact (parent or member in the respective community)
   */
  contact?:
    | ComCrmContactSelfServiceResourceListContactRelationshipContact
    | undefined;
  /**
   * Defines whether the community person will be able to use/request money from community owner wallet
   */
  walletSharing?:
    | ComCrmContactSelfServiceResourceListContactRelationshipWalletSharing
    | undefined;
  /**
   * Defines the usage allowance
   */
  usageAllowance?:
    | ComCrmContactSelfServiceResourceListContactRelationshipUsageAllowance
    | undefined;
  /**
   * The community member’s relation state. A person is considered as a valid community person only after they accept the invitation to join the community.
   */
  state?:
    | ComCrmContactSelfServiceResourceListContactRelationshipState
    | undefined;
  /**
   * The termed transfers set up by the community owner for the community member
   */
  termedTransfer?:
    | ComCrmContactSelfServiceResourceListContactRelationshipTermedTransfer
    | undefined;
};

/**
 * OK
 */
export type ComCrmContactSelfServiceResourceListContactRelationshipResponse = {
  paging?:
    | ComCrmContactSelfServiceResourceListContactRelationshipPaging
    | undefined;
  content?:
    | Array<ComCrmContactSelfServiceResourceListContactRelationshipContent>
    | undefined;
};

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipOrder$outboundSchema:
  z.ZodMiniEnum<
    typeof ComCrmContactSelfServiceResourceListContactRelationshipOrder
  > = z.enum(ComCrmContactSelfServiceResourceListContactRelationshipOrder);

/** @internal */
export type ComCrmContactSelfServiceResourceListContactRelationshipRequest$Outbound =
  {
    id: string;
    group?: string | undefined;
    include_devices?: boolean | undefined;
    include_product_allowance?: boolean | undefined;
    include_remaining_allowance?: boolean | undefined;
    include_termed_transfers?: boolean | undefined;
    include_total?: boolean | undefined;
    order?: string | undefined;
    page?: number | undefined;
    size?: number | undefined;
    sort?: string | undefined;
  };

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipRequest$outboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipRequest$Outbound,
    ComCrmContactSelfServiceResourceListContactRelationshipRequest
  > = z.pipe(
    z.object({
      id: z.string(),
      group: z.optional(z.string()),
      includeDevices: z.optional(z.boolean()),
      includeProductAllowance: z.optional(z.boolean()),
      includeRemainingAllowance: z.optional(z.boolean()),
      includeTermedTransfers: z.optional(z.boolean()),
      includeTotal: z.optional(z.boolean()),
      order: z.optional(
        ComCrmContactSelfServiceResourceListContactRelationshipOrder$outboundSchema,
      ),
      page: z.optional(z.int()),
      size: z.optional(z.int()),
      sort: z.optional(z.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        includeDevices: "include_devices",
        includeProductAllowance: "include_product_allowance",
        includeRemainingAllowance: "include_remaining_allowance",
        includeTermedTransfers: "include_termed_transfers",
        includeTotal: "include_total",
      });
    }),
  );

export function comCrmContactSelfServiceResourceListContactRelationshipRequestToJSON(
  comCrmContactSelfServiceResourceListContactRelationshipRequest:
    ComCrmContactSelfServiceResourceListContactRelationshipRequest,
): string {
  return JSON.stringify(
    ComCrmContactSelfServiceResourceListContactRelationshipRequest$outboundSchema
      .parse(comCrmContactSelfServiceResourceListContactRelationshipRequest),
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipPaging$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipPaging,
    unknown
  > = z.pipe(
    z.object({
      page: types.optional(types.number()),
      size: types.optional(types.number()),
      total: types.optional(types.number()),
      has_more: types.optional(types.boolean()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "has_more": "hasMore",
      });
    }),
  );

export function comCrmContactSelfServiceResourceListContactRelationshipPagingFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceListContactRelationshipPaging,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceListContactRelationshipPaging$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceListContactRelationshipPaging' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipRelation$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipRelation,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
  });

export function comCrmContactSelfServiceResourceListContactRelationshipRelationFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceListContactRelationshipRelation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceListContactRelationshipRelation$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceListContactRelationshipRelation' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipPermission$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipPermission,
    unknown
  > = openEnums.inboundSchema(
    ComCrmContactSelfServiceResourceListContactRelationshipPermission,
  );

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipCustomField$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipCustomField,
    unknown
  > = z.object({
    key: types.optional(types.string()),
    value: types.optional(types.string()),
  });

export function comCrmContactSelfServiceResourceListContactRelationshipCustomFieldFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceListContactRelationshipCustomField,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceListContactRelationshipCustomField$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceListContactRelationshipCustomField' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipDevice$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipDevice,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      serial_number: types.optional(types.string()),
      custom_fields: types.optional(z.array(z.lazy(() =>
        ComCrmContactSelfServiceResourceListContactRelationshipCustomField$inboundSchema
      ))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "serial_number": "serialNumber",
        "custom_fields": "customFields",
      });
    }),
  );

export function comCrmContactSelfServiceResourceListContactRelationshipDeviceFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceListContactRelationshipDevice,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceListContactRelationshipDevice$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceListContactRelationshipDevice' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipCountryCode$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipCountryCode,
    unknown
  > = openEnums.inboundSchema(
    ComCrmContactSelfServiceResourceListContactRelationshipCountryCode,
  );

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipPhone$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipPhone,
    unknown
  > = z.pipe(
    z.object({
      country_code: types.optional(
        ComCrmContactSelfServiceResourceListContactRelationshipCountryCode$inboundSchema,
      ),
      number: types.optional(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "country_code": "countryCode",
      });
    }),
  );

export function comCrmContactSelfServiceResourceListContactRelationshipPhoneFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceListContactRelationshipPhone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceListContactRelationshipPhone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceListContactRelationshipPhone' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipWallet$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipWallet,
    unknown
  > = z.object({
    id: types.optional(types.string()),
  });

export function comCrmContactSelfServiceResourceListContactRelationshipWalletFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceListContactRelationshipWallet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceListContactRelationshipWallet$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceListContactRelationshipWallet' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipContact$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipContact,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      first_name: types.optional(types.string()),
      last_name: types.optional(types.string()),
      phone: types.optional(z.lazy(() =>
        ComCrmContactSelfServiceResourceListContactRelationshipPhone$inboundSchema
      )),
      email: types.optional(types.string()),
      wallet: types.optional(z.lazy(() =>
        ComCrmContactSelfServiceResourceListContactRelationshipWallet$inboundSchema
      )),
    }),
    z.transform((v) => {
      return remap$(v, {
        "first_name": "firstName",
        "last_name": "lastName",
      });
    }),
  );

export function comCrmContactSelfServiceResourceListContactRelationshipContactFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceListContactRelationshipContact,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceListContactRelationshipContact$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceListContactRelationshipContact' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipWalletSharingCommercePool$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipWalletSharingCommercePool,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    description: types.optional(types.string()),
  });

export function comCrmContactSelfServiceResourceListContactRelationshipWalletSharingCommercePoolFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceListContactRelationshipWalletSharingCommercePool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceListContactRelationshipWalletSharingCommercePool$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceListContactRelationshipWalletSharingCommercePool' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipMethod$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipMethod,
    unknown
  > = openEnums.inboundSchema(
    ComCrmContactSelfServiceResourceListContactRelationshipMethod,
  );

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipWalletSharing$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipWalletSharing,
    unknown
  > = z.pipe(
    z.object({
      is_enabled: types.optional(types.boolean()),
      commerce_pools: types.optional(z.array(z.lazy(() =>
        ComCrmContactSelfServiceResourceListContactRelationshipWalletSharingCommercePool$inboundSchema
      ))),
      method: types.optional(
        ComCrmContactSelfServiceResourceListContactRelationshipMethod$inboundSchema,
      ),
      max_amount: types.optional(types.number()),
      remaining_amount: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "is_enabled": "isEnabled",
        "commerce_pools": "commercePools",
        "max_amount": "maxAmount",
        "remaining_amount": "remainingAmount",
      });
    }),
  );

export function comCrmContactSelfServiceResourceListContactRelationshipWalletSharingFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceListContactRelationshipWalletSharing,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceListContactRelationshipWalletSharing$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceListContactRelationshipWalletSharing' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipAccumulatedAllowanceCashLimits$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipAccumulatedAllowanceCashLimits,
    unknown
  > = z.pipe(
    z.object({
      per_transaction: types.optional(types.number()),
      per_day: types.optional(types.number()),
      per_billing_cycle: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "per_transaction": "perTransaction",
        "per_day": "perDay",
        "per_billing_cycle": "perBillingCycle",
      });
    }),
  );

export function comCrmContactSelfServiceResourceListContactRelationshipAccumulatedAllowanceCashLimitsFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceListContactRelationshipAccumulatedAllowanceCashLimits,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceListContactRelationshipAccumulatedAllowanceCashLimits$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceListContactRelationshipAccumulatedAllowanceCashLimits' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipAccumulatedAllowance$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipAccumulatedAllowance,
    unknown
  > = z.pipe(
    z.object({
      currency: types.optional(types.string()),
      cash_limits: types.optional(z.lazy(() =>
        ComCrmContactSelfServiceResourceListContactRelationshipAccumulatedAllowanceCashLimits$inboundSchema
      )),
    }),
    z.transform((v) => {
      return remap$(v, {
        "cash_limits": "cashLimits",
      });
    }),
  );

export function comCrmContactSelfServiceResourceListContactRelationshipAccumulatedAllowanceFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceListContactRelationshipAccumulatedAllowance,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceListContactRelationshipAccumulatedAllowance$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceListContactRelationshipAccumulatedAllowance' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipItemType$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipItemType,
    unknown
  > = openEnums.inboundSchema(
    ComCrmContactSelfServiceResourceListContactRelationshipItemType,
  );

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipMeasurementUnit$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipMeasurementUnit,
    unknown
  > = z.pipe(
    z.object({
      name: types.optional(types.string()),
      display_name: types.optional(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "display_name": "displayName",
      });
    }),
  );

export function comCrmContactSelfServiceResourceListContactRelationshipMeasurementUnitFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceListContactRelationshipMeasurementUnit,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceListContactRelationshipMeasurementUnit$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceListContactRelationshipMeasurementUnit' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipProductsAllowanceCashLimits$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipProductsAllowanceCashLimits,
    unknown
  > = z.pipe(
    z.object({
      per_transaction: types.optional(types.number()),
      per_day: types.optional(types.number()),
      per_billing_cycle: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "per_transaction": "perTransaction",
        "per_day": "perDay",
        "per_billing_cycle": "perBillingCycle",
      });
    }),
  );

export function comCrmContactSelfServiceResourceListContactRelationshipProductsAllowanceCashLimitsFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceListContactRelationshipProductsAllowanceCashLimits,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceListContactRelationshipProductsAllowanceCashLimits$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceListContactRelationshipProductsAllowanceCashLimits' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipUsageLimits$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipUsageLimits,
    unknown
  > = z.pipe(
    z.object({
      per_transaction: types.optional(types.number()),
      per_day: types.optional(types.number()),
      per_billing_cycle: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "per_transaction": "perTransaction",
        "per_day": "perDay",
        "per_billing_cycle": "perBillingCycle",
      });
    }),
  );

export function comCrmContactSelfServiceResourceListContactRelationshipUsageLimitsFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceListContactRelationshipUsageLimits,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceListContactRelationshipUsageLimits$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceListContactRelationshipUsageLimits' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipProductsAllowance$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipProductsAllowance,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      group_id: types.optional(types.string()),
      currency: types.optional(types.string()),
      item_type: types.optional(
        ComCrmContactSelfServiceResourceListContactRelationshipItemType$inboundSchema,
      ),
      item_id: types.optional(types.string()),
      name: types.optional(types.string()),
      sku: types.optional(types.string()),
      measurement_unit: types.optional(z.lazy(() =>
        ComCrmContactSelfServiceResourceListContactRelationshipMeasurementUnit$inboundSchema
      )),
      cash_limits: types.optional(z.lazy(() =>
        ComCrmContactSelfServiceResourceListContactRelationshipProductsAllowanceCashLimits$inboundSchema
      )),
      usage_limits: types.optional(z.lazy(() =>
        ComCrmContactSelfServiceResourceListContactRelationshipUsageLimits$inboundSchema
      )),
    }),
    z.transform((v) => {
      return remap$(v, {
        "group_id": "groupId",
        "item_type": "itemType",
        "item_id": "itemId",
        "measurement_unit": "measurementUnit",
        "cash_limits": "cashLimits",
        "usage_limits": "usageLimits",
      });
    }),
  );

export function comCrmContactSelfServiceResourceListContactRelationshipProductsAllowanceFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceListContactRelationshipProductsAllowance,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceListContactRelationshipProductsAllowance$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceListContactRelationshipProductsAllowance' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipOrganisation$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipOrganisation,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
  });

export function comCrmContactSelfServiceResourceListContactRelationshipOrganisationFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceListContactRelationshipOrganisation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceListContactRelationshipOrganisation$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceListContactRelationshipOrganisation' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipUsageAllowance$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipUsageAllowance,
    unknown
  > = z.pipe(
    z.object({
      accumulated_allowance: types.optional(z.lazy(() =>
        ComCrmContactSelfServiceResourceListContactRelationshipAccumulatedAllowance$inboundSchema
      )),
      same_as_owner: types.optional(types.boolean()),
      products_allowance: types.optional(z.array(z.lazy(() =>
        ComCrmContactSelfServiceResourceListContactRelationshipProductsAllowance$inboundSchema
      ))),
      organisations: types.optional(z.array(z.lazy(() =>
        ComCrmContactSelfServiceResourceListContactRelationshipOrganisation$inboundSchema
      ))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "accumulated_allowance": "accumulatedAllowance",
        "same_as_owner": "sameAsOwner",
        "products_allowance": "productsAllowance",
      });
    }),
  );

export function comCrmContactSelfServiceResourceListContactRelationshipUsageAllowanceFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceListContactRelationshipUsageAllowance,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceListContactRelationshipUsageAllowance$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceListContactRelationshipUsageAllowance' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipState$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipState,
    unknown
  > = openEnums.inboundSchema(
    ComCrmContactSelfServiceResourceListContactRelationshipState,
  );

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipCurrencyCode$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipCurrencyCode,
    unknown
  > = openEnums.inboundSchema(
    ComCrmContactSelfServiceResourceListContactRelationshipCurrencyCode,
  );

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipTermedTransferCommercePool$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipTermedTransferCommercePool,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
  });

export function comCrmContactSelfServiceResourceListContactRelationshipTermedTransferCommercePoolFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceListContactRelationshipTermedTransferCommercePool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceListContactRelationshipTermedTransferCommercePool$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceListContactRelationshipTermedTransferCommercePool' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipFrequency$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipFrequency,
    unknown
  > = openEnums.inboundSchema(
    ComCrmContactSelfServiceResourceListContactRelationshipFrequency,
  );

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipDayOfWeek$inboundSchema:
  z.ZodMiniEnum<
    typeof ComCrmContactSelfServiceResourceListContactRelationshipDayOfWeek
  > = z.enum(ComCrmContactSelfServiceResourceListContactRelationshipDayOfWeek);

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipSchedule$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipSchedule,
    unknown
  > = z.pipe(
    z.object({
      frequency: types.optional(
        ComCrmContactSelfServiceResourceListContactRelationshipFrequency$inboundSchema,
      ),
      day_of_week: types.optional(
        ComCrmContactSelfServiceResourceListContactRelationshipDayOfWeek$inboundSchema,
      ),
      day_of_month: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "day_of_week": "dayOfWeek",
        "day_of_month": "dayOfMonth",
      });
    }),
  );

export function comCrmContactSelfServiceResourceListContactRelationshipScheduleFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceListContactRelationshipSchedule,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceListContactRelationshipSchedule$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceListContactRelationshipSchedule' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipTermedTransfer$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipTermedTransfer,
    unknown
  > = z.pipe(
    z.object({
      is_enabled: types.optional(types.boolean()),
      amount: types.optional(types.number()),
      currency_code: types.optional(
        ComCrmContactSelfServiceResourceListContactRelationshipCurrencyCode$inboundSchema,
      ),
      commerce_pool: types.optional(z.lazy(() =>
        ComCrmContactSelfServiceResourceListContactRelationshipTermedTransferCommercePool$inboundSchema
      )),
      schedule: types.optional(z.lazy(() =>
        ComCrmContactSelfServiceResourceListContactRelationshipSchedule$inboundSchema
      )),
    }),
    z.transform((v) => {
      return remap$(v, {
        "is_enabled": "isEnabled",
        "currency_code": "currencyCode",
        "commerce_pool": "commercePool",
      });
    }),
  );

export function comCrmContactSelfServiceResourceListContactRelationshipTermedTransferFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceListContactRelationshipTermedTransfer,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceListContactRelationshipTermedTransfer$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceListContactRelationshipTermedTransfer' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipContent$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipContent,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      relation: types.optional(z.lazy(() =>
        ComCrmContactSelfServiceResourceListContactRelationshipRelation$inboundSchema
      )),
      group: types.optional(types.string()),
      is_admin: types.optional(types.boolean()),
      permissions: types.optional(
        z.array(
          ComCrmContactSelfServiceResourceListContactRelationshipPermission$inboundSchema,
        ),
      ),
      devices: types.optional(z.array(z.lazy(() =>
        ComCrmContactSelfServiceResourceListContactRelationshipDevice$inboundSchema
      ))),
      contact: types.optional(z.lazy(() =>
        ComCrmContactSelfServiceResourceListContactRelationshipContact$inboundSchema
      )),
      wallet_sharing: types.optional(z.lazy(() =>
        ComCrmContactSelfServiceResourceListContactRelationshipWalletSharing$inboundSchema
      )),
      usage_allowance: types.optional(z.lazy(() =>
        ComCrmContactSelfServiceResourceListContactRelationshipUsageAllowance$inboundSchema
      )),
      state: types.optional(
        ComCrmContactSelfServiceResourceListContactRelationshipState$inboundSchema,
      ),
      termed_transfer: types.optional(z.lazy(() =>
        ComCrmContactSelfServiceResourceListContactRelationshipTermedTransfer$inboundSchema
      )),
    }),
    z.transform((v) => {
      return remap$(v, {
        "is_admin": "isAdmin",
        "wallet_sharing": "walletSharing",
        "usage_allowance": "usageAllowance",
        "termed_transfer": "termedTransfer",
      });
    }),
  );

export function comCrmContactSelfServiceResourceListContactRelationshipContentFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceListContactRelationshipContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceListContactRelationshipContent$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceListContactRelationshipContent' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceListContactRelationshipResponse$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceListContactRelationshipResponse,
    unknown
  > = z.object({
    paging: types.optional(
      z.lazy(() =>
        ComCrmContactSelfServiceResourceListContactRelationshipPaging$inboundSchema
      ),
    ),
    content: types.optional(
      z.array(z.lazy(() =>
        ComCrmContactSelfServiceResourceListContactRelationshipContent$inboundSchema
      )),
    ),
  });

export function comCrmContactSelfServiceResourceListContactRelationshipResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceListContactRelationshipResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceListContactRelationshipResponse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceListContactRelationshipResponse' from JSON`,
  );
}
