/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 * @generated-id: b459df378eac
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

/**
 * Filter based on the intent that tokens were requested
 */
export const QueryParamIntent = {
  ApprovePurchase: "APPROVE_PURCHASE",
  RejectPurchase: "REJECT_PURCHASE",
  Spend: "SPEND",
} as const;
/**
 * Filter based on the intent that tokens were requested
 */
export type QueryParamIntent = ClosedEnum<typeof QueryParamIntent>;

export type ListContactTokensSSRequest = {
  /**
   * The id of the contact whose tokens will be retrieved
   */
  id: string;
  /**
   * The id of the community to which the contact which the contact wants to spend from
   */
  communityId?: string | undefined;
  /**
   * Filter based on the intent that tokens were requested
   */
  intent?: QueryParamIntent | undefined;
};

/**
 * The intent for which the token was requested
 */
export const IntentResponse = {
  ApprovePurchase: "APPROVE_PURCHASE",
  RejectPurchase: "REJECT_PURCHASE",
  Spend: "SPEND",
} as const;
/**
 * The intent for which the token was requested
 */
export type IntentResponse = OpenEnum<typeof IntentResponse>;

export type ListContactTokensSSContent = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The requested token
   */
  value?: string | undefined;
  /**
   * A 16-digit numeric code that can be used instead of the token value
   */
  alternativeToken?: string | undefined;
  /**
   * The token expiration date
   */
  expiration?: number | undefined;
  /**
   * The amount requested to be spent
   */
  spendAmount?: number | undefined;
  /**
   * The intent for which the token was requested
   */
  intent?: IntentResponse | undefined;
  /**
   * The community for which the token was requested
   */
  communityId?: string | undefined;
};

/**
 * OK
 */
export type ListContactTokensSSResponse = {
  content?: Array<ListContactTokensSSContent> | undefined;
};

/** @internal */
export const QueryParamIntent$outboundSchema: z.ZodMiniEnum<
  typeof QueryParamIntent
> = z.enum(QueryParamIntent);

/** @internal */
export type ListContactTokensSSRequest$Outbound = {
  id: string;
  community_id?: string | undefined;
  intent?: string | undefined;
};

/** @internal */
export const ListContactTokensSSRequest$outboundSchema: z.ZodMiniType<
  ListContactTokensSSRequest$Outbound,
  ListContactTokensSSRequest
> = z.pipe(
  z.object({
    id: z.string(),
    communityId: z.optional(z.string()),
    intent: z.optional(QueryParamIntent$outboundSchema),
  }),
  z.transform((v) => {
    return remap$(v, {
      communityId: "community_id",
    });
  }),
);

export function listContactTokensSSRequestToJSON(
  listContactTokensSSRequest: ListContactTokensSSRequest,
): string {
  return JSON.stringify(
    ListContactTokensSSRequest$outboundSchema.parse(listContactTokensSSRequest),
  );
}

/** @internal */
export const IntentResponse$inboundSchema: z.ZodMiniType<
  IntentResponse,
  unknown
> = openEnums.inboundSchema(IntentResponse);

/** @internal */
export const ListContactTokensSSContent$inboundSchema: z.ZodMiniType<
  ListContactTokensSSContent,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    value: types.optional(types.string()),
    alternative_token: types.optional(types.string()),
    expiration: types.optional(types.number()),
    spend_amount: types.optional(types.number()),
    intent: types.optional(IntentResponse$inboundSchema),
    community_id: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "alternative_token": "alternativeToken",
      "spend_amount": "spendAmount",
      "community_id": "communityId",
    });
  }),
);

export function listContactTokensSSContentFromJSON(
  jsonString: string,
): SafeParseResult<ListContactTokensSSContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListContactTokensSSContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListContactTokensSSContent' from JSON`,
  );
}

/** @internal */
export const ListContactTokensSSResponse$inboundSchema: z.ZodMiniType<
  ListContactTokensSSResponse,
  unknown
> = z.object({
  content: types.optional(
    z.array(z.lazy(() => ListContactTokensSSContent$inboundSchema)),
  ),
});

export function listContactTokensSSResponseFromJSON(
  jsonString: string,
): SafeParseResult<ListContactTokensSSResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListContactTokensSSResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListContactTokensSSResponse' from JSON`,
  );
}
