/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 * @generated-id: 294e7410ad62
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSecurity =
  {
    secretAPIKey: string;
  };

/**
 * The product’s classification
 */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesQueryParamClassification =
  {
    OneTimeService: "ONE_TIME_SERVICE",
    TermedService: "TERMED_SERVICE",
  } as const;
/**
 * The product’s classification
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesQueryParamClassification =
  ClosedEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesQueryParamClassification
  >;

/**
 * Defines how the results will be ordered
 */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesOrderEnum =
  {
    Asc: "ASC",
    Desc: "DESC",
  } as const;
/**
 * Defines how the results will be ordered
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesOrderEnum =
  ClosedEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesOrderEnum
  >;

export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesRequest =
  {
    id: string;
    /**
     * The product’s classification
     */
    classification?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesQueryParamClassification
      | undefined;
    /**
     * Include future services for the subscription
     */
    includeFutureInfo?: boolean | undefined;
    /**
     * By default order information is not returned
     */
    includeOrderInfo?: boolean | undefined;
    /**
     * Set it to true to also include information for the services’ subscription.
     */
    includeSubscription?: boolean | undefined;
    /**
     * Unique identifier of the subscription that groups services by their billing cycle
     */
    subscriptionId?: string | undefined;
    /**
     * Determine if a "total" will be returned in paging reference. If set to True, then "total" is also returned but it will return up to 10K value. If set to False, then the "total" in paging is null.
     */
    includeTotal?: boolean | undefined;
    /**
     * Defines how the results will be ordered
     */
    order?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesOrderEnum
      | undefined;
    /**
     * The page number that should be retrieved
     */
    page?: number | undefined;
    /**
     * The size (total records) of each page
     */
    size?: number | undefined;
    /**
     * Defines on which attribute the results should be sorted
     */
    sort?: string | undefined;
  };

export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPaging =
  {
    /**
     * The page number
     */
    page?: number | undefined;
    /**
     * The number of records per page
     */
    size?: number | undefined;
    /**
     * The total number of records. If "include_total" is not specified, then this total is null. If "include_total" is specified, total has a value but it is accurate up to 10K records.
     */
    total?: number | undefined;
    /**
     * Shows if there are more records available to fetch
     */
    hasMore?: boolean | undefined;
  };

/**
 * Subscription Service's State
 */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesState =
  {
    Draft: "DRAFT",
    Effective: "EFFECTIVE",
    NotEffective: "NOT_EFFECTIVE",
    Paused: "PAUSED",
    Regretted: "REGRETTED",
    Cancelled: "CANCELLED",
    Swapped: "SWAPPED",
    Removed: "REMOVED",
  } as const;
/**
 * Subscription Service's State
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesState =
  OpenEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesState
  >;

/**
 * The service product's classification
 */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContentClassification =
  {
    ExpensesService: "EXPENSES_SERVICE",
    OneTimeService: "ONE_TIME_SERVICE",
    TermedService: "TERMED_SERVICE",
  } as const;
/**
 * The service product's classification
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContentClassification =
  OpenEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContentClassification
  >;

/**
 * Product Composition
 */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTypeComposition =
  {
    Flat: "FLAT",
    FixedBundle: "FIXED_BUNDLE",
    FlexibleBundle: "FLEXIBLE_BUNDLE",
    Composite: "COMPOSITE",
  } as const;
/**
 * Product Composition
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTypeComposition =
  OpenEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTypeComposition
  >;

/**
 * Determines whether a service is managed as a single quantity or as separate, independently managed instances on subscription
 */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesInstanceModel =
  {
    QuantityBased: "QUANTITY_BASED",
    LineBased: "LINE_BASED",
  } as const;
/**
 * Determines whether a service is managed as a single quantity or as separate, independently managed instances on subscription
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesInstanceModel =
  OpenEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesInstanceModel
  >;

/**
 * Service product information
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesProduct =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * Product name
     */
    name?: string | undefined;
    /**
     * Product SKU
     */
    sku?: string | undefined;
    /**
     * The service product's classification
     */
    classification?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContentClassification
      | undefined;
    /**
     * Product Composition
     */
    typeComposition?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTypeComposition
      | undefined;
    /**
     * Determines whether a service is managed as a single quantity or as separate, independently managed instances on subscription
     */
    instanceModel?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesInstanceModel
      | undefined;
  };

/**
 * Currency code based on ISO 4217 standard
 */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesCurrencyCode =
  {
    Aed: "AED",
    Afn: "AFN",
    All: "ALL",
    Amd: "AMD",
    Ang: "ANG",
    Aoa: "AOA",
    Ars: "ARS",
    Aud: "AUD",
    Awg: "AWG",
    Azn: "AZN",
    Bam: "BAM",
    Bbd: "BBD",
    Bdt: "BDT",
    Bgn: "BGN",
    Bhd: "BHD",
    Bif: "BIF",
    Bmd: "BMD",
    Bnd: "BND",
    Bob: "BOB",
    Brl: "BRL",
    Bsd: "BSD",
    Btn: "BTN",
    Bwp: "BWP",
    Byr: "BYR",
    Bzd: "BZD",
    Cad: "CAD",
    Cdf: "CDF",
    Chf: "CHF",
    Clp: "CLP",
    Cny: "CNY",
    Cop: "COP",
    Crc: "CRC",
    Cuc: "CUC",
    Cup: "CUP",
    Cve: "CVE",
    Czk: "CZK",
    Djf: "DJF",
    Dkk: "DKK",
    Dop: "DOP",
    Dzd: "DZD",
    Egp: "EGP",
    Ern: "ERN",
    Etb: "ETB",
    Eur: "EUR",
    Fjd: "FJD",
    Fkp: "FKP",
    Gbp: "GBP",
    Gel: "GEL",
    Ggp: "GGP",
    Ghs: "GHS",
    Gip: "GIP",
    Gmd: "GMD",
    Gnf: "GNF",
    Gtq: "GTQ",
    Gyd: "GYD",
    Hkd: "HKD",
    Hnl: "HNL",
    Hrk: "HRK",
    Htg: "HTG",
    Huf: "HUF",
    Idr: "IDR",
    Ils: "ILS",
    Imp: "IMP",
    Inr: "INR",
    Iqd: "IQD",
    Irr: "IRR",
    Isk: "ISK",
    Jep: "JEP",
    Jmd: "JMD",
    Jod: "JOD",
    Jpy: "JPY",
    Kes: "KES",
    Kgs: "KGS",
    Khr: "KHR",
    Kmf: "KMF",
    Kpw: "KPW",
    Krw: "KRW",
    Kwd: "KWD",
    Kyd: "KYD",
    Kzt: "KZT",
    Lak: "LAK",
    Lbp: "LBP",
    Lkr: "LKR",
    Lrd: "LRD",
    Lsl: "LSL",
    Lyd: "LYD",
    Mad: "MAD",
    Mdl: "MDL",
    Mga: "MGA",
    Mkd: "MKD",
    Mmk: "MMK",
    Mnt: "MNT",
    Mop: "MOP",
    Mro: "MRO",
    Mur: "MUR",
    Mvr: "MVR",
    Mwk: "MWK",
    Mxn: "MXN",
    Myr: "MYR",
    Mzn: "MZN",
    Nad: "NAD",
    Ngn: "NGN",
    Nio: "NIO",
    Nok: "NOK",
    Npr: "NPR",
    Nzd: "NZD",
    Omr: "OMR",
    Pab: "PAB",
    Pen: "PEN",
    Pgk: "PGK",
    Php: "PHP",
    Pkr: "PKR",
    Pln: "PLN",
    Pyg: "PYG",
    Qar: "QAR",
    Ron: "RON",
    Rsd: "RSD",
    Rub: "RUB",
    Rwf: "RWF",
    Sar: "SAR",
    Sbd: "SBD",
    Scr: "SCR",
    Sdg: "SDG",
    Sek: "SEK",
    Sgd: "SGD",
    Shp: "SHP",
    Sll: "SLL",
    Sos: "SOS",
    Spl: "SPL",
    Srd: "SRD",
    Std: "STD",
    Svc: "SVC",
    Syp: "SYP",
    Szl: "SZL",
    Thb: "THB",
    Tjs: "TJS",
    Tmt: "TMT",
    Tnd: "TND",
    Top: "TOP",
    Try: "TRY",
    Ttd: "TTD",
    Tvd: "TVD",
    Twd: "TWD",
    Tzs: "TZS",
    Uah: "UAH",
    Ugx: "UGX",
    Usd: "USD",
    Uyu: "UYU",
    Uzs: "UZS",
    Vef: "VEF",
    Vnd: "VND",
    Vuv: "VUV",
    Wst: "WST",
    Xaf: "XAF",
    Xcd: "XCD",
    Xdr: "XDR",
    Xof: "XOF",
    Xpf: "XPF",
    Yer: "YER",
    Zar: "ZAR",
    Zmw: "ZMW",
    Zwd: "ZWD",
    Pts: "PTS",
  } as const;
/**
 * Currency code based on ISO 4217 standard
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesCurrencyCode =
  OpenEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesCurrencyCode
  >;

/**
 * Defines whether the price is tax inclusive or not. Defaults to the system's Taxation setting
 */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTaxModel =
  {
    TaxInclusive: "TAX_INCLUSIVE",
    TaxExclusive: "TAX_EXCLUSIVE",
  } as const;
/**
 * Defines whether the price is tax inclusive or not. Defaults to the system's Taxation setting
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTaxModel =
  OpenEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTaxModel
  >;

/**
 * The billing cycle's unit of time
 */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPriceUot =
  {
    Second: "SECOND",
    Minute: "MINUTE",
    Hour: "HOUR",
    Day: "DAY",
    Week: "WEEK",
    Month: "MONTH",
    Year: "YEAR",
    Overall: "OVERALL",
  } as const;
/**
 * The billing cycle's unit of time
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPriceUot =
  OpenEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPriceUot
  >;

/**
 * How often the service is billed
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPriceBillingPeriod =
  {
    /**
     * The billing cycle's duration
     */
    duration?: number | undefined;
    /**
     * The billing cycle's unit of time
     */
    uot?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPriceUot
      | undefined;
  };

/**
 * Service pricing information
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPrice =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * Price
     */
    price?: number | undefined;
    /**
     * Currency code based on ISO 4217 standard
     */
    currencyCode?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesCurrencyCode
      | undefined;
    /**
     * Defines whether the price is tax inclusive or not. Defaults to the system's Taxation setting
     */
    taxModel:
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTaxModel;
    /**
     * How often the service is billed
     */
    billingPeriod?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPriceBillingPeriod
      | undefined;
    /**
     * The label of the price
     */
    label?: string | undefined;
  };

/**
 * Latest billing information of the service
 */
export type Billing = {
  /**
   * Latest billed from date
   */
  billedFrom?: number | undefined;
  /**
   * Billed up to date
   */
  billedTo?: number | undefined;
};

/**
 * Billing model
 */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesBillingModel =
  {
    PostBill: "POST_BILL",
    PreBill: "PRE_BILL",
  } as const;
/**
 * Billing model
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesBillingModel =
  OpenEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesBillingModel
  >;

/**
 * Contract period unit of time
 */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContractPeriodUot =
  {
    Second: "SECOND",
    Minute: "MINUTE",
    Hour: "HOUR",
    Day: "DAY",
    Week: "WEEK",
    Month: "MONTH",
    Year: "YEAR",
    Overall: "OVERALL",
  } as const;
/**
 * Contract period unit of time
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContractPeriodUot =
  OpenEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContractPeriodUot
  >;

/**
 * Contract period details
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContractPeriod =
  {
    /**
     * ow long the service will be/was in contract
     */
    duration?: number | undefined;
    /**
     * Contract period unit of time
     */
    uot?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContractPeriodUot
      | undefined;
    /**
     * Contract period start date
     */
    startDate?: number | undefined;
    /**
     * Contract period end date
     */
    endDate?: number | undefined;
  };

/**
 * Service's termed period
 */
export type TermedPeriod = {
  /**
   * How many billing cycles each termed period covers
   */
  billingCycles?: number | undefined;
  /**
   * Latest termed period start date
   */
  startDate?: number | undefined;
  /**
   * Termed period end date
   */
  endDate?: number | undefined;
};

/**
 * The period of time that service will be accessible. Applicable only for one-time services
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesAccessPeriod =
  {
    startDate?: number | undefined;
    endDate?: number | undefined;
  };

/**
 * Services's price terms
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTerms =
  {
    /**
     * Billing model
     */
    billingModel?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesBillingModel
      | undefined;
    /**
     * Auto-renewed or not
     */
    autoRenew?: boolean | undefined;
    /**
     * Service in contract or not
     */
    inContract?: boolean | undefined;
    /**
     * Contract period details
     */
    contractPeriod?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContractPeriod
      | undefined;
    /**
     * Service's termed period
     */
    termedPeriod?: TermedPeriod | undefined;
    /**
     * Service quantity
     */
    quantity?: number | undefined;
    /**
     * The period of time that service will be accessible. Applicable only for one-time services
     */
    accessPeriod?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesAccessPeriod
      | undefined;
  };

/**
 * Trial period unit of time
 */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTrialPeriodUot =
  {
    Second: "SECOND",
    Minute: "MINUTE",
    Hour: "HOUR",
    Day: "DAY",
    Week: "WEEK",
    Month: "MONTH",
    Year: "YEAR",
    Overall: "OVERALL",
  } as const;
/**
 * Trial period unit of time
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTrialPeriodUot =
  OpenEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTrialPeriodUot
  >;

/**
 * Service currently in trial or not
 */
export const TrialState = {
  InTrial: "IN_TRIAL",
  TrialEnded: "TRIAL_ENDED",
} as const;
/**
 * Service currently in trial or not
 */
export type TrialState = OpenEnum<typeof TrialState>;

/**
 * Service's trial period details
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTrialPeriod =
  {
    /**
     * Trial period start date
     */
    startDate?: number | undefined;
    /**
     * Trial period end date
     */
    endDate?: number | undefined;
    /**
     * Trial period duration
     */
    duration?: number | undefined;
    /**
     * Trial period unit of time
     */
    uot?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTrialPeriodUot
      | undefined;
    /**
     * Service currently in trial or not
     */
    trialState?: TrialState | undefined;
  };

/**
 * Applicable while the service is paused
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPausedPeriod =
  {
    /**
     * Paused period start date
     */
    startDate?: number | undefined;
    /**
     * Paused period end date
     */
    endDate?: number | undefined;
  };

/**
 * Bundle service product
 */
export type BundledServiceProduct = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
  /**
   * The entity sku
   */
  sku?: string | undefined;
};

/**
 * Applicable when the service was added as part of a bundled service
 */
export type BundledService = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * Bundle service product
   */
  product?: BundledServiceProduct | undefined;
};

/**
 * Bundle device product
 */
export type BundledDeviceProduct = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
  /**
   * The entity sku
   */
  sku?: string | undefined;
};

/**
 * Applicable when the service was added as part of a bundled device
 */
export type BundledDevice = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * Bundle device serial number
   */
  serialNumber?: string | undefined;
  /**
   * Bundle device product
   */
  product?: BundledDeviceProduct | undefined;
};

/**
 * The billing cycle's unit of time
 */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionUot =
  {
    Second: "SECOND",
    Minute: "MINUTE",
    Hour: "HOUR",
    Day: "DAY",
    Week: "WEEK",
    Month: "MONTH",
    Year: "YEAR",
    Overall: "OVERALL",
  } as const;
/**
 * The billing cycle's unit of time
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionUot =
  OpenEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionUot
  >;

/**
 * How often services are billed
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionBillingPeriod =
  {
    /**
     * The billing cycle's duration
     */
    duration?: number | undefined;
    /**
     * The billing cycle's unit of time
     */
    uot?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionUot
      | undefined;
  };

/**
 * Billing day
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesBillingDay =
  {
    /**
     * Day of week
     */
    dayOfWeek?: string | undefined;
    /**
     * Day of month
     */
    dayOfMonth?: number | undefined;
    /**
     * Month of year
     */
    monthOfYear?: string | undefined;
  };

/**
 * Available payment method types
 */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesType =
  {
    Card: "CARD",
    AccountDebit: "ACCOUNT_DEBIT",
    Wallet: "WALLET",
    CrmWallet: "CRM_WALLET",
    Cash: "CASH",
    Cheque: "CHEQUE",
    ElectronicTransfer: "ELECTRONIC_TRANSFER",
  } as const;
/**
 * Available payment method types
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesType =
  OpenEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesType
  >;

/**
 * Payment method details
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesIdentity =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * A short description of the payment method. Depending on the payment method's type different information is returned:
     *
     * @remarks
     *
     *   -  Card: the brand, followed by the last 4 digits of the card plus expiration month/year
     *   -  Account debit: Name: Bank code followed by the first 5 and the last 9 digits of the account number/IBAN
     *   -  Wallet: Name: Email and/or phone used on registration
     */
    identifier?: string | undefined;
  };

/**
 * Payment method included in Get methods of Payments,Refunds and Payouts
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPaymentMethod =
  {
    /**
     * Available payment method types
     */
    type?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesType
      | undefined;
    /**
     * Payment method details
     */
    identity?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesIdentity
      | undefined;
  };

/**
 * Subscription's funding source
 *
 * @deprecated enum: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesFundingSource =
  {
    Account: "ACCOUNT",
    Wallet: "WALLET",
  } as const;
/**
 * Subscription's funding source
 *
 * @deprecated enum: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesFundingSource =
  OpenEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesFundingSource
  >;

/**
 * Subscription's billing model
 */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionBillingModel =
  {
    PostBill: "POST_BILL",
    PreBill: "PRE_BILL",
  } as const;
/**
 * Subscription's billing model
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionBillingModel =
  OpenEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionBillingModel
  >;

export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionTerms =
  {
    /**
     * How often services are billed
     */
    billingPeriod?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionBillingPeriod
      | undefined;
    /**
     * Billing day
     */
    billingDay?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesBillingDay
      | undefined;
    /**
     * Payment method included in Get methods of Payments,Refunds and Payouts
     */
    paymentMethod?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPaymentMethod
      | undefined;
    /**
     * Subscription's funding source
     *
     * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    fundingSource?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesFundingSource
      | undefined;
    /**
     * Subscription's billing model
     */
    billingModel?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionBillingModel
      | undefined;
  };

/**
 * The subscription's state
 */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionState =
  {
    Active: "ACTIVE",
    Inactive: "INACTIVE",
    Churned: "CHURNED",
  } as const;
/**
 * The subscription's state
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionState =
  OpenEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionState
  >;

/**
 * The subscription of the service
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscription =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * Subscription code
     */
    code?: string | undefined;
    terms?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionTerms
      | undefined;
    /**
     * The subscription's state
     */
    state?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionState
      | undefined;
  };

/**
 * The order related to the service
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContentOrder =
  {
    /**
     * the entity identifier
     */
    id?: string | undefined;
    /**
     * the entity number
     */
    number?: string | undefined;
  };

/**
 * Component service product
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentProduct =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The entity name
     */
    name?: string | undefined;
    /**
     * The entity sku
     */
    sku?: string | undefined;
  };

/**
 * Currency code based on ISO 4217 standard
 */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentCurrencyCode =
  {
    Aed: "AED",
    Afn: "AFN",
    All: "ALL",
    Amd: "AMD",
    Ang: "ANG",
    Aoa: "AOA",
    Ars: "ARS",
    Aud: "AUD",
    Awg: "AWG",
    Azn: "AZN",
    Bam: "BAM",
    Bbd: "BBD",
    Bdt: "BDT",
    Bgn: "BGN",
    Bhd: "BHD",
    Bif: "BIF",
    Bmd: "BMD",
    Bnd: "BND",
    Bob: "BOB",
    Brl: "BRL",
    Bsd: "BSD",
    Btn: "BTN",
    Bwp: "BWP",
    Byr: "BYR",
    Bzd: "BZD",
    Cad: "CAD",
    Cdf: "CDF",
    Chf: "CHF",
    Clp: "CLP",
    Cny: "CNY",
    Cop: "COP",
    Crc: "CRC",
    Cuc: "CUC",
    Cup: "CUP",
    Cve: "CVE",
    Czk: "CZK",
    Djf: "DJF",
    Dkk: "DKK",
    Dop: "DOP",
    Dzd: "DZD",
    Egp: "EGP",
    Ern: "ERN",
    Etb: "ETB",
    Eur: "EUR",
    Fjd: "FJD",
    Fkp: "FKP",
    Gbp: "GBP",
    Gel: "GEL",
    Ggp: "GGP",
    Ghs: "GHS",
    Gip: "GIP",
    Gmd: "GMD",
    Gnf: "GNF",
    Gtq: "GTQ",
    Gyd: "GYD",
    Hkd: "HKD",
    Hnl: "HNL",
    Hrk: "HRK",
    Htg: "HTG",
    Huf: "HUF",
    Idr: "IDR",
    Ils: "ILS",
    Imp: "IMP",
    Inr: "INR",
    Iqd: "IQD",
    Irr: "IRR",
    Isk: "ISK",
    Jep: "JEP",
    Jmd: "JMD",
    Jod: "JOD",
    Jpy: "JPY",
    Kes: "KES",
    Kgs: "KGS",
    Khr: "KHR",
    Kmf: "KMF",
    Kpw: "KPW",
    Krw: "KRW",
    Kwd: "KWD",
    Kyd: "KYD",
    Kzt: "KZT",
    Lak: "LAK",
    Lbp: "LBP",
    Lkr: "LKR",
    Lrd: "LRD",
    Lsl: "LSL",
    Lyd: "LYD",
    Mad: "MAD",
    Mdl: "MDL",
    Mga: "MGA",
    Mkd: "MKD",
    Mmk: "MMK",
    Mnt: "MNT",
    Mop: "MOP",
    Mro: "MRO",
    Mur: "MUR",
    Mvr: "MVR",
    Mwk: "MWK",
    Mxn: "MXN",
    Myr: "MYR",
    Mzn: "MZN",
    Nad: "NAD",
    Ngn: "NGN",
    Nio: "NIO",
    Nok: "NOK",
    Npr: "NPR",
    Nzd: "NZD",
    Omr: "OMR",
    Pab: "PAB",
    Pen: "PEN",
    Pgk: "PGK",
    Php: "PHP",
    Pkr: "PKR",
    Pln: "PLN",
    Pyg: "PYG",
    Qar: "QAR",
    Ron: "RON",
    Rsd: "RSD",
    Rub: "RUB",
    Rwf: "RWF",
    Sar: "SAR",
    Sbd: "SBD",
    Scr: "SCR",
    Sdg: "SDG",
    Sek: "SEK",
    Sgd: "SGD",
    Shp: "SHP",
    Sll: "SLL",
    Sos: "SOS",
    Spl: "SPL",
    Srd: "SRD",
    Std: "STD",
    Svc: "SVC",
    Syp: "SYP",
    Szl: "SZL",
    Thb: "THB",
    Tjs: "TJS",
    Tmt: "TMT",
    Tnd: "TND",
    Top: "TOP",
    Try: "TRY",
    Ttd: "TTD",
    Tvd: "TVD",
    Twd: "TWD",
    Tzs: "TZS",
    Uah: "UAH",
    Ugx: "UGX",
    Usd: "USD",
    Uyu: "UYU",
    Uzs: "UZS",
    Vef: "VEF",
    Vnd: "VND",
    Vuv: "VUV",
    Wst: "WST",
    Xaf: "XAF",
    Xcd: "XCD",
    Xdr: "XDR",
    Xof: "XOF",
    Xpf: "XPF",
    Yer: "YER",
    Zar: "ZAR",
    Zmw: "ZMW",
    Zwd: "ZWD",
    Pts: "PTS",
  } as const;
/**
 * Currency code based on ISO 4217 standard
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentCurrencyCode =
  OpenEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentCurrencyCode
  >;

/**
 * The component service's price
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentPrice =
  {
    /**
     * Component service price
     */
    price?: number | undefined;
    /**
     * Currency code based on ISO 4217 standard
     */
    currencyCode?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentCurrencyCode
      | undefined;
    /**
     * The label of the price
     */
    label?: string | undefined;
  };

/**
 * Component Service's State
 */
export const ComponentState = {
  Draft: "DRAFT",
  Effective: "EFFECTIVE",
  NotEffective: "NOT_EFFECTIVE",
  Paused: "PAUSED",
  Regretted: "REGRETTED",
  Cancelled: "CANCELLED",
  Swapped: "SWAPPED",
  Removed: "REMOVED",
} as const;
/**
 * Component Service's State
 */
export type ComponentState = OpenEnum<typeof ComponentState>;

export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponent =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * Component service added date
     */
    addedOn?: number | undefined;
    /**
     * Componenent service first activation date
     */
    firstActivatedOn?: number | undefined;
    /**
     * Component service product
     */
    product?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentProduct
      | undefined;
    /**
     * The component service's price
     */
    price?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentPrice
      | undefined;
    /**
     * Component Service's State
     */
    state?: ComponentState | undefined;
    /**
     * Component service in contract or not
     */
    inContract?: boolean | undefined;
    /**
     * Component Service quantity
     */
    quantity?: number | undefined;
    /**
     * Indicates whether the component will be billed once added to the subscription (if its price is not inclusive). When price is icnlusive, then the component's price/cost is included in the bundle's cost
     */
    priceInclusive?: boolean | undefined;
    /**
     * Shows whether the service allows subscribers to consume usage
     */
    hasAllowance?: boolean | undefined;
  };

export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesIntegration =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The entity name
     */
    name?: string | undefined;
  };

export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContent =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * Subscription Service's State
     */
    state?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesState
      | undefined;
    /**
     * Date added to the subscription
     */
    addedOn?: number | undefined;
    /**
     * First activation date
     */
    firstActivatedOn?: number | undefined;
    /**
     * Date removed from the subscription (applies for churned services)
     */
    removedOn?: number | undefined;
    /**
     * Applicable for expense services to indicate whether they are charged on a recurring basis
     */
    isRecurringCharge?: boolean | undefined;
    /**
     * Shows whether the service allows subscribers to consume usage
     */
    hasAllowance?: boolean | undefined;
    /**
     * Shows whether there are pending scheduled actions for the service
     */
    scheduledActions?: boolean | undefined;
    /**
     * Service product information
     */
    product?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesProduct
      | undefined;
    /**
     * Service pricing information
     */
    price?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPrice
      | undefined;
    /**
     * Latest billing information of the service
     */
    billing?: Billing | undefined;
    /**
     * Services's price terms
     */
    terms?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTerms
      | undefined;
    /**
     * Service's trial period details
     */
    trialPeriod?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTrialPeriod
      | undefined;
    /**
     * Applicable while the service is paused
     */
    pausedPeriod?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPausedPeriod
      | undefined;
    /**
     * Applicable when the service was added as part of a bundled service
     */
    bundledService?: BundledService | undefined;
    /**
     * Applicable when the service was added as part of a bundled device
     */
    bundledDevice?: BundledDevice | undefined;
    /**
     * The subscription of the service
     */
    subscription?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscription
      | undefined;
    /**
     * The date on which the service is scheduled to be added on the subscription
     */
    startDate?: number | undefined;
    /**
     * The order related to the service
     */
    order?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContentOrder
      | undefined;
    /**
     * Τhe most recent date on which the service was activated
     */
    lastActivatedOn?: number | undefined;
    /**
     * Τhe most recent date on which the service was deactivated (via a Deactivate service action that changed the service’s state to Not Effective)
     */
    lastDeactivatedOn?: number | undefined;
    /**
     * Applicable for bundle services and returns a list of component services
     */
    components?:
      | Array<
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponent
      >
      | undefined;
    /**
     * The integrations related to the service
     */
    integrations?:
      | Array<
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesIntegration
      >
      | undefined;
  };

/**
 * OK
 */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesResponse =
  {
    paging?:
      | ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPaging
      | undefined;
    content?:
      | Array<
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContent
      >
      | undefined;
  };

/** @internal */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSecurity$Outbound =
  {
    Secret_API_key: string;
  };

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSecurity$outboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSecurity$Outbound,
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSecurity
  > = z.pipe(
    z.object({
      secretAPIKey: z.string(),
    }),
    z.transform((v) => {
      return remap$(v, {
        secretAPIKey: "Secret_API_key",
      });
    }),
  );

export function comCrmSubscriptionSelfServiceResourceListSubscriptionServicesSecurityToJSON(
  comCrmSubscriptionSelfServiceResourceListSubscriptionServicesSecurity:
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSecurity,
): string {
  return JSON.stringify(
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSecurity$outboundSchema
      .parse(
        comCrmSubscriptionSelfServiceResourceListSubscriptionServicesSecurity,
      ),
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesQueryParamClassification$outboundSchema:
  z.ZodMiniEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesQueryParamClassification
  > = z.enum(
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesQueryParamClassification,
  );

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesOrderEnum$outboundSchema:
  z.ZodMiniEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesOrderEnum
  > = z.enum(
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesOrderEnum,
  );

/** @internal */
export type ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesRequest$Outbound =
  {
    id: string;
    classification?: string | undefined;
    include_future_info: boolean;
    include_order_info: boolean;
    include_subscription?: boolean | undefined;
    subscription_id?: string | undefined;
    include_total: boolean;
    order: string;
    page: number;
    size: number;
    sort: string;
  };

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesRequest$outboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesRequest$Outbound,
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesRequest
  > = z.pipe(
    z.object({
      id: z.string(),
      classification: z.optional(
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesQueryParamClassification$outboundSchema,
      ),
      includeFutureInfo: z._default(z.boolean(), false),
      includeOrderInfo: z._default(z.boolean(), false),
      includeSubscription: z.optional(z.boolean()),
      subscriptionId: z.optional(z.string()),
      includeTotal: z._default(z.boolean(), false),
      order: z._default(
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesOrderEnum$outboundSchema,
        "DESC",
      ),
      page: z._default(z.int(), 1),
      size: z._default(z.int(), 10),
      sort: z._default(z.string(), "CREATED_DATE"),
    }),
    z.transform((v) => {
      return remap$(v, {
        includeFutureInfo: "include_future_info",
        includeOrderInfo: "include_order_info",
        includeSubscription: "include_subscription",
        subscriptionId: "subscription_id",
        includeTotal: "include_total",
      });
    }),
  );

export function comCrmSubscriptionSelfServiceResourceListSubscriptionServicesRequestToJSON(
  comCrmSubscriptionSelfServiceResourceListSubscriptionServicesRequest:
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesRequest,
): string {
  return JSON.stringify(
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesRequest$outboundSchema
      .parse(
        comCrmSubscriptionSelfServiceResourceListSubscriptionServicesRequest,
      ),
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPaging$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPaging,
    unknown
  > = z.pipe(
    z.object({
      page: types.optional(types.number()),
      size: types.optional(types.number()),
      total: types.optional(types.number()),
      has_more: types.optional(types.boolean()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "has_more": "hasMore",
      });
    }),
  );

export function comCrmSubscriptionSelfServiceResourceListSubscriptionServicesPagingFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPaging,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPaging$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPaging' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesState$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesState,
    unknown
  > = openEnums.inboundSchema(
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesState,
  );

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContentClassification$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContentClassification,
    unknown
  > = openEnums.inboundSchema(
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContentClassification,
  );

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTypeComposition$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTypeComposition,
    unknown
  > = openEnums.inboundSchema(
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTypeComposition,
  );

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesInstanceModel$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesInstanceModel,
    unknown
  > = openEnums.inboundSchema(
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesInstanceModel,
  );

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesProduct$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesProduct,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      name: types.optional(types.string()),
      sku: types.optional(types.string()),
      classification: types.optional(
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContentClassification$inboundSchema,
      ),
      type_composition: types.optional(
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTypeComposition$inboundSchema,
      ),
      instance_model: types.optional(
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesInstanceModel$inboundSchema,
      ),
    }),
    z.transform((v) => {
      return remap$(v, {
        "type_composition": "typeComposition",
        "instance_model": "instanceModel",
      });
    }),
  );

export function comCrmSubscriptionSelfServiceResourceListSubscriptionServicesProductFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesProduct,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesProduct$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesProduct' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesCurrencyCode$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesCurrencyCode,
    unknown
  > = openEnums.inboundSchema(
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesCurrencyCode,
  );

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTaxModel$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTaxModel,
    unknown
  > = openEnums.inboundSchema(
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTaxModel,
  );

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPriceUot$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPriceUot,
    unknown
  > = openEnums.inboundSchema(
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPriceUot,
  );

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPriceBillingPeriod$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPriceBillingPeriod,
    unknown
  > = z.object({
    duration: types.optional(types.number()),
    uot: types.optional(
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPriceUot$inboundSchema,
    ),
  });

export function comCrmSubscriptionSelfServiceResourceListSubscriptionServicesPriceBillingPeriodFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPriceBillingPeriod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPriceBillingPeriod$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPriceBillingPeriod' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPrice$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPrice,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      price: types.optional(types.number()),
      currency_code: types.optional(
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesCurrencyCode$inboundSchema,
      ),
      tax_model: z._default(
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTaxModel$inboundSchema,
        "TAX_INCLUSIVE",
      ),
      billing_period: types.optional(z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPriceBillingPeriod$inboundSchema
      )),
      label: types.optional(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "currency_code": "currencyCode",
        "tax_model": "taxModel",
        "billing_period": "billingPeriod",
      });
    }),
  );

export function comCrmSubscriptionSelfServiceResourceListSubscriptionServicesPriceFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPrice,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPrice$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPrice' from JSON`,
  );
}

/** @internal */
export const Billing$inboundSchema: z.ZodMiniType<Billing, unknown> = z.pipe(
  z.object({
    billed_from: types.optional(types.number()),
    billed_to: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "billed_from": "billedFrom",
      "billed_to": "billedTo",
    });
  }),
);

export function billingFromJSON(
  jsonString: string,
): SafeParseResult<Billing, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Billing$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Billing' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesBillingModel$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesBillingModel,
    unknown
  > = openEnums.inboundSchema(
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesBillingModel,
  );

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContractPeriodUot$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContractPeriodUot,
    unknown
  > = openEnums.inboundSchema(
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContractPeriodUot,
  );

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContractPeriod$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContractPeriod,
    unknown
  > = z.pipe(
    z.object({
      duration: types.optional(types.number()),
      uot: types.optional(
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContractPeriodUot$inboundSchema,
      ),
      start_date: types.optional(types.number()),
      end_date: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "start_date": "startDate",
        "end_date": "endDate",
      });
    }),
  );

export function comCrmSubscriptionSelfServiceResourceListSubscriptionServicesContractPeriodFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContractPeriod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContractPeriod$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContractPeriod' from JSON`,
  );
}

/** @internal */
export const TermedPeriod$inboundSchema: z.ZodMiniType<TermedPeriod, unknown> =
  z.pipe(
    z.object({
      billing_cycles: types.optional(types.number()),
      start_date: types.optional(types.number()),
      end_date: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "billing_cycles": "billingCycles",
        "start_date": "startDate",
        "end_date": "endDate",
      });
    }),
  );

export function termedPeriodFromJSON(
  jsonString: string,
): SafeParseResult<TermedPeriod, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TermedPeriod$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TermedPeriod' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesAccessPeriod$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesAccessPeriod,
    unknown
  > = z.pipe(
    z.object({
      start_date: types.optional(types.number()),
      end_date: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "start_date": "startDate",
        "end_date": "endDate",
      });
    }),
  );

export function comCrmSubscriptionSelfServiceResourceListSubscriptionServicesAccessPeriodFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesAccessPeriod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesAccessPeriod$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesAccessPeriod' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTerms$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTerms,
    unknown
  > = z.pipe(
    z.object({
      billing_model: types.optional(
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesBillingModel$inboundSchema,
      ),
      auto_renew: types.optional(types.boolean()),
      in_contract: types.optional(types.boolean()),
      contract_period: types.optional(z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContractPeriod$inboundSchema
      )),
      termed_period: types.optional(z.lazy(() =>
        TermedPeriod$inboundSchema
      )),
      quantity: types.optional(types.number()),
      access_period: types.optional(z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesAccessPeriod$inboundSchema
      )),
    }),
    z.transform((v) => {
      return remap$(v, {
        "billing_model": "billingModel",
        "auto_renew": "autoRenew",
        "in_contract": "inContract",
        "contract_period": "contractPeriod",
        "termed_period": "termedPeriod",
        "access_period": "accessPeriod",
      });
    }),
  );

export function comCrmSubscriptionSelfServiceResourceListSubscriptionServicesTermsFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTerms,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTerms$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTerms' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTrialPeriodUot$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTrialPeriodUot,
    unknown
  > = openEnums.inboundSchema(
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTrialPeriodUot,
  );

/** @internal */
export const TrialState$inboundSchema: z.ZodMiniType<TrialState, unknown> =
  openEnums.inboundSchema(TrialState);

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTrialPeriod$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTrialPeriod,
    unknown
  > = z.pipe(
    z.object({
      start_date: types.optional(types.number()),
      end_date: types.optional(types.number()),
      duration: types.optional(types.number()),
      uot: types.optional(
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTrialPeriodUot$inboundSchema,
      ),
      trial_state: types.optional(TrialState$inboundSchema),
    }),
    z.transform((v) => {
      return remap$(v, {
        "start_date": "startDate",
        "end_date": "endDate",
        "trial_state": "trialState",
      });
    }),
  );

export function comCrmSubscriptionSelfServiceResourceListSubscriptionServicesTrialPeriodFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTrialPeriod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTrialPeriod$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTrialPeriod' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPausedPeriod$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPausedPeriod,
    unknown
  > = z.pipe(
    z.object({
      start_date: types.optional(types.number()),
      end_date: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "start_date": "startDate",
        "end_date": "endDate",
      });
    }),
  );

export function comCrmSubscriptionSelfServiceResourceListSubscriptionServicesPausedPeriodFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPausedPeriod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPausedPeriod$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPausedPeriod' from JSON`,
  );
}

/** @internal */
export const BundledServiceProduct$inboundSchema: z.ZodMiniType<
  BundledServiceProduct,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
  sku: types.optional(types.string()),
});

export function bundledServiceProductFromJSON(
  jsonString: string,
): SafeParseResult<BundledServiceProduct, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BundledServiceProduct$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BundledServiceProduct' from JSON`,
  );
}

/** @internal */
export const BundledService$inboundSchema: z.ZodMiniType<
  BundledService,
  unknown
> = z.object({
  id: types.optional(types.string()),
  product: types.optional(z.lazy(() => BundledServiceProduct$inboundSchema)),
});

export function bundledServiceFromJSON(
  jsonString: string,
): SafeParseResult<BundledService, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BundledService$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BundledService' from JSON`,
  );
}

/** @internal */
export const BundledDeviceProduct$inboundSchema: z.ZodMiniType<
  BundledDeviceProduct,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
  sku: types.optional(types.string()),
});

export function bundledDeviceProductFromJSON(
  jsonString: string,
): SafeParseResult<BundledDeviceProduct, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BundledDeviceProduct$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BundledDeviceProduct' from JSON`,
  );
}

/** @internal */
export const BundledDevice$inboundSchema: z.ZodMiniType<
  BundledDevice,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    serial_number: types.optional(types.string()),
    product: types.optional(z.lazy(() => BundledDeviceProduct$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "serial_number": "serialNumber",
    });
  }),
);

export function bundledDeviceFromJSON(
  jsonString: string,
): SafeParseResult<BundledDevice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BundledDevice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BundledDevice' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionUot$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionUot,
    unknown
  > = openEnums.inboundSchema(
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionUot,
  );

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionBillingPeriod$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionBillingPeriod,
    unknown
  > = z.object({
    duration: types.optional(types.number()),
    uot: types.optional(
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionUot$inboundSchema,
    ),
  });

export function comCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionBillingPeriodFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionBillingPeriod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionBillingPeriod$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionBillingPeriod' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesBillingDay$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesBillingDay,
    unknown
  > = z.pipe(
    z.object({
      day_of_week: types.optional(types.string()),
      day_of_month: types.optional(types.number()),
      month_of_year: types.optional(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "day_of_week": "dayOfWeek",
        "day_of_month": "dayOfMonth",
        "month_of_year": "monthOfYear",
      });
    }),
  );

export function comCrmSubscriptionSelfServiceResourceListSubscriptionServicesBillingDayFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesBillingDay,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesBillingDay$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesBillingDay' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesType$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesType,
    unknown
  > = openEnums.inboundSchema(
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesType,
  );

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesIdentity$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesIdentity,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    identifier: types.optional(types.string()),
  });

export function comCrmSubscriptionSelfServiceResourceListSubscriptionServicesIdentityFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesIdentity,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesIdentity$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesIdentity' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPaymentMethod$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPaymentMethod,
    unknown
  > = z.object({
    type: types.optional(
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesType$inboundSchema,
    ),
    identity: types.optional(
      z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesIdentity$inboundSchema
      ),
    ),
  });

export function comCrmSubscriptionSelfServiceResourceListSubscriptionServicesPaymentMethodFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPaymentMethod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPaymentMethod$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPaymentMethod' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesFundingSource$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesFundingSource,
    unknown
  > = openEnums.inboundSchema(
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesFundingSource,
  );

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionBillingModel$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionBillingModel,
    unknown
  > = openEnums.inboundSchema(
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionBillingModel,
  );

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionTerms$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionTerms,
    unknown
  > = z.pipe(
    z.object({
      billing_period: types.optional(z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionBillingPeriod$inboundSchema
      )),
      billing_day: types.optional(z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesBillingDay$inboundSchema
      )),
      payment_method: types.optional(z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPaymentMethod$inboundSchema
      )),
      funding_source: types.optional(
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesFundingSource$inboundSchema,
      ),
      billing_model: types.optional(
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionBillingModel$inboundSchema,
      ),
    }),
    z.transform((v) => {
      return remap$(v, {
        "billing_period": "billingPeriod",
        "billing_day": "billingDay",
        "payment_method": "paymentMethod",
        "funding_source": "fundingSource",
        "billing_model": "billingModel",
      });
    }),
  );

export function comCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionTermsFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionTerms,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionTerms$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionTerms' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionState$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionState,
    unknown
  > = openEnums.inboundSchema(
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionState,
  );

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscription$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscription,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    code: types.optional(types.string()),
    terms: types.optional(
      z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionTerms$inboundSchema
      ),
    ),
    state: types.optional(
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionState$inboundSchema,
    ),
  });

export function comCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscriptionFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscription,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscription$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscription' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContentOrder$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContentOrder,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    number: types.optional(types.string()),
  });

export function comCrmSubscriptionSelfServiceResourceListSubscriptionServicesContentOrderFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContentOrder,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContentOrder$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContentOrder' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentProduct$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentProduct,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    sku: types.optional(types.string()),
  });

export function comCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentProductFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentProduct,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentProduct$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentProduct' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentCurrencyCode$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentCurrencyCode,
    unknown
  > = openEnums.inboundSchema(
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentCurrencyCode,
  );

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentPrice$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentPrice,
    unknown
  > = z.pipe(
    z.object({
      price: types.optional(types.number()),
      currency_code: types.optional(
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentCurrencyCode$inboundSchema,
      ),
      label: types.optional(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "currency_code": "currencyCode",
      });
    }),
  );

export function comCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentPriceFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentPrice,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentPrice$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentPrice' from JSON`,
  );
}

/** @internal */
export const ComponentState$inboundSchema: z.ZodMiniType<
  ComponentState,
  unknown
> = openEnums.inboundSchema(ComponentState);

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponent$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponent,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      added_on: types.optional(types.number()),
      first_activated_on: types.optional(types.number()),
      product: types.optional(z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentProduct$inboundSchema
      )),
      price: types.optional(z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentPrice$inboundSchema
      )),
      state: types.optional(ComponentState$inboundSchema),
      in_contract: types.optional(types.boolean()),
      quantity: types.optional(types.number()),
      price_inclusive: types.optional(types.boolean()),
      has_allowance: types.optional(types.boolean()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "added_on": "addedOn",
        "first_activated_on": "firstActivatedOn",
        "in_contract": "inContract",
        "price_inclusive": "priceInclusive",
        "has_allowance": "hasAllowance",
      });
    }),
  );

export function comCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponentFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponent$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponent' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesIntegration$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesIntegration,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
  });

export function comCrmSubscriptionSelfServiceResourceListSubscriptionServicesIntegrationFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesIntegration,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesIntegration$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesIntegration' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContent$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContent,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      state: types.optional(
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesState$inboundSchema,
      ),
      added_on: types.optional(types.number()),
      first_activated_on: types.optional(types.number()),
      removed_on: types.optional(types.number()),
      is_recurring_charge: types.optional(types.boolean()),
      has_allowance: types.optional(types.boolean()),
      scheduled_actions: types.optional(types.boolean()),
      product: types.optional(z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesProduct$inboundSchema
      )),
      price: types.optional(z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPrice$inboundSchema
      )),
      billing: types.optional(z.lazy(() =>
        Billing$inboundSchema
      )),
      terms: types.optional(z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTerms$inboundSchema
      )),
      trial_period: types.optional(z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesTrialPeriod$inboundSchema
      )),
      paused_period: types.optional(z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPausedPeriod$inboundSchema
      )),
      bundled_service: types.optional(z.lazy(() =>
        BundledService$inboundSchema
      )),
      bundled_device: types.optional(z.lazy(() =>
        BundledDevice$inboundSchema
      )),
      subscription: types.optional(z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesSubscription$inboundSchema
      )),
      start_date: types.optional(types.number()),
      order: types.optional(z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContentOrder$inboundSchema
      )),
      last_activated_on: types.optional(types.number()),
      last_deactivated_on: types.optional(types.number()),
      components: types.optional(z.array(z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesComponent$inboundSchema
      ))),
      integrations: types.optional(z.array(z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesIntegration$inboundSchema
      ))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "added_on": "addedOn",
        "first_activated_on": "firstActivatedOn",
        "removed_on": "removedOn",
        "is_recurring_charge": "isRecurringCharge",
        "has_allowance": "hasAllowance",
        "scheduled_actions": "scheduledActions",
        "trial_period": "trialPeriod",
        "paused_period": "pausedPeriod",
        "bundled_service": "bundledService",
        "bundled_device": "bundledDevice",
        "start_date": "startDate",
        "last_activated_on": "lastActivatedOn",
        "last_deactivated_on": "lastDeactivatedOn",
      });
    }),
  );

export function comCrmSubscriptionSelfServiceResourceListSubscriptionServicesContentFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContent$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContent' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesResponse$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesResponse,
    unknown
  > = z.object({
    paging: types.optional(
      z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesPaging$inboundSchema
      ),
    ),
    content: types.optional(
      z.array(z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesContent$inboundSchema
      )),
    ),
  });

export function comCrmSubscriptionSelfServiceResourceListSubscriptionServicesResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesResponse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListSubscriptionServicesResponse' from JSON`,
  );
}
