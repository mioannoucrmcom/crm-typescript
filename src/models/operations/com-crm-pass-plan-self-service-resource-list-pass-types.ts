/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 * @generated-id: f9c1dfd0b016
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

/**
 * Defines how the results will be ordered
 */
export const ComCrmPassPlanSelfServiceResourceListPassTypesOrder = {
  Asc: "ASC",
  Desc: "DESC",
} as const;
/**
 * Defines how the results will be ordered
 */
export type ComCrmPassPlanSelfServiceResourceListPassTypesOrder = ClosedEnum<
  typeof ComCrmPassPlanSelfServiceResourceListPassTypesOrder
>;

export type ComCrmPassPlanSelfServiceResourceListPassTypesRequest = {
  /**
   * The pass plan's currency code.
   */
  currencyCode?: string | undefined;
  /**
   * Search pass plans based on their related product
   */
  productId?: string | undefined;
  /**
   * Search for pass plans using the pass plan name
   */
  searchValue?: string | undefined;
  /**
   * Determine if a "total" will be returned in paging reference. If set to True, then "total" is also returned but it will return up to 10K value. If set to False, then the "total" in paging is null.
   */
  includeTotal?: boolean | undefined;
  /**
   * Defines how the results will be ordered
   */
  order?: ComCrmPassPlanSelfServiceResourceListPassTypesOrder | undefined;
  /**
   * The page number that should be retrieved
   */
  page?: number | undefined;
  /**
   * The size (total records) of each page
   */
  size?: number | undefined;
  /**
   * Defines on which attribute the results should be sorted
   */
  sort?: string | undefined;
};

export type ComCrmPassPlanSelfServiceResourceListPassTypesPaging = {
  /**
   * The page number
   */
  page?: number | undefined;
  /**
   * The number of records per page
   */
  size?: number | undefined;
  /**
   * The total number of records. If "include_total" is not specified, then this total is null. If "include_total" is specified, total has a value but it is accurate up to 10K records.
   */
  total?: number | undefined;
  /**
   * Shows if there are more records available to fetch
   */
  hasMore?: boolean | undefined;
};

/**
 * Valid states of a pass plan
 */
export const ComCrmPassPlanSelfServiceResourceListPassTypesState = {
  Active: "ACTIVE",
  Inactive: "INACTIVE",
} as const;
/**
 * Valid states of a pass plan
 */
export type ComCrmPassPlanSelfServiceResourceListPassTypesState = OpenEnum<
  typeof ComCrmPassPlanSelfServiceResourceListPassTypesState
>;

/**
 * The classification of the pass type
 */
export const ComCrmPassPlanSelfServiceResourceListPassTypesClassification = {
  Gift: "GIFT",
  Topup: "TOPUP",
  Promotion: "PROMOTION",
} as const;
/**
 * The classification of the pass type
 */
export type ComCrmPassPlanSelfServiceResourceListPassTypesClassification =
  OpenEnum<typeof ComCrmPassPlanSelfServiceResourceListPassTypesClassification>;

/**
 * The type of pass codes to be generated by the pass plan
 */
export const PassCodeType = {
  Single: "SINGLE",
  Multiple: "MULTIPLE",
} as const;
/**
 * The type of pass codes to be generated by the pass plan
 */
export type PassCodeType = OpenEnum<typeof PassCodeType>;

/**
 * These attributes are applicable only if the pass plan classification is PROMOTION
 */
export type PromotionPasses = {
  /**
   * The id of the promotion that the pass will consume, either promotion_id OR reward_offer_id must be specified
   */
  promotionId: string;
  /**
   * The id of the reward offer that the pass will consume, either promotion_id OR reward_offer_id must be specified
   */
  rewardOfferId: string;
  /**
   * Promotion name or reward offer name (depending on promotion_id or reward_offer_id received)
   */
  name?: string | undefined;
  /**
   * The type of pass codes to be generated by the pass plan
   */
  passCodeType?: PassCodeType | undefined;
  /**
   * The maximum number of times the pass can be used, 1 = single use pass >1 = multiple uses
   */
  maximumUsage?: number | undefined;
};

/**
 * The validity type
 */
export const ValidityType = {
  Period: "PERIOD",
  Date: "DATE",
  Always: "ALWAYS",
} as const;
/**
 * The validity type
 */
export type ValidityType = OpenEnum<typeof ValidityType>;

/**
 * The period unit of time, applicable only if validity type is PERIOD. Used in conjunction with 'period' to set the validity period.
 */
export const ComCrmPassPlanSelfServiceResourceListPassTypesUot = {
  Days: "DAYS",
  Months: "MONTHS",
  Years: "YEARS",
} as const;
/**
 * The period unit of time, applicable only if validity type is PERIOD. Used in conjunction with 'period' to set the validity period.
 */
export type ComCrmPassPlanSelfServiceResourceListPassTypesUot = OpenEnum<
  typeof ComCrmPassPlanSelfServiceResourceListPassTypesUot
>;

/**
 * Pass plan validity setting - this relates to the date whereby the pass can be redeemed until (not to be confused with the expiration of the pass value)
 */
export type Validity = {
  /**
   * The validity type
   */
  type?: ValidityType | undefined;
  /**
   * The validity period value, applicable only if validity type is PERIOD (e.g. expires in X days/months/years). Used in conjunction with 'uot' to set the validity period.
   */
  period?: number | undefined;
  /**
   * The period unit of time, applicable only if validity type is PERIOD. Used in conjunction with 'period' to set the validity period.
   */
  uot?: ComCrmPassPlanSelfServiceResourceListPassTypesUot | undefined;
  /**
   * The fixed date by which passes can be redeemed, applicable only if validity type is DATE
   */
  fixedDate?: number | undefined;
};

/**
 * Will passes have a fixed or variable value? FIXED indicates that the pass value is predefined, VARIABLE allows the value of the pass to be set during creation (within a range of values)
 */
export const ValueType = {
  Fixed: "FIXED",
  Variable: "VARIABLE",
} as const;
/**
 * Will passes have a fixed or variable value? FIXED indicates that the pass value is predefined, VARIABLE allows the value of the pass to be set during creation (within a range of values)
 */
export type ValueType = OpenEnum<typeof ValueType>;

/**
 * The base currency code of the system
 */
export const ValueCurrencyCode = {
  Aed: "AED",
  Afn: "AFN",
  All: "ALL",
  Amd: "AMD",
  Ang: "ANG",
  Aoa: "AOA",
  Ars: "ARS",
  Aud: "AUD",
  Awg: "AWG",
  Azn: "AZN",
  Bam: "BAM",
  Bbd: "BBD",
  Bdt: "BDT",
  Bgn: "BGN",
  Bhd: "BHD",
  Bif: "BIF",
  Bmd: "BMD",
  Bnd: "BND",
  Bob: "BOB",
  Brl: "BRL",
  Bsd: "BSD",
  Btn: "BTN",
  Bwp: "BWP",
  Byr: "BYR",
  Bzd: "BZD",
  Cad: "CAD",
  Cdf: "CDF",
  Chf: "CHF",
  Clp: "CLP",
  Cny: "CNY",
  Cop: "COP",
  Crc: "CRC",
  Cuc: "CUC",
  Cup: "CUP",
  Cve: "CVE",
  Czk: "CZK",
  Djf: "DJF",
  Dkk: "DKK",
  Dop: "DOP",
  Dzd: "DZD",
  Egp: "EGP",
  Ern: "ERN",
  Etb: "ETB",
  Eur: "EUR",
  Fjd: "FJD",
  Fkp: "FKP",
  Gbp: "GBP",
  Gel: "GEL",
  Ggp: "GGP",
  Ghs: "GHS",
  Gip: "GIP",
  Gmd: "GMD",
  Gnf: "GNF",
  Gtq: "GTQ",
  Gyd: "GYD",
  Hkd: "HKD",
  Hnl: "HNL",
  Hrk: "HRK",
  Htg: "HTG",
  Huf: "HUF",
  Idr: "IDR",
  Ils: "ILS",
  Imp: "IMP",
  Inr: "INR",
  Iqd: "IQD",
  Irr: "IRR",
  Isk: "ISK",
  Jep: "JEP",
  Jmd: "JMD",
  Jod: "JOD",
  Jpy: "JPY",
  Kes: "KES",
  Kgs: "KGS",
  Khr: "KHR",
  Kmf: "KMF",
  Kpw: "KPW",
  Krw: "KRW",
  Kwd: "KWD",
  Kyd: "KYD",
  Kzt: "KZT",
  Lak: "LAK",
  Lbp: "LBP",
  Lkr: "LKR",
  Lrd: "LRD",
  Lsl: "LSL",
  Lyd: "LYD",
  Mad: "MAD",
  Mdl: "MDL",
  Mga: "MGA",
  Mkd: "MKD",
  Mmk: "MMK",
  Mnt: "MNT",
  Mop: "MOP",
  Mro: "MRO",
  Mur: "MUR",
  Mvr: "MVR",
  Mwk: "MWK",
  Mxn: "MXN",
  Myr: "MYR",
  Mzn: "MZN",
  Nad: "NAD",
  Ngn: "NGN",
  Nio: "NIO",
  Nok: "NOK",
  Npr: "NPR",
  Nzd: "NZD",
  Omr: "OMR",
  Pab: "PAB",
  Pen: "PEN",
  Pgk: "PGK",
  Php: "PHP",
  Pkr: "PKR",
  Pln: "PLN",
  Pyg: "PYG",
  Qar: "QAR",
  Ron: "RON",
  Rsd: "RSD",
  Rub: "RUB",
  Rwf: "RWF",
  Sar: "SAR",
  Sbd: "SBD",
  Scr: "SCR",
  Sdg: "SDG",
  Sek: "SEK",
  Sgd: "SGD",
  Shp: "SHP",
  Sll: "SLL",
  Sos: "SOS",
  Spl: "SPL",
  Srd: "SRD",
  Std: "STD",
  Svc: "SVC",
  Syp: "SYP",
  Szl: "SZL",
  Thb: "THB",
  Tjs: "TJS",
  Tmt: "TMT",
  Tnd: "TND",
  Top: "TOP",
  Try: "TRY",
  Ttd: "TTD",
  Tvd: "TVD",
  Twd: "TWD",
  Tzs: "TZS",
  Uah: "UAH",
  Ugx: "UGX",
  Usd: "USD",
  Uyu: "UYU",
  Uzs: "UZS",
  Vef: "VEF",
  Vnd: "VND",
  Vuv: "VUV",
  Wst: "WST",
  Xaf: "XAF",
  Xcd: "XCD",
  Xdr: "XDR",
  Xof: "XOF",
  Xpf: "XPF",
  Yer: "YER",
  Zar: "ZAR",
  Zmw: "ZMW",
  Zwd: "ZWD",
  Pts: "PTS",
} as const;
/**
 * The base currency code of the system
 */
export type ValueCurrencyCode = OpenEnum<typeof ValueCurrencyCode>;

/**
 * The pass plan value information, applicable only for pass plans with classification of GIFT or TOP_UP
 */
export type Value = {
  /**
   * Will passes have a fixed or variable value? FIXED indicates that the pass value is predefined, VARIABLE allows the value of the pass to be set during creation (within a range of values)
   */
  type?: ValueType | undefined;
  /**
   * The fixed pass value amount (in the base currency of the system), applicable only if value type is FIXED
   */
  fixedAmount?: number | undefined;
  /**
   * The minimum allowed value of the pass, applicable only if value type is VARIABLE. Used in conjunction with 'maximum'
   */
  minimum?: number | undefined;
  /**
   * The maximum allowed value of the pass, applicable only if value type is VARIABLE. Used in conjunction with 'minimum'
   */
  maximum?: number | undefined;
  /**
   * The base currency code of the system
   */
  currencyCode?: ValueCurrencyCode | undefined;
};

/**
 * The pass code type to be used
 */
export const CodeFormatType = {
  Alphanumeric: "ALPHANUMERIC",
  Alphabetic: "ALPHABETIC",
  Numeric: "NUMERIC",
} as const;
/**
 * The pass code type to be used
 */
export type CodeFormatType = OpenEnum<typeof CodeFormatType>;

/**
 * Details of the pass code format to be followed when a pass code is created. All the following are applicable for GIFT & TOP_UP pass plans, or PROMOTION pass plans with a pass_code_type of MULTIPLE, unless otherwise stated
 */
export type ComCrmPassPlanSelfServiceResourceListPassTypesCodeFormat = {
  /**
   * The pass code type to be used
   */
  type: CodeFormatType;
  /**
   * Optional pass code prefix (appears at the beginning of the pass code)
   */
  prefix?: string | undefined;
  /**
   * Optional pass code suffix (appears at the end of the pass code)
   */
  suffix?: string | undefined;
  /**
   * Pass code length (min.7, max.16), not inlcuding prefix and suffix
   */
  length?: number | undefined;
  /**
   * Defines whether the passes will be associated with a pin (not for PROMOTION type pass plans)
   */
  pinRequired: boolean;
  /**
   * The single pass code to be used for all passes. Applicable only for PROMOTION type pass plans with pass_code_type = SINGLE
   */
  singleCode?: string | undefined;
};

/**
 * The wallet balance to be credited when the pass is redeemed. For TOP_UP and GIFT passes only
 */
export const CreditWalletBalance = {
  Open: "OPEN",
  Commerce: "COMMERCE",
} as const;
/**
 * The wallet balance to be credited when the pass is redeemed. For TOP_UP and GIFT passes only
 */
export type CreditWalletBalance = OpenEnum<typeof CreditWalletBalance>;

/**
 * Details about commerce pool
 */
export type ComCrmPassPlanSelfServiceResourceListPassTypesCommercePool = {
  /**
   * The commerce pool identifier
   */
  id?: string | undefined;
  /**
   * The commerce pool name
   */
  name?: string | undefined;
  /**
   * The commerce pool description
   */
  description?: string | undefined;
};

/**
 * A list of custom fields whose values can be set when creating or updating entities
 */
export type ComCrmPassPlanSelfServiceResourceListPassTypesCustomField = {
  /**
   * The custom field’s unique key
   */
  key?: string | undefined;
  /**
   * The custom field’s value
   */
  value?: string | undefined;
};

/**
 * Currency code based on ISO 4217 standard
 */
export const ComCrmPassPlanSelfServiceResourceListPassTypesCurrencyCode = {
  Aed: "AED",
  Afn: "AFN",
  All: "ALL",
  Amd: "AMD",
  Ang: "ANG",
  Aoa: "AOA",
  Ars: "ARS",
  Aud: "AUD",
  Awg: "AWG",
  Azn: "AZN",
  Bam: "BAM",
  Bbd: "BBD",
  Bdt: "BDT",
  Bgn: "BGN",
  Bhd: "BHD",
  Bif: "BIF",
  Bmd: "BMD",
  Bnd: "BND",
  Bob: "BOB",
  Brl: "BRL",
  Bsd: "BSD",
  Btn: "BTN",
  Bwp: "BWP",
  Byr: "BYR",
  Bzd: "BZD",
  Cad: "CAD",
  Cdf: "CDF",
  Chf: "CHF",
  Clp: "CLP",
  Cny: "CNY",
  Cop: "COP",
  Crc: "CRC",
  Cuc: "CUC",
  Cup: "CUP",
  Cve: "CVE",
  Czk: "CZK",
  Djf: "DJF",
  Dkk: "DKK",
  Dop: "DOP",
  Dzd: "DZD",
  Egp: "EGP",
  Ern: "ERN",
  Etb: "ETB",
  Eur: "EUR",
  Fjd: "FJD",
  Fkp: "FKP",
  Gbp: "GBP",
  Gel: "GEL",
  Ggp: "GGP",
  Ghs: "GHS",
  Gip: "GIP",
  Gmd: "GMD",
  Gnf: "GNF",
  Gtq: "GTQ",
  Gyd: "GYD",
  Hkd: "HKD",
  Hnl: "HNL",
  Hrk: "HRK",
  Htg: "HTG",
  Huf: "HUF",
  Idr: "IDR",
  Ils: "ILS",
  Imp: "IMP",
  Inr: "INR",
  Iqd: "IQD",
  Irr: "IRR",
  Isk: "ISK",
  Jep: "JEP",
  Jmd: "JMD",
  Jod: "JOD",
  Jpy: "JPY",
  Kes: "KES",
  Kgs: "KGS",
  Khr: "KHR",
  Kmf: "KMF",
  Kpw: "KPW",
  Krw: "KRW",
  Kwd: "KWD",
  Kyd: "KYD",
  Kzt: "KZT",
  Lak: "LAK",
  Lbp: "LBP",
  Lkr: "LKR",
  Lrd: "LRD",
  Lsl: "LSL",
  Lyd: "LYD",
  Mad: "MAD",
  Mdl: "MDL",
  Mga: "MGA",
  Mkd: "MKD",
  Mmk: "MMK",
  Mnt: "MNT",
  Mop: "MOP",
  Mro: "MRO",
  Mur: "MUR",
  Mvr: "MVR",
  Mwk: "MWK",
  Mxn: "MXN",
  Myr: "MYR",
  Mzn: "MZN",
  Nad: "NAD",
  Ngn: "NGN",
  Nio: "NIO",
  Nok: "NOK",
  Npr: "NPR",
  Nzd: "NZD",
  Omr: "OMR",
  Pab: "PAB",
  Pen: "PEN",
  Pgk: "PGK",
  Php: "PHP",
  Pkr: "PKR",
  Pln: "PLN",
  Pyg: "PYG",
  Qar: "QAR",
  Ron: "RON",
  Rsd: "RSD",
  Rub: "RUB",
  Rwf: "RWF",
  Sar: "SAR",
  Sbd: "SBD",
  Scr: "SCR",
  Sdg: "SDG",
  Sek: "SEK",
  Sgd: "SGD",
  Shp: "SHP",
  Sll: "SLL",
  Sos: "SOS",
  Spl: "SPL",
  Srd: "SRD",
  Std: "STD",
  Svc: "SVC",
  Syp: "SYP",
  Szl: "SZL",
  Thb: "THB",
  Tjs: "TJS",
  Tmt: "TMT",
  Tnd: "TND",
  Top: "TOP",
  Try: "TRY",
  Ttd: "TTD",
  Tvd: "TVD",
  Twd: "TWD",
  Tzs: "TZS",
  Uah: "UAH",
  Ugx: "UGX",
  Usd: "USD",
  Uyu: "UYU",
  Uzs: "UZS",
  Vef: "VEF",
  Vnd: "VND",
  Vuv: "VUV",
  Wst: "WST",
  Xaf: "XAF",
  Xcd: "XCD",
  Xdr: "XDR",
  Xof: "XOF",
  Xpf: "XPF",
  Yer: "YER",
  Zar: "ZAR",
  Zmw: "ZMW",
  Zwd: "ZWD",
  Pts: "PTS",
} as const;
/**
 * Currency code based on ISO 4217 standard
 */
export type ComCrmPassPlanSelfServiceResourceListPassTypesCurrencyCode =
  OpenEnum<typeof ComCrmPassPlanSelfServiceResourceListPassTypesCurrencyCode>;

/**
 * The product related to the Pass Plan. Applicable only for Electronic Gift pass plans, but optional. If specified, then electronic gift passes will be available for contacts to be purchased in a front-end system. Only flat, non-traceable physical goods can be specified.
 */
export type ComCrmPassPlanSelfServiceResourceListPassTypesProduct = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
  /**
   * The entity sku
   */
  sku?: string | undefined;
};

export type ComCrmPassPlanSelfServiceResourceListPassTypesContent = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * Valid states of a pass plan
   */
  state?: ComCrmPassPlanSelfServiceResourceListPassTypesState | undefined;
  /**
   * The name of the pass type
   */
  name?: string | undefined;
  /**
   * The description of the pass type
   */
  description?: string | undefined;
  /**
   * The classification of the pass type
   */
  classification?:
    | ComCrmPassPlanSelfServiceResourceListPassTypesClassification
    | undefined;
  /**
   * These attributes are applicable only if the pass plan classification is PROMOTION
   */
  promotionPasses?: PromotionPasses | undefined;
  /**
   * Pass plan validity setting - this relates to the date whereby the pass can be redeemed until (not to be confused with the expiration of the pass value)
   */
  validity?: Validity | undefined;
  /**
   * The pass plan value information, applicable only for pass plans with classification of GIFT or TOP_UP
   */
  value?: Value | undefined;
  /**
   * Defines whether the passes will be printed. true = printed, false = electronic
   */
  printed?: boolean | undefined;
  /**
   * Details of the pass code format to be followed when a pass code is created. All the following are applicable for GIFT & TOP_UP pass plans, or PROMOTION pass plans with a pass_code_type of MULTIPLE, unless otherwise stated
   */
  codeFormat?:
    | ComCrmPassPlanSelfServiceResourceListPassTypesCodeFormat
    | undefined;
  /**
   * The wallet balance to be credited when the pass is redeemed. For TOP_UP and GIFT passes only
   */
  creditWalletBalance?: CreditWalletBalance | undefined;
  /**
   * Details about commerce pool
   */
  commercePool?:
    | ComCrmPassPlanSelfServiceResourceListPassTypesCommercePool
    | undefined;
  /**
   * For printed passes - this is the number of passes to create, for electronic passes - this is the maximum number of passes to be created
   */
  numberOfPasses?: number | undefined;
  /**
   * Number of passes generated (for printed - this is the number of printed passes, for electronic - this is the number of passes generated so far)
   */
  passesGenerated?: number | undefined;
  /**
   * Includes a list of custom fields whose values can be set on creating or updating entities
   */
  customFields?:
    | Array<ComCrmPassPlanSelfServiceResourceListPassTypesCustomField>
    | undefined;
  /**
   * Currency code based on ISO 4217 standard
   */
  currencyCode: ComCrmPassPlanSelfServiceResourceListPassTypesCurrencyCode;
  /**
   * The product related to the Pass Plan. Applicable only for Electronic Gift pass plans, but optional. If specified, then electronic gift passes will be available for contacts to be purchased in a front-end system. Only flat, non-traceable physical goods can be specified.
   */
  product?: ComCrmPassPlanSelfServiceResourceListPassTypesProduct | undefined;
};

/**
 * OK
 */
export type ComCrmPassPlanSelfServiceResourceListPassTypesResponse = {
  paging?: ComCrmPassPlanSelfServiceResourceListPassTypesPaging | undefined;
  content?:
    | Array<ComCrmPassPlanSelfServiceResourceListPassTypesContent>
    | undefined;
};

/** @internal */
export const ComCrmPassPlanSelfServiceResourceListPassTypesOrder$outboundSchema:
  z.ZodMiniEnum<typeof ComCrmPassPlanSelfServiceResourceListPassTypesOrder> = z
    .enum(ComCrmPassPlanSelfServiceResourceListPassTypesOrder);

/** @internal */
export type ComCrmPassPlanSelfServiceResourceListPassTypesRequest$Outbound = {
  currency_code?: string | undefined;
  product_id?: string | undefined;
  search_value?: string | undefined;
  include_total: boolean;
  order: string;
  page: number;
  size: number;
  sort: string;
};

/** @internal */
export const ComCrmPassPlanSelfServiceResourceListPassTypesRequest$outboundSchema:
  z.ZodMiniType<
    ComCrmPassPlanSelfServiceResourceListPassTypesRequest$Outbound,
    ComCrmPassPlanSelfServiceResourceListPassTypesRequest
  > = z.pipe(
    z.object({
      currencyCode: z.optional(z.string()),
      productId: z.optional(z.string()),
      searchValue: z.optional(z.string()),
      includeTotal: z._default(z.boolean(), false),
      order: z._default(
        ComCrmPassPlanSelfServiceResourceListPassTypesOrder$outboundSchema,
        "DESC",
      ),
      page: z._default(z.int(), 1),
      size: z._default(z.int(), 10),
      sort: z._default(z.string(), "CREATED_DATE"),
    }),
    z.transform((v) => {
      return remap$(v, {
        currencyCode: "currency_code",
        productId: "product_id",
        searchValue: "search_value",
        includeTotal: "include_total",
      });
    }),
  );

export function comCrmPassPlanSelfServiceResourceListPassTypesRequestToJSON(
  comCrmPassPlanSelfServiceResourceListPassTypesRequest:
    ComCrmPassPlanSelfServiceResourceListPassTypesRequest,
): string {
  return JSON.stringify(
    ComCrmPassPlanSelfServiceResourceListPassTypesRequest$outboundSchema.parse(
      comCrmPassPlanSelfServiceResourceListPassTypesRequest,
    ),
  );
}

/** @internal */
export const ComCrmPassPlanSelfServiceResourceListPassTypesPaging$inboundSchema:
  z.ZodMiniType<ComCrmPassPlanSelfServiceResourceListPassTypesPaging, unknown> =
    z.pipe(
      z.object({
        page: types.optional(types.number()),
        size: types.optional(types.number()),
        total: types.optional(types.number()),
        has_more: types.optional(types.boolean()),
      }),
      z.transform((v) => {
        return remap$(v, {
          "has_more": "hasMore",
        });
      }),
    );

export function comCrmPassPlanSelfServiceResourceListPassTypesPagingFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmPassPlanSelfServiceResourceListPassTypesPaging,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmPassPlanSelfServiceResourceListPassTypesPaging$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmPassPlanSelfServiceResourceListPassTypesPaging' from JSON`,
  );
}

/** @internal */
export const ComCrmPassPlanSelfServiceResourceListPassTypesState$inboundSchema:
  z.ZodMiniType<ComCrmPassPlanSelfServiceResourceListPassTypesState, unknown> =
    openEnums.inboundSchema(
      ComCrmPassPlanSelfServiceResourceListPassTypesState,
    );

/** @internal */
export const ComCrmPassPlanSelfServiceResourceListPassTypesClassification$inboundSchema:
  z.ZodMiniType<
    ComCrmPassPlanSelfServiceResourceListPassTypesClassification,
    unknown
  > = openEnums.inboundSchema(
    ComCrmPassPlanSelfServiceResourceListPassTypesClassification,
  );

/** @internal */
export const PassCodeType$inboundSchema: z.ZodMiniType<PassCodeType, unknown> =
  openEnums.inboundSchema(PassCodeType);

/** @internal */
export const PromotionPasses$inboundSchema: z.ZodMiniType<
  PromotionPasses,
  unknown
> = z.pipe(
  z.object({
    promotion_id: types.string(),
    reward_offer_id: types.string(),
    name: types.optional(types.string()),
    pass_code_type: types.optional(PassCodeType$inboundSchema),
    maximum_usage: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "promotion_id": "promotionId",
      "reward_offer_id": "rewardOfferId",
      "pass_code_type": "passCodeType",
      "maximum_usage": "maximumUsage",
    });
  }),
);

export function promotionPassesFromJSON(
  jsonString: string,
): SafeParseResult<PromotionPasses, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PromotionPasses$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PromotionPasses' from JSON`,
  );
}

/** @internal */
export const ValidityType$inboundSchema: z.ZodMiniType<ValidityType, unknown> =
  openEnums.inboundSchema(ValidityType);

/** @internal */
export const ComCrmPassPlanSelfServiceResourceListPassTypesUot$inboundSchema:
  z.ZodMiniType<ComCrmPassPlanSelfServiceResourceListPassTypesUot, unknown> =
    openEnums.inboundSchema(ComCrmPassPlanSelfServiceResourceListPassTypesUot);

/** @internal */
export const Validity$inboundSchema: z.ZodMiniType<Validity, unknown> = z.pipe(
  z.object({
    type: types.optional(ValidityType$inboundSchema),
    period: types.optional(types.number()),
    uot: types.optional(
      ComCrmPassPlanSelfServiceResourceListPassTypesUot$inboundSchema,
    ),
    fixed_date: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "fixed_date": "fixedDate",
    });
  }),
);

export function validityFromJSON(
  jsonString: string,
): SafeParseResult<Validity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Validity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Validity' from JSON`,
  );
}

/** @internal */
export const ValueType$inboundSchema: z.ZodMiniType<ValueType, unknown> =
  openEnums.inboundSchema(ValueType);

/** @internal */
export const ValueCurrencyCode$inboundSchema: z.ZodMiniType<
  ValueCurrencyCode,
  unknown
> = openEnums.inboundSchema(ValueCurrencyCode);

/** @internal */
export const Value$inboundSchema: z.ZodMiniType<Value, unknown> = z.pipe(
  z.object({
    type: types.optional(ValueType$inboundSchema),
    fixed_amount: types.optional(types.number()),
    minimum: types.optional(types.number()),
    maximum: types.optional(types.number()),
    currency_code: types.optional(ValueCurrencyCode$inboundSchema),
  }),
  z.transform((v) => {
    return remap$(v, {
      "fixed_amount": "fixedAmount",
      "currency_code": "currencyCode",
    });
  }),
);

export function valueFromJSON(
  jsonString: string,
): SafeParseResult<Value, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Value$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Value' from JSON`,
  );
}

/** @internal */
export const CodeFormatType$inboundSchema: z.ZodMiniType<
  CodeFormatType,
  unknown
> = openEnums.inboundSchema(CodeFormatType);

/** @internal */
export const ComCrmPassPlanSelfServiceResourceListPassTypesCodeFormat$inboundSchema:
  z.ZodMiniType<
    ComCrmPassPlanSelfServiceResourceListPassTypesCodeFormat,
    unknown
  > = z.pipe(
    z.object({
      type: CodeFormatType$inboundSchema,
      prefix: types.optional(types.string()),
      suffix: types.optional(types.string()),
      length: types.optional(types.number()),
      pin_required: z._default(types.boolean(), false),
      single_code: types.optional(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "pin_required": "pinRequired",
        "single_code": "singleCode",
      });
    }),
  );

export function comCrmPassPlanSelfServiceResourceListPassTypesCodeFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmPassPlanSelfServiceResourceListPassTypesCodeFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmPassPlanSelfServiceResourceListPassTypesCodeFormat$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmPassPlanSelfServiceResourceListPassTypesCodeFormat' from JSON`,
  );
}

/** @internal */
export const CreditWalletBalance$inboundSchema: z.ZodMiniType<
  CreditWalletBalance,
  unknown
> = openEnums.inboundSchema(CreditWalletBalance);

/** @internal */
export const ComCrmPassPlanSelfServiceResourceListPassTypesCommercePool$inboundSchema:
  z.ZodMiniType<
    ComCrmPassPlanSelfServiceResourceListPassTypesCommercePool,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    description: types.optional(types.string()),
  });

export function comCrmPassPlanSelfServiceResourceListPassTypesCommercePoolFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmPassPlanSelfServiceResourceListPassTypesCommercePool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmPassPlanSelfServiceResourceListPassTypesCommercePool$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmPassPlanSelfServiceResourceListPassTypesCommercePool' from JSON`,
  );
}

/** @internal */
export const ComCrmPassPlanSelfServiceResourceListPassTypesCustomField$inboundSchema:
  z.ZodMiniType<
    ComCrmPassPlanSelfServiceResourceListPassTypesCustomField,
    unknown
  > = z.object({
    key: types.optional(types.string()),
    value: types.optional(types.string()),
  });

export function comCrmPassPlanSelfServiceResourceListPassTypesCustomFieldFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmPassPlanSelfServiceResourceListPassTypesCustomField,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmPassPlanSelfServiceResourceListPassTypesCustomField$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmPassPlanSelfServiceResourceListPassTypesCustomField' from JSON`,
  );
}

/** @internal */
export const ComCrmPassPlanSelfServiceResourceListPassTypesCurrencyCode$inboundSchema:
  z.ZodMiniType<
    ComCrmPassPlanSelfServiceResourceListPassTypesCurrencyCode,
    unknown
  > = openEnums.inboundSchema(
    ComCrmPassPlanSelfServiceResourceListPassTypesCurrencyCode,
  );

/** @internal */
export const ComCrmPassPlanSelfServiceResourceListPassTypesProduct$inboundSchema:
  z.ZodMiniType<
    ComCrmPassPlanSelfServiceResourceListPassTypesProduct,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    sku: types.optional(types.string()),
  });

export function comCrmPassPlanSelfServiceResourceListPassTypesProductFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmPassPlanSelfServiceResourceListPassTypesProduct,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmPassPlanSelfServiceResourceListPassTypesProduct$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmPassPlanSelfServiceResourceListPassTypesProduct' from JSON`,
  );
}

/** @internal */
export const ComCrmPassPlanSelfServiceResourceListPassTypesContent$inboundSchema:
  z.ZodMiniType<
    ComCrmPassPlanSelfServiceResourceListPassTypesContent,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      state: types.optional(
        ComCrmPassPlanSelfServiceResourceListPassTypesState$inboundSchema,
      ),
      name: types.optional(types.string()),
      description: types.optional(types.string()),
      classification: types.optional(
        ComCrmPassPlanSelfServiceResourceListPassTypesClassification$inboundSchema,
      ),
      promotion_passes: types.optional(
        z.lazy(() => PromotionPasses$inboundSchema),
      ),
      validity: types.optional(z.lazy(() => Validity$inboundSchema)),
      value: types.optional(z.lazy(() => Value$inboundSchema)),
      printed: types.optional(types.boolean()),
      code_format: types.optional(z.lazy(() =>
        ComCrmPassPlanSelfServiceResourceListPassTypesCodeFormat$inboundSchema
      )),
      credit_wallet_balance: types.optional(CreditWalletBalance$inboundSchema),
      commerce_pool: types.optional(z.lazy(() =>
        ComCrmPassPlanSelfServiceResourceListPassTypesCommercePool$inboundSchema
      )),
      number_of_passes: types.optional(types.number()),
      passes_generated: types.optional(types.number()),
      custom_fields: types.optional(z.array(z.lazy(() =>
        ComCrmPassPlanSelfServiceResourceListPassTypesCustomField$inboundSchema
      ))),
      currency_code:
        ComCrmPassPlanSelfServiceResourceListPassTypesCurrencyCode$inboundSchema,
      product: types.optional(z.lazy(() =>
        ComCrmPassPlanSelfServiceResourceListPassTypesProduct$inboundSchema
      )),
    }),
    z.transform((v) => {
      return remap$(v, {
        "promotion_passes": "promotionPasses",
        "code_format": "codeFormat",
        "credit_wallet_balance": "creditWalletBalance",
        "commerce_pool": "commercePool",
        "number_of_passes": "numberOfPasses",
        "passes_generated": "passesGenerated",
        "custom_fields": "customFields",
        "currency_code": "currencyCode",
      });
    }),
  );

export function comCrmPassPlanSelfServiceResourceListPassTypesContentFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmPassPlanSelfServiceResourceListPassTypesContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmPassPlanSelfServiceResourceListPassTypesContent$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmPassPlanSelfServiceResourceListPassTypesContent' from JSON`,
  );
}

/** @internal */
export const ComCrmPassPlanSelfServiceResourceListPassTypesResponse$inboundSchema:
  z.ZodMiniType<
    ComCrmPassPlanSelfServiceResourceListPassTypesResponse,
    unknown
  > = z.object({
    paging: types.optional(
      z.lazy(() =>
        ComCrmPassPlanSelfServiceResourceListPassTypesPaging$inboundSchema
      ),
    ),
    content: types.optional(
      z.array(z.lazy(() =>
        ComCrmPassPlanSelfServiceResourceListPassTypesContent$inboundSchema
      )),
    ),
  });

export function comCrmPassPlanSelfServiceResourceListPassTypesResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmPassPlanSelfServiceResourceListPassTypesResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmPassPlanSelfServiceResourceListPassTypesResponse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmPassPlanSelfServiceResourceListPassTypesResponse' from JSON`,
  );
}
