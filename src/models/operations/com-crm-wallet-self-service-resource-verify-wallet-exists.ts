/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 * @generated-id: 6f94971d3cbc
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

export type ComCrmWalletSelfServiceResourceVerifyWalletExistsSecurity = {
  publicAPIKey: string;
};

export type ComCrmWalletSelfServiceResourceVerifyWalletExistsRequest = {
  /**
   * A wallet can either be identified across the business network based on a phone or email address
   */
  type?: string | undefined;
  /**
   * The wallet identity phone or email address depending on the identity's type
   */
  value?: string | undefined;
};

/**
 * OK
 */
export type ComCrmWalletSelfServiceResourceVerifyWalletExistsResponse = {
  /**
   * Indicates whether a wallet using the email or phone provided as identity, already exists
   */
  walletExists?: boolean | undefined;
};

/** @internal */
export type ComCrmWalletSelfServiceResourceVerifyWalletExistsSecurity$Outbound =
  {
    Public_API_key: string;
  };

/** @internal */
export const ComCrmWalletSelfServiceResourceVerifyWalletExistsSecurity$outboundSchema:
  z.ZodMiniType<
    ComCrmWalletSelfServiceResourceVerifyWalletExistsSecurity$Outbound,
    ComCrmWalletSelfServiceResourceVerifyWalletExistsSecurity
  > = z.pipe(
    z.object({
      publicAPIKey: z.string(),
    }),
    z.transform((v) => {
      return remap$(v, {
        publicAPIKey: "Public_API_key",
      });
    }),
  );

export function comCrmWalletSelfServiceResourceVerifyWalletExistsSecurityToJSON(
  comCrmWalletSelfServiceResourceVerifyWalletExistsSecurity:
    ComCrmWalletSelfServiceResourceVerifyWalletExistsSecurity,
): string {
  return JSON.stringify(
    ComCrmWalletSelfServiceResourceVerifyWalletExistsSecurity$outboundSchema
      .parse(comCrmWalletSelfServiceResourceVerifyWalletExistsSecurity),
  );
}

/** @internal */
export type ComCrmWalletSelfServiceResourceVerifyWalletExistsRequest$Outbound =
  {
    type?: string | undefined;
    value?: string | undefined;
  };

/** @internal */
export const ComCrmWalletSelfServiceResourceVerifyWalletExistsRequest$outboundSchema:
  z.ZodMiniType<
    ComCrmWalletSelfServiceResourceVerifyWalletExistsRequest$Outbound,
    ComCrmWalletSelfServiceResourceVerifyWalletExistsRequest
  > = z.object({
    type: z.optional(z.string()),
    value: z.optional(z.string()),
  });

export function comCrmWalletSelfServiceResourceVerifyWalletExistsRequestToJSON(
  comCrmWalletSelfServiceResourceVerifyWalletExistsRequest:
    ComCrmWalletSelfServiceResourceVerifyWalletExistsRequest,
): string {
  return JSON.stringify(
    ComCrmWalletSelfServiceResourceVerifyWalletExistsRequest$outboundSchema
      .parse(comCrmWalletSelfServiceResourceVerifyWalletExistsRequest),
  );
}

/** @internal */
export const ComCrmWalletSelfServiceResourceVerifyWalletExistsResponse$inboundSchema:
  z.ZodMiniType<
    ComCrmWalletSelfServiceResourceVerifyWalletExistsResponse,
    unknown
  > = z.pipe(
    z.object({
      wallet_exists: types.optional(types.boolean()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "wallet_exists": "walletExists",
      });
    }),
  );

export function comCrmWalletSelfServiceResourceVerifyWalletExistsResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmWalletSelfServiceResourceVerifyWalletExistsResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmWalletSelfServiceResourceVerifyWalletExistsResponse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmWalletSelfServiceResourceVerifyWalletExistsResponse' from JSON`,
  );
}
