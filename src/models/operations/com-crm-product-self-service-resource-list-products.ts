/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

export type ComCrmProductSelfServiceResourceListProductsSecurity = {
  secretAPIKey?: string | undefined;
  authorizationSelfService?: string | undefined;
};

/**
 * Defines how the results will be ordered
 */
export const ComCrmProductSelfServiceResourceListProductsOrder = {
  Asc: "ASC",
  Desc: "DESC",
} as const;
/**
 * Defines how the results will be ordered
 */
export type ComCrmProductSelfServiceResourceListProductsOrder = ClosedEnum<
  typeof ComCrmProductSelfServiceResourceListProductsOrder
>;

export type ComCrmProductSelfServiceResourceListProductsRequest = {
  /**
   * Billing period duration. If specified, then the period's UOT must also be specified
   */
  billingPeriod?: number | undefined;
  /**
   * Billing period's uot (required when searching for services with a specific billing cycle duration)
   */
  billingPeriodUot?: string | undefined;
  /**
   * Filter based on product brand
   */
  brandId?: string | undefined;
  /**
   * Search for products under the specified category, including all products assigned to its sub-categories.
   */
  categoryId?: string | undefined;
  /**
   * Search for products assigned only to the specified category. Products in sub-categories of the specified category are not included.
   */
  categoryIdExact?: string | undefined;
  /**
   * Search based on characteristics, in key/value pairs
   */
  characteristics?: string | undefined;
  /**
   * The product’s classification
   */
  classification?: string | undefined;
  /**
   * The product’s composition
   */
  composition?: string | undefined;
  /**
   * Retrieve product prices that are filtered according to the selected country.
   */
  country?: string | undefined;
  /**
   * Retrieve product prices in the selected currency. If multiple prices exist, the system defaults to the currency of the contact’s primary account.
   */
  currency?: string | undefined;
  /**
   * Search based on product custom fields, in key/value pairs
   */
  customFields?: string | undefined;
  /**
   * Filter based on product family
   */
  familyId?: string | undefined;
  /**
   * The organisation that will fulfill a customer’s ordering. Products that can be ordered by the specified organisation at the time of ordering will be returned
   */
  fulfilledBy?: string | undefined;
  /**
   * Defines whether characteristics should be retrieved or not</br>Default:false
   */
  includeCharacteristics?: boolean | undefined;
  /**
   * Defines whether custom fields should be retrieved or not</br>Default:false
   */
  includeCustomFields?: boolean | undefined;
  /**
   * Defines whether included one time services should be retrieved or not</br>Default:false
   */
  includesOneTimeServices?: boolean | undefined;
  /**
   * The instance model
   */
  instanceModel?: string | undefined;
  /**
   * If specified, then only products marked as modifiers are returned. A product is marked as modifier through its type. If not specified, then it’s ignored and filtering is not applied.
   */
  isModifier?: boolean | undefined;
  /**
   * Filter based on product name (search based on like, for a minimum of three characters search with CONTAINS and case insensitive)
   */
  name?: string | undefined;
  /**
   * Filter based on order catalogue
   */
  orderCatalogId?: string | undefined;
  /**
   * Filter based on order catalogue category
   */
  orderCategoryId?: string | undefined;
  /**
   * The organisation owning the product catalog (the subsidiary, merchant or venue from which the products will be purchased)
   */
  ownedBy?: string | undefined;
  /**
   * Filter based on product ids
   */
  productIds?: string | undefined;
  /**
   * Filter based on product skus
   */
  productSkus?: string | undefined;
  /**
   * Search for a product using its SKU or name
   */
  searchValue?: string | undefined;
  /**
   * Filter based on product supply method
   */
  supplyMethod?: string | undefined;
  /**
   * Filter based on product type
   */
  typeId?: string | undefined;
  /**
   * The date on which a product is sold/added as a charge or a service should also be within its validity date. Applicable only when listing products to get the services available to be ordered, added as charges or included in a subscription either as a new addition or through a service change. Filter based on the validity date, which may fall within a given date range. The value can be a string with a date in epoch format. Each option must also include an operator. Use up to two options based on the required search (e.g. validity_date[gte]=1618395497&validity_date[lt]=1618395497).
   */
  validityDate?: number | undefined;
  /**
   * Determine if a "total" will be returned in paging reference. If set to True, then "total" is also returned but it will return up to 10K value. If set to False, then the "total" in paging is null.
   */
  includeTotal?: boolean | undefined;
  /**
   * Defines how the results will be ordered
   */
  order?: ComCrmProductSelfServiceResourceListProductsOrder | undefined;
  /**
   * The page number that should be retrieved
   */
  page?: number | undefined;
  /**
   * The size (total records) of each page
   */
  size?: number | undefined;
  /**
   * Defines on which attribute the results should be sorted
   */
  sort?: string | undefined;
};

export type ComCrmProductSelfServiceResourceListProductsPaging = {
  /**
   * The page number
   */
  page?: number | undefined;
  /**
   * The number of records per page
   */
  size?: number | undefined;
  /**
   * The total number of records. If "include_total" is not specified, then this total is null. If "include_total" is specified, total has a value but it is accurate up to 10K records.
   */
  total?: number | undefined;
  /**
   * Shows if there are more records available to fetch
   */
  hasMore?: boolean | undefined;
};

/**
 * Product type classification
 */
export const ComCrmProductSelfServiceResourceListProductsClassification = {
  TermedService: "TERMED_SERVICE",
  UsageService: "USAGE_SERVICE",
  OneTimeService: "ONE_TIME_SERVICE",
  TraceablePhysicalGood: "TRACEABLE_PHYSICAL_GOOD",
  NonTraceablePhysicalGood: "NON_TRACEABLE_PHYSICAL_GOOD",
  ExpensesService: "EXPENSES_SERVICE",
} as const;
/**
 * Product type classification
 */
export type ComCrmProductSelfServiceResourceListProductsClassification =
  OpenEnum<typeof ComCrmProductSelfServiceResourceListProductsClassification>;

export const ComCrmProductSelfServiceResourceListProductsTypeComposition = {
  Flat: "FLAT",
  FlexibleBundle: "FLEXIBLE_BUNDLE",
  FixedBundle: "FIXED_BUNDLE",
  Composite: "COMPOSITE",
} as const;
export type ComCrmProductSelfServiceResourceListProductsTypeComposition =
  OpenEnum<typeof ComCrmProductSelfServiceResourceListProductsTypeComposition>;

/**
 * Denotes whether the product is available for ordering at the organisation that will fulfill the order. Available only if a fulfilled by organisation is set in the method's filters
 */
export const ComCrmProductSelfServiceResourceListProductsAvailability = {
  Enabled: "ENABLED",
  Disabled: "DISABLED",
} as const;
/**
 * Denotes whether the product is available for ordering at the organisation that will fulfill the order. Available only if a fulfilled by organisation is set in the method's filters
 */
export type ComCrmProductSelfServiceResourceListProductsAvailability = OpenEnum<
  typeof ComCrmProductSelfServiceResourceListProductsAvailability
>;

/**
 * Details about the organisation
 */
export type ComCrmProductSelfServiceResourceListProductsOwner = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
};

/**
 * Determines whether a service is managed as a single quantity or as separate, independently managed instances on a subscription
 */
export const ComCrmProductSelfServiceResourceListProductsInstanceModel = {
  QuantityBased: "QUANTITY_BASED",
  LineBased: "LINE_BASED",
} as const;
/**
 * Determines whether a service is managed as a single quantity or as separate, independently managed instances on a subscription
 */
export type ComCrmProductSelfServiceResourceListProductsInstanceModel =
  OpenEnum<typeof ComCrmProductSelfServiceResourceListProductsInstanceModel>;

export type ComCrmProductSelfServiceResourceListProductsCharacteristic = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * Attribute’s key
   */
  key?: string | undefined;
  /**
   * Attribute’s value
   */
  value?: string | undefined;
  /**
   * Attribute’s label for UI purposes
   */
  label?: string | undefined;
  /**
   * Defines whether the attribute is mandatory (and cannot be removed from the product) or not
   */
  mandatory?: boolean | undefined;
};

/**
 * Currency code
 */
export const ComCrmProductSelfServiceResourceListProductsCurrencyCode = {
  Aed: "AED",
  Afn: "AFN",
  All: "ALL",
  Amd: "AMD",
  Ang: "ANG",
  Aoa: "AOA",
  Ars: "ARS",
  Aud: "AUD",
  Awg: "AWG",
  Azn: "AZN",
  Bam: "BAM",
  Bbd: "BBD",
  Bdt: "BDT",
  Bgn: "BGN",
  Bhd: "BHD",
  Bif: "BIF",
  Bmd: "BMD",
  Bnd: "BND",
  Bob: "BOB",
  Brl: "BRL",
  Bsd: "BSD",
  Btn: "BTN",
  Bwp: "BWP",
  Byr: "BYR",
  Bzd: "BZD",
  Cad: "CAD",
  Cdf: "CDF",
  Chf: "CHF",
  Clp: "CLP",
  Cny: "CNY",
  Cop: "COP",
  Crc: "CRC",
  Cuc: "CUC",
  Cup: "CUP",
  Cve: "CVE",
  Czk: "CZK",
  Djf: "DJF",
  Dkk: "DKK",
  Dop: "DOP",
  Dzd: "DZD",
  Egp: "EGP",
  Ern: "ERN",
  Etb: "ETB",
  Eur: "EUR",
  Fjd: "FJD",
  Fkp: "FKP",
  Gbp: "GBP",
  Gel: "GEL",
  Ggp: "GGP",
  Ghs: "GHS",
  Gip: "GIP",
  Gmd: "GMD",
  Gnf: "GNF",
  Gtq: "GTQ",
  Gyd: "GYD",
  Hkd: "HKD",
  Hnl: "HNL",
  Hrk: "HRK",
  Htg: "HTG",
  Huf: "HUF",
  Idr: "IDR",
  Ils: "ILS",
  Imp: "IMP",
  Inr: "INR",
  Iqd: "IQD",
  Irr: "IRR",
  Isk: "ISK",
  Jep: "JEP",
  Jmd: "JMD",
  Jod: "JOD",
  Jpy: "JPY",
  Kes: "KES",
  Kgs: "KGS",
  Khr: "KHR",
  Kmf: "KMF",
  Kpw: "KPW",
  Krw: "KRW",
  Kwd: "KWD",
  Kyd: "KYD",
  Kzt: "KZT",
  Lak: "LAK",
  Lbp: "LBP",
  Lkr: "LKR",
  Lrd: "LRD",
  Lsl: "LSL",
  Lyd: "LYD",
  Mad: "MAD",
  Mdl: "MDL",
  Mga: "MGA",
  Mkd: "MKD",
  Mmk: "MMK",
  Mnt: "MNT",
  Mop: "MOP",
  Mro: "MRO",
  Mur: "MUR",
  Mvr: "MVR",
  Mwk: "MWK",
  Mxn: "MXN",
  Myr: "MYR",
  Mzn: "MZN",
  Nad: "NAD",
  Ngn: "NGN",
  Nio: "NIO",
  Nok: "NOK",
  Npr: "NPR",
  Nzd: "NZD",
  Omr: "OMR",
  Pab: "PAB",
  Pen: "PEN",
  Pgk: "PGK",
  Php: "PHP",
  Pkr: "PKR",
  Pln: "PLN",
  Pyg: "PYG",
  Qar: "QAR",
  Ron: "RON",
  Rsd: "RSD",
  Rub: "RUB",
  Rwf: "RWF",
  Sar: "SAR",
  Sbd: "SBD",
  Scr: "SCR",
  Sdg: "SDG",
  Sek: "SEK",
  Sgd: "SGD",
  Shp: "SHP",
  Sll: "SLL",
  Sos: "SOS",
  Spl: "SPL",
  Srd: "SRD",
  Std: "STD",
  Svc: "SVC",
  Syp: "SYP",
  Szl: "SZL",
  Thb: "THB",
  Tjs: "TJS",
  Tmt: "TMT",
  Tnd: "TND",
  Top: "TOP",
  Try: "TRY",
  Ttd: "TTD",
  Tvd: "TVD",
  Twd: "TWD",
  Tzs: "TZS",
  Uah: "UAH",
  Ugx: "UGX",
  Usd: "USD",
  Uyu: "UYU",
  Uzs: "UZS",
  Vef: "VEF",
  Vnd: "VND",
  Vuv: "VUV",
  Wst: "WST",
  Xaf: "XAF",
  Xcd: "XCD",
  Xdr: "XDR",
  Xof: "XOF",
  Xpf: "XPF",
  Yer: "YER",
  Zar: "ZAR",
  Zmw: "ZMW",
  Zwd: "ZWD",
  Pts: "PTS",
} as const;
/**
 * Currency code
 */
export type ComCrmProductSelfServiceResourceListProductsCurrencyCode = OpenEnum<
  typeof ComCrmProductSelfServiceResourceListProductsCurrencyCode
>;

/**
 * The tax model of price
 */
export const ComCrmProductSelfServiceResourceListProductsTaxModel = {
  TaxInclusive: "TAX_INCLUSIVE",
  TaxExclusive: "TAX_EXCLUSIVE",
} as const;
/**
 * The tax model of price
 */
export type ComCrmProductSelfServiceResourceListProductsTaxModel = OpenEnum<
  typeof ComCrmProductSelfServiceResourceListProductsTaxModel
>;

/**
 * The price model of price
 */
export const ComCrmProductSelfServiceResourceListProductsPriceModel = {
  Flat: "FLAT",
  Tiered: "TIERED",
  Volume: "VOLUME",
  Stairstep: "STAIRSTEP",
} as const;
/**
 * The price model of price
 */
export type ComCrmProductSelfServiceResourceListProductsPriceModel = OpenEnum<
  typeof ComCrmProductSelfServiceResourceListProductsPriceModel
>;

/**
 * Defines the order’ supply method
 */
export const ComCrmProductSelfServiceResourceListProductsSupplyMethod = {
  Delivery: "DELIVERY",
  PickUp: "PICK_UP",
  DirectSale: "DIRECT_SALE",
} as const;
/**
 * Defines the order’ supply method
 */
export type ComCrmProductSelfServiceResourceListProductsSupplyMethod = OpenEnum<
  typeof ComCrmProductSelfServiceResourceListProductsSupplyMethod
>;

/**
 * The sales model unique identifier which will enable the user to choose one of the configured sales model types for the product
 */
export type ComCrmProductSelfServiceResourceListProductsSalesModel = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
};

export type ComCrmProductSelfServiceResourceListProductsOrderQueue = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
};

/**
 * Period Cycle unit of time
 */
export const ComCrmProductSelfServiceResourceListProductsBillingPeriodUot = {
  Second: "SECOND",
  Minute: "MINUTE",
  Hour: "HOUR",
  Day: "DAY",
  Week: "WEEK",
  Month: "MONTH",
  Year: "YEAR",
  Overall: "OVERALL",
} as const;
/**
 * Period Cycle unit of time
 */
export type ComCrmProductSelfServiceResourceListProductsBillingPeriodUot =
  OpenEnum<typeof ComCrmProductSelfServiceResourceListProductsBillingPeriodUot>;

/**
 * The service's billing cycle
 */
export type ComCrmProductSelfServiceResourceListProductsBillingPeriod = {
  /**
   * Period Cycle duration
   */
  duration?: number | undefined;
  /**
   * Period Cycle unit of time
   */
  uot?:
    | ComCrmProductSelfServiceResourceListProductsBillingPeriodUot
    | undefined;
};

/**
 * Period Cycle unit of time
 */
export const ComCrmProductSelfServiceResourceListProductsTrialPeriodUot = {
  Second: "SECOND",
  Minute: "MINUTE",
  Hour: "HOUR",
  Day: "DAY",
  Week: "WEEK",
  Month: "MONTH",
  Year: "YEAR",
  Overall: "OVERALL",
} as const;
/**
 * Period Cycle unit of time
 */
export type ComCrmProductSelfServiceResourceListProductsTrialPeriodUot =
  OpenEnum<typeof ComCrmProductSelfServiceResourceListProductsTrialPeriodUot>;

/**
 * Shows if the service will get a trial period
 */
export type ComCrmProductSelfServiceResourceListProductsTrialPeriod = {
  /**
   * Period Cycle duration
   */
  duration?: number | undefined;
  /**
   * Period Cycle unit of time
   */
  uot?: ComCrmProductSelfServiceResourceListProductsTrialPeriodUot | undefined;
};

/**
 * The period of time that contacts will have access to the service. Applicable only for one-time services. Either the billing period or the access period should be specified for one-time services.
 */
export type ComCrmProductSelfServiceResourceListProductsAccessPeriod = {
  /**
   * The date that the One Time service will start
   */
  startDate?: number | undefined;
  /**
   * The date that the One Time service will end
   */
  endDate?: number | undefined;
};

/**
 * Defines whether the service is billed in pre-/post-bill mode
 */
export const ComCrmProductSelfServiceResourceListProductsBillingModel = {
  PreBill: "PRE_BILL",
  PostBill: "POST_BILL",
} as const;
/**
 * Defines whether the service is billed in pre-/post-bill mode
 */
export type ComCrmProductSelfServiceResourceListProductsBillingModel = OpenEnum<
  typeof ComCrmProductSelfServiceResourceListProductsBillingModel
>;

/**
 * Period Cycle unit of time
 */
export const ComCrmProductSelfServiceResourceListProductsContractPeriodUot = {
  Second: "SECOND",
  Minute: "MINUTE",
  Hour: "HOUR",
  Day: "DAY",
  Week: "WEEK",
  Month: "MONTH",
  Year: "YEAR",
  Overall: "OVERALL",
} as const;
/**
 * Period Cycle unit of time
 */
export type ComCrmProductSelfServiceResourceListProductsContractPeriodUot =
  OpenEnum<
    typeof ComCrmProductSelfServiceResourceListProductsContractPeriodUot
  >;

/**
 * The service's contract period (if any)
 */
export type ComCrmProductSelfServiceResourceListProductsContractPeriod = {
  /**
   * Period Cycle duration
   */
  duration?: number | undefined;
  /**
   * Period Cycle unit of time
   */
  uot?:
    | ComCrmProductSelfServiceResourceListProductsContractPeriodUot
    | undefined;
};

/**
 * Applicable only for traceable physical goods given to contacts as Rentals
 */
export type ComCrmProductSelfServiceResourceListProductsRentalService = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
  /**
   * The entity sku
   */
  sku?: string | undefined;
};

export const ComCrmProductSelfServiceResourceListProductsValueType = {
  Fixed: "FIXED",
  Variable: "VARIABLE",
} as const;
export type ComCrmProductSelfServiceResourceListProductsValueType = OpenEnum<
  typeof ComCrmProductSelfServiceResourceListProductsValueType
>;

/**
 * price terms
 */
export type ComCrmProductSelfServiceResourceListProductsPriceTerms = {
  /**
   * The service's billing cycle
   */
  billingPeriod?:
    | ComCrmProductSelfServiceResourceListProductsBillingPeriod
    | undefined;
  /**
   * Shows if the service will get a trial period
   */
  trialPeriod?:
    | ComCrmProductSelfServiceResourceListProductsTrialPeriod
    | undefined;
  /**
   * The period of time that contacts will have access to the service. Applicable only for one-time services. Either the billing period or the access period should be specified for one-time services.
   */
  accessPeriod?:
    | ComCrmProductSelfServiceResourceListProductsAccessPeriod
    | undefined;
  /**
   * Defines whether the service is auto-renewed at the end of the termed period or it gets expired.
   */
  autoRenewed?: boolean | undefined;
  /**
   * Defines whether the service is billed in pre-/post-bill mode
   */
  billingModel?:
    | ComCrmProductSelfServiceResourceListProductsBillingModel
    | undefined;
  /**
   * The service's contract period (if any)
   */
  contractPeriod?:
    | ComCrmProductSelfServiceResourceListProductsContractPeriod
    | undefined;
  /**
   * Number of billing cycles that the service' termed period covers
   */
  termsBillingCycles?: number | undefined;
  /**
   * Applicable only for traceable physical goods given to contacts as Rentals
   */
  rentalService?:
    | ComCrmProductSelfServiceResourceListProductsRentalService
    | undefined;
  valueType?: ComCrmProductSelfServiceResourceListProductsValueType | undefined;
};

export type ComCrmProductSelfServiceResourceListProductsTier = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The lower tier in the price's range. The first range's tier must begin with 1. Then each subsequent range's lower tier must have a value equal to the previous range's upper tier +1.
   */
  lowerTier?: number | undefined;
  /**
   * The upper tier. Not rquired (and should remain empty in the last tier range).
   */
  upperTier?: number | undefined;
  /**
   * Tier range’s price
   */
  price?: number | undefined;
  outOfContract?: number | undefined;
};

export type ComCrmProductSelfServiceResourceListProductsPricing = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * Price
   */
  price?: number | undefined;
  /**
   * Price label
   */
  label?: string | undefined;
  /**
   * Currency code
   */
  currencyCode?:
    | ComCrmProductSelfServiceResourceListProductsCurrencyCode
    | undefined;
  /**
   * Default price
   */
  isDefault?: boolean | undefined;
  /**
   * The tax model of price
   */
  taxModel?: ComCrmProductSelfServiceResourceListProductsTaxModel | undefined;
  /**
   * The price model of price
   */
  priceModel?:
    | ComCrmProductSelfServiceResourceListProductsPriceModel
    | undefined;
  /**
   * Defines the order’ supply method
   */
  supplyMethod?:
    | ComCrmProductSelfServiceResourceListProductsSupplyMethod
    | undefined;
  /**
   * The sales model unique identifier which will enable the user to choose one of the configured sales model types for the product
   */
  salesModel?:
    | ComCrmProductSelfServiceResourceListProductsSalesModel
    | undefined;
  orderQueue?:
    | ComCrmProductSelfServiceResourceListProductsOrderQueue
    | undefined;
  /**
   * price terms
   */
  priceTerms?:
    | ComCrmProductSelfServiceResourceListProductsPriceTerms
    | undefined;
  /**
   * List of tiered prices. Applicable only for Tiered/Volume/Stairstep pricing models
   */
  tiers?: Array<ComCrmProductSelfServiceResourceListProductsTier> | undefined;
};

/**
 * Information about the creative type
 */
export const ComCrmProductSelfServiceResourceListProductsUsageType = {
  Logo: "LOGO",
  Background: "BACKGROUND",
  Avatar: "AVATAR",
  Hero: "HERO",
  Marketing: "MARKETING",
  Attachment: "ATTACHMENT",
  Profileimage: "PROFILEIMAGE",
  AppleLockscreenIcon: "APPLE_LOCKSCREEN_ICON",
  AppleLogoImage: "APPLE_LOGO_IMAGE",
  AppleStripImage: "APPLE_STRIP_IMAGE",
  GoogleLogoImage: "GOOGLE_LOGO_IMAGE",
  GoogleStripImage: "GOOGLE_STRIP_IMAGE",
  LandingPageLogoImage: "LANDING_PAGE_LOGO_IMAGE",
  LandingPageHeaderImage: "LANDING_PAGE_HEADER_IMAGE",
  LandingPageBackgroundImage: "LANDING_PAGE_BACKGROUND_IMAGE",
  DeliveryImage: "DELIVERY_IMAGE",
  PickupImage: "PICKUP_IMAGE",
  DirectSaleImage: "DIRECT_SALE_IMAGE",
  WalletImage: "WALLET_IMAGE",
  LandingPageImage: "LANDING_PAGE_IMAGE",
  AppLogo: "APP_LOGO",
  PartnerLogo: "PARTNER_LOGO",
  Carousel: "CAROUSEL",
  Shortcut: "SHORTCUT",
  ShortcutImage: "SHORTCUT_IMAGE",
  EmbeddedLinkImage: "EMBEDDED_LINK_IMAGE",
  Image: "IMAGE",
  AppLoaderImage: "APP_LOADER_IMAGE",
  MobileBackgroundImage: "MOBILE_BACKGROUND_IMAGE",
} as const;
/**
 * Information about the creative type
 */
export type ComCrmProductSelfServiceResourceListProductsUsageType = OpenEnum<
  typeof ComCrmProductSelfServiceResourceListProductsUsageType
>;

export type ComCrmProductSelfServiceResourceListProductsMedia = {
  /**
   * The transformed creative width
   */
  width?: number | undefined;
  /**
   * The transformed creative height
   */
  height?: number | undefined;
  /**
   * The transformed creative URL
   */
  url?: string | undefined;
};

export type ComCrmProductSelfServiceResourceListProductsCreative = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * the identifier of media
   */
  mediaGroupId?: string | undefined;
  /**
   * Information about the creative type
   */
  usageType?: ComCrmProductSelfServiceResourceListProductsUsageType | undefined;
  /**
   * The creative width
   */
  width?: number | undefined;
  /**
   * The creative height
   */
  height?: number | undefined;
  /**
   * The creative format
   */
  format?: string | undefined;
  /**
   * The creative content URL
   */
  url?: string | undefined;
  /**
   * The creative public identifier
   */
  publicId?: string | undefined;
  /**
   * The media identifier
   */
  mediaId?: string | undefined;
  /**
   * The creative caption used in cases where usage_type=CAROUSEL
   */
  caption?: string | undefined;
  /**
   * The creative sort order used in cases where usage_type=CAROUSEL
   */
  sortOrder?: number | undefined;
  /**
   * Information about the creative transformations
   */
  media?: Array<ComCrmProductSelfServiceResourceListProductsMedia> | undefined;
};

/**
 * A list of custom fields whose values can be set when creating or updating entities
 */
export type ComCrmProductSelfServiceResourceListProductsCustomField = {
  /**
   * The custom field’s unique key
   */
  key?: string | undefined;
  /**
   * The custom field’s value
   */
  value?: string | undefined;
};

export type ComCrmProductSelfServiceResourceListProductsIncludedOneTimeService =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The entity name
     */
    name?: string | undefined;
    /**
     * The entity sku
     */
    sku?: string | undefined;
  };

export type ComCrmProductSelfServiceResourceListProductsContent = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * Product SKU
   */
  sku?: string | undefined;
  /**
   * Product name
   */
  name?: string | undefined;
  /**
   * Product description
   */
  description?: string | undefined;
  /**
   * Product type classification
   */
  classification?:
    | ComCrmProductSelfServiceResourceListProductsClassification
    | undefined;
  typeComposition?:
    | ComCrmProductSelfServiceResourceListProductsTypeComposition
    | undefined;
  /**
   * Number of items in the product's allowed composition.Available only for bundles and composite products
   */
  components?: number | undefined;
  /**
   * Number of variant products. Available only for Composite prducts
   */
  variants?: number | undefined;
  /**
   * Number of characteristics
   */
  numberOfCharacteristics?: number | undefined;
  numberOfPrices?: number | undefined;
  /**
   * Denotes whether the product is available for ordering at the organisation that will fulfill the order. Available only if a fulfilled by organisation is set in the method's filters
   */
  availability?:
    | ComCrmProductSelfServiceResourceListProductsAvailability
    | undefined;
  /**
   * Details about the organisation
   */
  owner?: ComCrmProductSelfServiceResourceListProductsOwner | undefined;
  /**
   * Defines whether the product is modifier
   */
  isModifier?: boolean | undefined;
  /**
   * Defines whether the product is allowed to have negative balance
   */
  negativeBalanceAllowed?: boolean | undefined;
  /**
   * Defines whether the product is used for provision
   */
  isProvisionable?: boolean | undefined;
  /**
   * Defines whether the product is a stockable product
   */
  isStockable?: boolean | undefined;
  /**
   * Determines whether a service is managed as a single quantity or as separate, independently managed instances on a subscription
   */
  instanceModel?:
    | ComCrmProductSelfServiceResourceListProductsInstanceModel
    | undefined;
  /**
   * List of product characteristics and their values
   */
  characteristics?:
    | Array<ComCrmProductSelfServiceResourceListProductsCharacteristic>
    | undefined;
  /**
   * Lists all prices of the product. Only prices applicable at the account owner's Country of agreement are returned.
   */
  pricing?:
    | Array<ComCrmProductSelfServiceResourceListProductsPricing>
    | undefined;
  /**
   * A creative is an object that contains all the data required for visually rendering an image responsively. The object contains the initial image and a number of scale versions of it (srcset)
   */
  creatives?:
    | Array<ComCrmProductSelfServiceResourceListProductsCreative>
    | undefined;
  /**
   * A list of custom fields whose values can be set when creating or updating entities
   */
  customFields?:
    | Array<ComCrmProductSelfServiceResourceListProductsCustomField>
    | null
    | undefined;
  /**
   * A list of one-time services which extend the behaviour of a termed service product so whenever the termed service is added/renewed, then all related one-time service are added to the same subscription. Only one-time services can be specified and applicable only for flat, termed services.
   */
  includedOneTimeServices?:
    | Array<ComCrmProductSelfServiceResourceListProductsIncludedOneTimeService>
    | undefined;
};

/**
 * OK
 */
export type ComCrmProductSelfServiceResourceListProductsResponse = {
  paging?: ComCrmProductSelfServiceResourceListProductsPaging | undefined;
  content?:
    | Array<ComCrmProductSelfServiceResourceListProductsContent>
    | undefined;
};

/** @internal */
export type ComCrmProductSelfServiceResourceListProductsSecurity$Outbound = {
  Secret_API_key?: string | undefined;
  authorization_self_service?: string | undefined;
};

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsSecurity$outboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsSecurity$Outbound,
    ComCrmProductSelfServiceResourceListProductsSecurity
  > = z.pipe(
    z.object({
      secretAPIKey: z.optional(z.string()),
      authorizationSelfService: z.optional(z.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        secretAPIKey: "Secret_API_key",
        authorizationSelfService: "authorization_self_service",
      });
    }),
  );

export function comCrmProductSelfServiceResourceListProductsSecurityToJSON(
  comCrmProductSelfServiceResourceListProductsSecurity:
    ComCrmProductSelfServiceResourceListProductsSecurity,
): string {
  return JSON.stringify(
    ComCrmProductSelfServiceResourceListProductsSecurity$outboundSchema.parse(
      comCrmProductSelfServiceResourceListProductsSecurity,
    ),
  );
}

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsOrder$outboundSchema:
  z.ZodMiniEnum<typeof ComCrmProductSelfServiceResourceListProductsOrder> = z
    .enum(ComCrmProductSelfServiceResourceListProductsOrder);

/** @internal */
export type ComCrmProductSelfServiceResourceListProductsRequest$Outbound = {
  billing_period?: number | undefined;
  billing_period_uot?: string | undefined;
  brand_id?: string | undefined;
  category_id?: string | undefined;
  category_id_exact?: string | undefined;
  characteristics?: string | undefined;
  classification?: string | undefined;
  composition?: string | undefined;
  country?: string | undefined;
  currency?: string | undefined;
  custom_fields?: string | undefined;
  family_id?: string | undefined;
  fulfilled_by?: string | undefined;
  include_characteristics?: boolean | undefined;
  include_custom_fields?: boolean | undefined;
  includes_one_time_services?: boolean | undefined;
  instance_model?: string | undefined;
  is_modifier?: boolean | undefined;
  name?: string | undefined;
  order_catalog_id?: string | undefined;
  order_category_id?: string | undefined;
  owned_by?: string | undefined;
  product_ids?: string | undefined;
  product_skus?: string | undefined;
  search_value?: string | undefined;
  supply_method?: string | undefined;
  type_id?: string | undefined;
  validity_date?: number | undefined;
  include_total: boolean;
  order: string;
  page: number;
  size: number;
  sort: string;
};

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsRequest$outboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsRequest$Outbound,
    ComCrmProductSelfServiceResourceListProductsRequest
  > = z.pipe(
    z.object({
      billingPeriod: z.optional(z.int()),
      billingPeriodUot: z.optional(z.string()),
      brandId: z.optional(z.string()),
      categoryId: z.optional(z.string()),
      categoryIdExact: z.optional(z.string()),
      characteristics: z.optional(z.string()),
      classification: z.optional(z.string()),
      composition: z.optional(z.string()),
      country: z.optional(z.string()),
      currency: z.optional(z.string()),
      customFields: z.optional(z.string()),
      familyId: z.optional(z.string()),
      fulfilledBy: z.optional(z.string()),
      includeCharacteristics: z.optional(z.boolean()),
      includeCustomFields: z.optional(z.boolean()),
      includesOneTimeServices: z.optional(z.boolean()),
      instanceModel: z.optional(z.string()),
      isModifier: z.optional(z.boolean()),
      name: z.optional(z.string()),
      orderCatalogId: z.optional(z.string()),
      orderCategoryId: z.optional(z.string()),
      ownedBy: z.optional(z.string()),
      productIds: z.optional(z.string()),
      productSkus: z.optional(z.string()),
      searchValue: z.optional(z.string()),
      supplyMethod: z.optional(z.string()),
      typeId: z.optional(z.string()),
      validityDate: z.optional(z.int()),
      includeTotal: z._default(z.boolean(), false),
      order: z._default(
        ComCrmProductSelfServiceResourceListProductsOrder$outboundSchema,
        "DESC",
      ),
      page: z._default(z.int(), 1),
      size: z._default(z.int(), 10),
      sort: z._default(z.string(), "CREATED_DATE"),
    }),
    z.transform((v) => {
      return remap$(v, {
        billingPeriod: "billing_period",
        billingPeriodUot: "billing_period_uot",
        brandId: "brand_id",
        categoryId: "category_id",
        categoryIdExact: "category_id_exact",
        customFields: "custom_fields",
        familyId: "family_id",
        fulfilledBy: "fulfilled_by",
        includeCharacteristics: "include_characteristics",
        includeCustomFields: "include_custom_fields",
        includesOneTimeServices: "includes_one_time_services",
        instanceModel: "instance_model",
        isModifier: "is_modifier",
        orderCatalogId: "order_catalog_id",
        orderCategoryId: "order_category_id",
        ownedBy: "owned_by",
        productIds: "product_ids",
        productSkus: "product_skus",
        searchValue: "search_value",
        supplyMethod: "supply_method",
        typeId: "type_id",
        validityDate: "validity_date",
        includeTotal: "include_total",
      });
    }),
  );

export function comCrmProductSelfServiceResourceListProductsRequestToJSON(
  comCrmProductSelfServiceResourceListProductsRequest:
    ComCrmProductSelfServiceResourceListProductsRequest,
): string {
  return JSON.stringify(
    ComCrmProductSelfServiceResourceListProductsRequest$outboundSchema.parse(
      comCrmProductSelfServiceResourceListProductsRequest,
    ),
  );
}

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsPaging$inboundSchema:
  z.ZodMiniType<ComCrmProductSelfServiceResourceListProductsPaging, unknown> = z
    .pipe(
      z.object({
        page: types.optional(types.number()),
        size: types.optional(types.number()),
        total: types.optional(types.number()),
        has_more: types.optional(types.boolean()),
      }),
      z.transform((v) => {
        return remap$(v, {
          "has_more": "hasMore",
        });
      }),
    );

export function comCrmProductSelfServiceResourceListProductsPagingFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmProductSelfServiceResourceListProductsPaging,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmProductSelfServiceResourceListProductsPaging$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmProductSelfServiceResourceListProductsPaging' from JSON`,
  );
}

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsClassification$inboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsClassification,
    unknown
  > = openEnums.inboundSchema(
    ComCrmProductSelfServiceResourceListProductsClassification,
  );

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsTypeComposition$inboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsTypeComposition,
    unknown
  > = openEnums.inboundSchema(
    ComCrmProductSelfServiceResourceListProductsTypeComposition,
  );

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsAvailability$inboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsAvailability,
    unknown
  > = openEnums.inboundSchema(
    ComCrmProductSelfServiceResourceListProductsAvailability,
  );

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsOwner$inboundSchema:
  z.ZodMiniType<ComCrmProductSelfServiceResourceListProductsOwner, unknown> = z
    .object({
      id: types.optional(types.string()),
      name: types.optional(types.string()),
    });

export function comCrmProductSelfServiceResourceListProductsOwnerFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmProductSelfServiceResourceListProductsOwner,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmProductSelfServiceResourceListProductsOwner$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmProductSelfServiceResourceListProductsOwner' from JSON`,
  );
}

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsInstanceModel$inboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsInstanceModel,
    unknown
  > = openEnums.inboundSchema(
    ComCrmProductSelfServiceResourceListProductsInstanceModel,
  );

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsCharacteristic$inboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsCharacteristic,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    key: types.optional(types.string()),
    value: types.optional(types.string()),
    label: types.optional(types.string()),
    mandatory: types.optional(types.boolean()),
  });

export function comCrmProductSelfServiceResourceListProductsCharacteristicFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmProductSelfServiceResourceListProductsCharacteristic,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmProductSelfServiceResourceListProductsCharacteristic$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmProductSelfServiceResourceListProductsCharacteristic' from JSON`,
  );
}

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsCurrencyCode$inboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsCurrencyCode,
    unknown
  > = openEnums.inboundSchema(
    ComCrmProductSelfServiceResourceListProductsCurrencyCode,
  );

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsTaxModel$inboundSchema:
  z.ZodMiniType<ComCrmProductSelfServiceResourceListProductsTaxModel, unknown> =
    openEnums.inboundSchema(
      ComCrmProductSelfServiceResourceListProductsTaxModel,
    );

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsPriceModel$inboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsPriceModel,
    unknown
  > = openEnums.inboundSchema(
    ComCrmProductSelfServiceResourceListProductsPriceModel,
  );

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsSupplyMethod$inboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsSupplyMethod,
    unknown
  > = openEnums.inboundSchema(
    ComCrmProductSelfServiceResourceListProductsSupplyMethod,
  );

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsSalesModel$inboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsSalesModel,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
  });

export function comCrmProductSelfServiceResourceListProductsSalesModelFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmProductSelfServiceResourceListProductsSalesModel,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmProductSelfServiceResourceListProductsSalesModel$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmProductSelfServiceResourceListProductsSalesModel' from JSON`,
  );
}

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsOrderQueue$inboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsOrderQueue,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
  });

export function comCrmProductSelfServiceResourceListProductsOrderQueueFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmProductSelfServiceResourceListProductsOrderQueue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmProductSelfServiceResourceListProductsOrderQueue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmProductSelfServiceResourceListProductsOrderQueue' from JSON`,
  );
}

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsBillingPeriodUot$inboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsBillingPeriodUot,
    unknown
  > = openEnums.inboundSchema(
    ComCrmProductSelfServiceResourceListProductsBillingPeriodUot,
  );

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsBillingPeriod$inboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsBillingPeriod,
    unknown
  > = z.object({
    duration: types.optional(types.number()),
    uot: types.optional(
      ComCrmProductSelfServiceResourceListProductsBillingPeriodUot$inboundSchema,
    ),
  });

export function comCrmProductSelfServiceResourceListProductsBillingPeriodFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmProductSelfServiceResourceListProductsBillingPeriod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmProductSelfServiceResourceListProductsBillingPeriod$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmProductSelfServiceResourceListProductsBillingPeriod' from JSON`,
  );
}

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsTrialPeriodUot$inboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsTrialPeriodUot,
    unknown
  > = openEnums.inboundSchema(
    ComCrmProductSelfServiceResourceListProductsTrialPeriodUot,
  );

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsTrialPeriod$inboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsTrialPeriod,
    unknown
  > = z.object({
    duration: types.optional(types.number()),
    uot: types.optional(
      ComCrmProductSelfServiceResourceListProductsTrialPeriodUot$inboundSchema,
    ),
  });

export function comCrmProductSelfServiceResourceListProductsTrialPeriodFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmProductSelfServiceResourceListProductsTrialPeriod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmProductSelfServiceResourceListProductsTrialPeriod$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmProductSelfServiceResourceListProductsTrialPeriod' from JSON`,
  );
}

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsAccessPeriod$inboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsAccessPeriod,
    unknown
  > = z.pipe(
    z.object({
      start_date: types.optional(types.number()),
      end_date: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "start_date": "startDate",
        "end_date": "endDate",
      });
    }),
  );

export function comCrmProductSelfServiceResourceListProductsAccessPeriodFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmProductSelfServiceResourceListProductsAccessPeriod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmProductSelfServiceResourceListProductsAccessPeriod$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmProductSelfServiceResourceListProductsAccessPeriod' from JSON`,
  );
}

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsBillingModel$inboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsBillingModel,
    unknown
  > = openEnums.inboundSchema(
    ComCrmProductSelfServiceResourceListProductsBillingModel,
  );

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsContractPeriodUot$inboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsContractPeriodUot,
    unknown
  > = openEnums.inboundSchema(
    ComCrmProductSelfServiceResourceListProductsContractPeriodUot,
  );

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsContractPeriod$inboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsContractPeriod,
    unknown
  > = z.object({
    duration: types.optional(types.number()),
    uot: types.optional(
      ComCrmProductSelfServiceResourceListProductsContractPeriodUot$inboundSchema,
    ),
  });

export function comCrmProductSelfServiceResourceListProductsContractPeriodFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmProductSelfServiceResourceListProductsContractPeriod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmProductSelfServiceResourceListProductsContractPeriod$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmProductSelfServiceResourceListProductsContractPeriod' from JSON`,
  );
}

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsRentalService$inboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsRentalService,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    sku: types.optional(types.string()),
  });

export function comCrmProductSelfServiceResourceListProductsRentalServiceFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmProductSelfServiceResourceListProductsRentalService,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmProductSelfServiceResourceListProductsRentalService$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmProductSelfServiceResourceListProductsRentalService' from JSON`,
  );
}

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsValueType$inboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsValueType,
    unknown
  > = openEnums.inboundSchema(
    ComCrmProductSelfServiceResourceListProductsValueType,
  );

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsPriceTerms$inboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsPriceTerms,
    unknown
  > = z.pipe(
    z.object({
      billing_period: types.optional(z.lazy(() =>
        ComCrmProductSelfServiceResourceListProductsBillingPeriod$inboundSchema
      )),
      trial_period: types.optional(z.lazy(() =>
        ComCrmProductSelfServiceResourceListProductsTrialPeriod$inboundSchema
      )),
      access_period: types.optional(z.lazy(() =>
        ComCrmProductSelfServiceResourceListProductsAccessPeriod$inboundSchema
      )),
      auto_renewed: types.optional(types.boolean()),
      billing_model: types.optional(
        ComCrmProductSelfServiceResourceListProductsBillingModel$inboundSchema,
      ),
      contract_period: types.optional(z.lazy(() =>
        ComCrmProductSelfServiceResourceListProductsContractPeriod$inboundSchema
      )),
      terms_billing_cycles: types.optional(types.number()),
      rental_service: types.optional(z.lazy(() =>
        ComCrmProductSelfServiceResourceListProductsRentalService$inboundSchema
      )),
      value_type: types.optional(
        ComCrmProductSelfServiceResourceListProductsValueType$inboundSchema,
      ),
    }),
    z.transform((v) => {
      return remap$(v, {
        "billing_period": "billingPeriod",
        "trial_period": "trialPeriod",
        "access_period": "accessPeriod",
        "auto_renewed": "autoRenewed",
        "billing_model": "billingModel",
        "contract_period": "contractPeriod",
        "terms_billing_cycles": "termsBillingCycles",
        "rental_service": "rentalService",
        "value_type": "valueType",
      });
    }),
  );

export function comCrmProductSelfServiceResourceListProductsPriceTermsFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmProductSelfServiceResourceListProductsPriceTerms,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmProductSelfServiceResourceListProductsPriceTerms$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmProductSelfServiceResourceListProductsPriceTerms' from JSON`,
  );
}

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsTier$inboundSchema:
  z.ZodMiniType<ComCrmProductSelfServiceResourceListProductsTier, unknown> = z
    .pipe(
      z.object({
        id: types.optional(types.string()),
        lower_tier: types.optional(types.number()),
        upper_tier: types.optional(types.number()),
        price: types.optional(types.number()),
        out_of_contract: types.optional(types.number()),
      }),
      z.transform((v) => {
        return remap$(v, {
          "lower_tier": "lowerTier",
          "upper_tier": "upperTier",
          "out_of_contract": "outOfContract",
        });
      }),
    );

export function comCrmProductSelfServiceResourceListProductsTierFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmProductSelfServiceResourceListProductsTier,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmProductSelfServiceResourceListProductsTier$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmProductSelfServiceResourceListProductsTier' from JSON`,
  );
}

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsPricing$inboundSchema:
  z.ZodMiniType<ComCrmProductSelfServiceResourceListProductsPricing, unknown> =
    z.pipe(
      z.object({
        id: types.optional(types.string()),
        price: types.optional(types.number()),
        label: types.optional(types.string()),
        currency_code: types.optional(
          ComCrmProductSelfServiceResourceListProductsCurrencyCode$inboundSchema,
        ),
        is_default: types.optional(types.boolean()),
        tax_model: types.optional(
          ComCrmProductSelfServiceResourceListProductsTaxModel$inboundSchema,
        ),
        price_model: types.optional(
          ComCrmProductSelfServiceResourceListProductsPriceModel$inboundSchema,
        ),
        supply_method: types.optional(
          ComCrmProductSelfServiceResourceListProductsSupplyMethod$inboundSchema,
        ),
        sales_model: types.optional(z.lazy(() =>
          ComCrmProductSelfServiceResourceListProductsSalesModel$inboundSchema
        )),
        order_queue: types.optional(z.lazy(() =>
          ComCrmProductSelfServiceResourceListProductsOrderQueue$inboundSchema
        )),
        price_terms: types.optional(z.lazy(() =>
          ComCrmProductSelfServiceResourceListProductsPriceTerms$inboundSchema
        )),
        tiers: types.optional(z.array(z.lazy(() =>
          ComCrmProductSelfServiceResourceListProductsTier$inboundSchema
        ))),
      }),
      z.transform((v) => {
        return remap$(v, {
          "currency_code": "currencyCode",
          "is_default": "isDefault",
          "tax_model": "taxModel",
          "price_model": "priceModel",
          "supply_method": "supplyMethod",
          "sales_model": "salesModel",
          "order_queue": "orderQueue",
          "price_terms": "priceTerms",
        });
      }),
    );

export function comCrmProductSelfServiceResourceListProductsPricingFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmProductSelfServiceResourceListProductsPricing,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmProductSelfServiceResourceListProductsPricing$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmProductSelfServiceResourceListProductsPricing' from JSON`,
  );
}

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsUsageType$inboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsUsageType,
    unknown
  > = openEnums.inboundSchema(
    ComCrmProductSelfServiceResourceListProductsUsageType,
  );

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsMedia$inboundSchema:
  z.ZodMiniType<ComCrmProductSelfServiceResourceListProductsMedia, unknown> = z
    .object({
      width: types.optional(types.number()),
      height: types.optional(types.number()),
      url: types.optional(types.string()),
    });

export function comCrmProductSelfServiceResourceListProductsMediaFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmProductSelfServiceResourceListProductsMedia,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmProductSelfServiceResourceListProductsMedia$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmProductSelfServiceResourceListProductsMedia' from JSON`,
  );
}

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsCreative$inboundSchema:
  z.ZodMiniType<ComCrmProductSelfServiceResourceListProductsCreative, unknown> =
    z.pipe(
      z.object({
        id: types.optional(types.string()),
        media_group_id: types.optional(types.string()),
        usage_type: types.optional(
          ComCrmProductSelfServiceResourceListProductsUsageType$inboundSchema,
        ),
        width: types.optional(types.number()),
        height: types.optional(types.number()),
        format: types.optional(types.string()),
        url: types.optional(types.string()),
        public_id: types.optional(types.string()),
        media_id: types.optional(types.string()),
        caption: types.optional(types.string()),
        sort_order: types.optional(types.number()),
        media: types.optional(z.array(z.lazy(() =>
          ComCrmProductSelfServiceResourceListProductsMedia$inboundSchema
        ))),
      }),
      z.transform((v) => {
        return remap$(v, {
          "media_group_id": "mediaGroupId",
          "usage_type": "usageType",
          "public_id": "publicId",
          "media_id": "mediaId",
          "sort_order": "sortOrder",
        });
      }),
    );

export function comCrmProductSelfServiceResourceListProductsCreativeFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmProductSelfServiceResourceListProductsCreative,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmProductSelfServiceResourceListProductsCreative$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmProductSelfServiceResourceListProductsCreative' from JSON`,
  );
}

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsCustomField$inboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsCustomField,
    unknown
  > = z.object({
    key: types.optional(types.string()),
    value: types.optional(types.string()),
  });

export function comCrmProductSelfServiceResourceListProductsCustomFieldFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmProductSelfServiceResourceListProductsCustomField,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmProductSelfServiceResourceListProductsCustomField$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmProductSelfServiceResourceListProductsCustomField' from JSON`,
  );
}

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsIncludedOneTimeService$inboundSchema:
  z.ZodMiniType<
    ComCrmProductSelfServiceResourceListProductsIncludedOneTimeService,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    sku: types.optional(types.string()),
  });

export function comCrmProductSelfServiceResourceListProductsIncludedOneTimeServiceFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmProductSelfServiceResourceListProductsIncludedOneTimeService,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmProductSelfServiceResourceListProductsIncludedOneTimeService$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmProductSelfServiceResourceListProductsIncludedOneTimeService' from JSON`,
  );
}

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsContent$inboundSchema:
  z.ZodMiniType<ComCrmProductSelfServiceResourceListProductsContent, unknown> =
    z.pipe(
      z.object({
        id: types.optional(types.string()),
        sku: types.optional(types.string()),
        name: types.optional(types.string()),
        description: types.optional(types.string()),
        classification: types.optional(
          ComCrmProductSelfServiceResourceListProductsClassification$inboundSchema,
        ),
        type_composition: types.optional(
          ComCrmProductSelfServiceResourceListProductsTypeComposition$inboundSchema,
        ),
        components: types.optional(types.number()),
        variants: types.optional(types.number()),
        number_of_characteristics: types.optional(types.number()),
        number_of_prices: types.optional(types.number()),
        availability: types.optional(
          ComCrmProductSelfServiceResourceListProductsAvailability$inboundSchema,
        ),
        owner: types.optional(z.lazy(() =>
          ComCrmProductSelfServiceResourceListProductsOwner$inboundSchema
        )),
        is_modifier: types.optional(types.boolean()),
        negative_balance_allowed: types.optional(types.boolean()),
        is_provisionable: types.optional(types.boolean()),
        is_stockable: types.optional(types.boolean()),
        instance_model: types.optional(
          ComCrmProductSelfServiceResourceListProductsInstanceModel$inboundSchema,
        ),
        characteristics: types.optional(z.array(z.lazy(() =>
          ComCrmProductSelfServiceResourceListProductsCharacteristic$inboundSchema
        ))),
        pricing: types.optional(z.array(z.lazy(() =>
          ComCrmProductSelfServiceResourceListProductsPricing$inboundSchema
        ))),
        creatives: types.optional(z.array(z.lazy(() =>
          ComCrmProductSelfServiceResourceListProductsCreative$inboundSchema
        ))),
        custom_fields: z.optional(z.nullable(z.array(z.lazy(() =>
          ComCrmProductSelfServiceResourceListProductsCustomField$inboundSchema
        )))),
        included_one_time_services: types.optional(z.array(z.lazy(() =>
          ComCrmProductSelfServiceResourceListProductsIncludedOneTimeService$inboundSchema
        ))),
      }),
      z.transform((v) => {
        return remap$(v, {
          "type_composition": "typeComposition",
          "number_of_characteristics": "numberOfCharacteristics",
          "number_of_prices": "numberOfPrices",
          "is_modifier": "isModifier",
          "negative_balance_allowed": "negativeBalanceAllowed",
          "is_provisionable": "isProvisionable",
          "is_stockable": "isStockable",
          "instance_model": "instanceModel",
          "custom_fields": "customFields",
          "included_one_time_services": "includedOneTimeServices",
        });
      }),
    );

export function comCrmProductSelfServiceResourceListProductsContentFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmProductSelfServiceResourceListProductsContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmProductSelfServiceResourceListProductsContent$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmProductSelfServiceResourceListProductsContent' from JSON`,
  );
}

/** @internal */
export const ComCrmProductSelfServiceResourceListProductsResponse$inboundSchema:
  z.ZodMiniType<ComCrmProductSelfServiceResourceListProductsResponse, unknown> =
    z.object({
      paging: types.optional(
        z.lazy(() =>
          ComCrmProductSelfServiceResourceListProductsPaging$inboundSchema
        ),
      ),
      content: types.optional(
        z.array(z.lazy(() =>
          ComCrmProductSelfServiceResourceListProductsContent$inboundSchema
        )),
      ),
    });

export function comCrmProductSelfServiceResourceListProductsResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmProductSelfServiceResourceListProductsResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmProductSelfServiceResourceListProductsResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmProductSelfServiceResourceListProductsResponse' from JSON`,
  );
}
