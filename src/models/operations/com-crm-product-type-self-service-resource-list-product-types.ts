/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 * @generated-id: 3e8f5ae900d8
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

/**
 * Defines how the results will be ordered
 */
export const ComCrmProductTypeSelfServiceResourceListProductTypesOrder = {
  Asc: "ASC",
  Desc: "DESC",
} as const;
/**
 * Defines how the results will be ordered
 */
export type ComCrmProductTypeSelfServiceResourceListProductTypesOrder =
  ClosedEnum<typeof ComCrmProductTypeSelfServiceResourceListProductTypesOrder>;

export type ComCrmProductTypeSelfServiceResourceListProductTypesRequest = {
  classifications?: string | undefined;
  /**
   * Search for product types based on their Name, Display Name or Description
   */
  searchValue?: string | undefined;
  /**
   * Determine if a "total" will be returned in paging reference. If set to True, then "total" is also returned but it will return up to 10K value. If set to False, then the "total" in paging is null.
   */
  includeTotal?: boolean | undefined;
  /**
   * Defines how the results will be ordered
   */
  order?: ComCrmProductTypeSelfServiceResourceListProductTypesOrder | undefined;
  /**
   * The page number that should be retrieved
   */
  page?: number | undefined;
  /**
   * The size (total records) of each page
   */
  size?: number | undefined;
  /**
   * Defines on which attribute the results should be sorted
   */
  sort?: string | undefined;
};

export type ComCrmProductTypeSelfServiceResourceListProductTypesPaging = {
  /**
   * The page number
   */
  page?: number | undefined;
  /**
   * The number of records per page
   */
  size?: number | undefined;
  /**
   * The total number of records. If "include_total" is not specified, then this total is null. If "include_total" is specified, total has a value but it is accurate up to 10K records.
   */
  total?: number | undefined;
  /**
   * Shows if there are more records available to fetch
   */
  hasMore?: boolean | undefined;
};

/**
 * Product Classification
 */
export const ComCrmProductTypeSelfServiceResourceListProductTypesClassification =
  {
    TermedService: "TERMED_SERVICE",
    UsageService: "USAGE_SERVICE",
    OneTimeService: "ONE_TIME_SERVICE",
    TraceablePhysicalGood: "TRACEABLE_PHYSICAL_GOOD",
    NonTraceablePhysicalGood: "NON_TRACEABLE_PHYSICAL_GOOD",
    ExpensesService: "EXPENSES_SERVICE",
  } as const;
/**
 * Product Classification
 */
export type ComCrmProductTypeSelfServiceResourceListProductTypesClassification =
  OpenEnum<
    typeof ComCrmProductTypeSelfServiceResourceListProductTypesClassification
  >;

/**
 * Product Composition
 */
export const CompositionMethod = {
  Flat: "FLAT",
  FlexibleBundle: "FLEXIBLE_BUNDLE",
  FixedBundle: "FIXED_BUNDLE",
  Composite: "COMPOSITE",
} as const;
/**
 * Product Composition
 */
export type CompositionMethod = OpenEnum<typeof CompositionMethod>;

/**
 * Product type tax category
 */
export type TaxCategory = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
  /**
   * The entity code
   */
  code?: string | undefined;
};

/**
 * Details about the organisation. Valid only in B2B connect scennarios
 */
export type ComCrmProductTypeSelfServiceResourceListProductTypesOwner = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
};

export type ComCrmProductTypeSelfServiceResourceListProductTypesContent = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The name of the product type
   */
  name?: string | undefined;
  /**
   * The display name of the product type
   */
  displayName?: string | undefined;
  /**
   * Product type description
   */
  description?: string | undefined;
  /**
   * Product Classification
   */
  classification?:
    | ComCrmProductTypeSelfServiceResourceListProductTypesClassification
    | undefined;
  /**
   * Product Composition
   */
  compositionMethod?: CompositionMethod | undefined;
  /**
   * Product type tax category
   */
  taxCategory?: TaxCategory | undefined;
  /**
   * Defines whether products of classification TRACEABLE_PHYSICAL_GOOD or NON_TRACEABLE_PHYSICAL_GOOD are stockable or not
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  isStockable?: boolean | undefined;
  /**
   * Defines if stockable phsical goods balance can go below 0 in the warehouse
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  negativeBalanceAllowed?: boolean | undefined;
  /**
   * Defines whether product of this type are provisionable or not. Applicable for classifications: TRACEABLE_PHYSICAL_GOOD (flat and fixed bundle), TERMED_SERVICE (flat and fixed bundle) and ONE_TIME_SERVICE (flat)
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  isProvisionable?: boolean | undefined;
  /**
   * Defines whether products of classification TRACEABLE_PHYSICAL_GOOD or NON_TRACEABLE_PHYSICAL_GOOD are modifiers of products or not
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  isModifier?: boolean | undefined;
  /**
   * Details about the organisation. Valid only in B2B connect scennarios
   */
  owner?: ComCrmProductTypeSelfServiceResourceListProductTypesOwner | undefined;
  /**
   * Number of characteristics set for this product type
   */
  characteristics?: number | undefined;
};

/**
 * OK
 */
export type ComCrmProductTypeSelfServiceResourceListProductTypesResponse = {
  paging?:
    | ComCrmProductTypeSelfServiceResourceListProductTypesPaging
    | undefined;
  content?:
    | Array<ComCrmProductTypeSelfServiceResourceListProductTypesContent>
    | undefined;
};

/** @internal */
export const ComCrmProductTypeSelfServiceResourceListProductTypesOrder$outboundSchema:
  z.ZodMiniEnum<
    typeof ComCrmProductTypeSelfServiceResourceListProductTypesOrder
  > = z.enum(ComCrmProductTypeSelfServiceResourceListProductTypesOrder);

/** @internal */
export type ComCrmProductTypeSelfServiceResourceListProductTypesRequest$Outbound =
  {
    classifications?: string | undefined;
    search_value?: string | undefined;
    include_total: boolean;
    order: string;
    page: number;
    size: number;
    sort: string;
  };

/** @internal */
export const ComCrmProductTypeSelfServiceResourceListProductTypesRequest$outboundSchema:
  z.ZodMiniType<
    ComCrmProductTypeSelfServiceResourceListProductTypesRequest$Outbound,
    ComCrmProductTypeSelfServiceResourceListProductTypesRequest
  > = z.pipe(
    z.object({
      classifications: z.optional(z.string()),
      searchValue: z.optional(z.string()),
      includeTotal: z._default(z.boolean(), false),
      order: z._default(
        ComCrmProductTypeSelfServiceResourceListProductTypesOrder$outboundSchema,
        "DESC",
      ),
      page: z._default(z.int(), 1),
      size: z._default(z.int(), 10),
      sort: z._default(z.string(), "CREATED_DATE"),
    }),
    z.transform((v) => {
      return remap$(v, {
        searchValue: "search_value",
        includeTotal: "include_total",
      });
    }),
  );

export function comCrmProductTypeSelfServiceResourceListProductTypesRequestToJSON(
  comCrmProductTypeSelfServiceResourceListProductTypesRequest:
    ComCrmProductTypeSelfServiceResourceListProductTypesRequest,
): string {
  return JSON.stringify(
    ComCrmProductTypeSelfServiceResourceListProductTypesRequest$outboundSchema
      .parse(comCrmProductTypeSelfServiceResourceListProductTypesRequest),
  );
}

/** @internal */
export const ComCrmProductTypeSelfServiceResourceListProductTypesPaging$inboundSchema:
  z.ZodMiniType<
    ComCrmProductTypeSelfServiceResourceListProductTypesPaging,
    unknown
  > = z.pipe(
    z.object({
      page: types.optional(types.number()),
      size: types.optional(types.number()),
      total: types.optional(types.number()),
      has_more: types.optional(types.boolean()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "has_more": "hasMore",
      });
    }),
  );

export function comCrmProductTypeSelfServiceResourceListProductTypesPagingFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmProductTypeSelfServiceResourceListProductTypesPaging,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmProductTypeSelfServiceResourceListProductTypesPaging$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmProductTypeSelfServiceResourceListProductTypesPaging' from JSON`,
  );
}

/** @internal */
export const ComCrmProductTypeSelfServiceResourceListProductTypesClassification$inboundSchema:
  z.ZodMiniType<
    ComCrmProductTypeSelfServiceResourceListProductTypesClassification,
    unknown
  > = openEnums.inboundSchema(
    ComCrmProductTypeSelfServiceResourceListProductTypesClassification,
  );

/** @internal */
export const CompositionMethod$inboundSchema: z.ZodMiniType<
  CompositionMethod,
  unknown
> = openEnums.inboundSchema(CompositionMethod);

/** @internal */
export const TaxCategory$inboundSchema: z.ZodMiniType<TaxCategory, unknown> = z
  .object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    code: types.optional(types.string()),
  });

export function taxCategoryFromJSON(
  jsonString: string,
): SafeParseResult<TaxCategory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TaxCategory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TaxCategory' from JSON`,
  );
}

/** @internal */
export const ComCrmProductTypeSelfServiceResourceListProductTypesOwner$inboundSchema:
  z.ZodMiniType<
    ComCrmProductTypeSelfServiceResourceListProductTypesOwner,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
  });

export function comCrmProductTypeSelfServiceResourceListProductTypesOwnerFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmProductTypeSelfServiceResourceListProductTypesOwner,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmProductTypeSelfServiceResourceListProductTypesOwner$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmProductTypeSelfServiceResourceListProductTypesOwner' from JSON`,
  );
}

/** @internal */
export const ComCrmProductTypeSelfServiceResourceListProductTypesContent$inboundSchema:
  z.ZodMiniType<
    ComCrmProductTypeSelfServiceResourceListProductTypesContent,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      name: types.optional(types.string()),
      display_name: types.optional(types.string()),
      description: types.optional(types.string()),
      classification: types.optional(
        ComCrmProductTypeSelfServiceResourceListProductTypesClassification$inboundSchema,
      ),
      composition_method: types.optional(CompositionMethod$inboundSchema),
      tax_category: types.optional(z.lazy(() => TaxCategory$inboundSchema)),
      is_stockable: types.optional(types.boolean()),
      negative_balance_allowed: types.optional(types.boolean()),
      is_provisionable: types.optional(types.boolean()),
      is_modifier: types.optional(types.boolean()),
      owner: types.optional(z.lazy(() =>
        ComCrmProductTypeSelfServiceResourceListProductTypesOwner$inboundSchema
      )),
      characteristics: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "display_name": "displayName",
        "composition_method": "compositionMethod",
        "tax_category": "taxCategory",
        "is_stockable": "isStockable",
        "negative_balance_allowed": "negativeBalanceAllowed",
        "is_provisionable": "isProvisionable",
        "is_modifier": "isModifier",
      });
    }),
  );

export function comCrmProductTypeSelfServiceResourceListProductTypesContentFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmProductTypeSelfServiceResourceListProductTypesContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmProductTypeSelfServiceResourceListProductTypesContent$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmProductTypeSelfServiceResourceListProductTypesContent' from JSON`,
  );
}

/** @internal */
export const ComCrmProductTypeSelfServiceResourceListProductTypesResponse$inboundSchema:
  z.ZodMiniType<
    ComCrmProductTypeSelfServiceResourceListProductTypesResponse,
    unknown
  > = z.object({
    paging: types.optional(
      z.lazy(() =>
        ComCrmProductTypeSelfServiceResourceListProductTypesPaging$inboundSchema
      ),
    ),
    content: types.optional(
      z.array(z.lazy(() =>
        ComCrmProductTypeSelfServiceResourceListProductTypesContent$inboundSchema
      )),
    ),
  });

export function comCrmProductTypeSelfServiceResourceListProductTypesResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmProductTypeSelfServiceResourceListProductTypesResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmProductTypeSelfServiceResourceListProductTypesResponse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmProductTypeSelfServiceResourceListProductTypesResponse' from JSON`,
  );
}
