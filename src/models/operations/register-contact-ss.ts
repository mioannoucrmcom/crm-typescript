/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 * @generated-id: 1ddf940b73f0
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

/**
 * The contact’s identity provider
 */
export const RegisterContactSSProvider = {
  Email: "EMAIL",
  Phone: "PHONE",
  Facebook: "FACEBOOK",
  Apple: "APPLE",
  Google: "GOOGLE",
  MacAddress: "MAC_ADDRESS",
  OidcOauth: "OIDC_OAUTH",
} as const;
/**
 * The contact’s identity provider
 */
export type RegisterContactSSProvider = ClosedEnum<
  typeof RegisterContactSSProvider
>;

/**
 * The phone country code
 */
export const RegisterContactSSCountryCode = {
  Abw: "ABW",
  Afg: "AFG",
  Ago: "AGO",
  Aia: "AIA",
  Ala: "ALA",
  Alb: "ALB",
  And: "AND",
  Ant: "ANT",
  Are: "ARE",
  Arg: "ARG",
  Arm: "ARM",
  Asm: "ASM",
  Ata: "ATA",
  Atf: "ATF",
  Atg: "ATG",
  Aus: "AUS",
  Aut: "AUT",
  Aze: "AZE",
  Bdi: "BDI",
  Bel: "BEL",
  Ben: "BEN",
  Bes: "BES",
  Bfa: "BFA",
  Bgd: "BGD",
  Bgr: "BGR",
  Bhr: "BHR",
  Bhs: "BHS",
  Bih: "BIH",
  Blm: "BLM",
  Blr: "BLR",
  Blz: "BLZ",
  Bmu: "BMU",
  Bol: "BOL",
  Bra: "BRA",
  Brb: "BRB",
  Brn: "BRN",
  Btn: "BTN",
  Bvt: "BVT",
  Bwa: "BWA",
  Caf: "CAF",
  Can: "CAN",
  Cck: "CCK",
  Che: "CHE",
  Chl: "CHL",
  Chn: "CHN",
  Civ: "CIV",
  Cmr: "CMR",
  Cod: "COD",
  Cog: "COG",
  Cok: "COK",
  Col: "COL",
  Com: "COM",
  Cpv: "CPV",
  Cri: "CRI",
  Cub: "CUB",
  Cuw: "CUW",
  Cxr: "CXR",
  Cym: "CYM",
  Cyp: "CYP",
  Cze: "CZE",
  Deu: "DEU",
  Dji: "DJI",
  Dma: "DMA",
  Dnk: "DNK",
  Dom: "DOM",
  Dza: "DZA",
  Ecu: "ECU",
  Egy: "EGY",
  Eri: "ERI",
  Esh: "ESH",
  Esp: "ESP",
  Est: "EST",
  Eth: "ETH",
  Fin: "FIN",
  Fji: "FJI",
  Flk: "FLK",
  Fra: "FRA",
  Fro: "FRO",
  Fsm: "FSM",
  Gab: "GAB",
  Gbr: "GBR",
  Geo: "GEO",
  Ggy: "GGY",
  Gha: "GHA",
  Gib: "GIB",
  Gin: "GIN",
  Glp: "GLP",
  Gmb: "GMB",
  Gnb: "GNB",
  Gnq: "GNQ",
  Grc: "GRC",
  Grd: "GRD",
  Grl: "GRL",
  Gtm: "GTM",
  Guf: "GUF",
  Gum: "GUM",
  Guy: "GUY",
  Hkg: "HKG",
  Hmd: "HMD",
  Hnd: "HND",
  Hrv: "HRV",
  Hti: "HTI",
  Hun: "HUN",
  Idn: "IDN",
  Imn: "IMN",
  Ind: "IND",
  Iot: "IOT",
  Irl: "IRL",
  Irn: "IRN",
  Irq: "IRQ",
  Isl: "ISL",
  Isr: "ISR",
  Ita: "ITA",
  Jam: "JAM",
  Jey: "JEY",
  Jor: "JOR",
  Jpn: "JPN",
  Kaz: "KAZ",
  Ken: "KEN",
  Kgz: "KGZ",
  Khm: "KHM",
  Kir: "KIR",
  Kna: "KNA",
  Kor: "KOR",
  Kwt: "KWT",
  Lao: "LAO",
  Lbn: "LBN",
  Lbr: "LBR",
  Lby: "LBY",
  Lca: "LCA",
  Lie: "LIE",
  Lka: "LKA",
  Lso: "LSO",
  Ltu: "LTU",
  Lux: "LUX",
  Lva: "LVA",
  Mac: "MAC",
  Maf: "MAF",
  Mar: "MAR",
  Mco: "MCO",
  Mda: "MDA",
  Mdg: "MDG",
  Mdv: "MDV",
  Mex: "MEX",
  Mhl: "MHL",
  Mkd: "MKD",
  Mli: "MLI",
  Mlt: "MLT",
  Mmr: "MMR",
  Mne: "MNE",
  Mng: "MNG",
  Mnp: "MNP",
  Moz: "MOZ",
  Mrt: "MRT",
  Msr: "MSR",
  Mtq: "MTQ",
  Mus: "MUS",
  Mwi: "MWI",
  Mys: "MYS",
  Myt: "MYT",
  Nam: "NAM",
  Ncl: "NCL",
  Ner: "NER",
  Nfk: "NFK",
  Nga: "NGA",
  Nic: "NIC",
  Niu: "NIU",
  Nld: "NLD",
  Nor: "NOR",
  Npl: "NPL",
  Nru: "NRU",
  Nzl: "NZL",
  Omn: "OMN",
  Pak: "PAK",
  Pan: "PAN",
  Pcn: "PCN",
  Per: "PER",
  Phl: "PHL",
  Plw: "PLW",
  Png: "PNG",
  Pol: "POL",
  Pri: "PRI",
  Prk: "PRK",
  Prt: "PRT",
  Pry: "PRY",
  Pse: "PSE",
  Pyf: "PYF",
  Qat: "QAT",
  Reu: "REU",
  Rks: "RKS",
  Rou: "ROU",
  Rus: "RUS",
  Rwa: "RWA",
  Sau: "SAU",
  Sdn: "SDN",
  Sen: "SEN",
  Sgp: "SGP",
  Sgs: "SGS",
  Shn: "SHN",
  Sjm: "SJM",
  Slb: "SLB",
  Sle: "SLE",
  Slv: "SLV",
  Smr: "SMR",
  Som: "SOM",
  Spm: "SPM",
  Srb: "SRB",
  Ssd: "SSD",
  Stp: "STP",
  Sur: "SUR",
  Svk: "SVK",
  Svn: "SVN",
  Swe: "SWE",
  Swz: "SWZ",
  Sxm: "SXM",
  Syc: "SYC",
  Syr: "SYR",
  Tca: "TCA",
  Tcd: "TCD",
  Tgo: "TGO",
  Tha: "THA",
  Tjk: "TJK",
  Tkl: "TKL",
  Tkm: "TKM",
  Tls: "TLS",
  Ton: "TON",
  Tto: "TTO",
  Tun: "TUN",
  Tur: "TUR",
  Tuv: "TUV",
  Twn: "TWN",
  Tza: "TZA",
  Uga: "UGA",
  Ukr: "UKR",
  Umi: "UMI",
  Ury: "URY",
  Usa: "USA",
  Uzb: "UZB",
  Vat: "VAT",
  Vct: "VCT",
  Ven: "VEN",
  Vgb: "VGB",
  Vir: "VIR",
  Vnm: "VNM",
  Vut: "VUT",
  Wlf: "WLF",
  Wsm: "WSM",
  Yem: "YEM",
  Zaf: "ZAF",
  Zmb: "ZMB",
  Zwe: "ZWE",
} as const;
/**
 * The phone country code
 */
export type RegisterContactSSCountryCode = ClosedEnum<
  typeof RegisterContactSSCountryCode
>;

/**
 * The contact’s phone (required for phone/password or phone/OTP verification). Password is applicable only when authentication is phone/otp.
 */
export type RegisterContactSSPhone = {
  /**
   * The phone number
   */
  number: string;
  /**
   * The phone country code
   */
  countryCode: RegisterContactSSCountryCode;
};

/**
 * Details about how the contact will be identified based on app/portal configuration
 */
export type Identification = {
  /**
   * The contact’s identity provider
   */
  provider?: RegisterContactSSProvider | undefined;
  /**
   * The contact’s email (required for email/password or email/OTP verification). Password is applicable only when authentication is email/otp.
   */
  email: string | null;
  /**
   * The contact’s password (required if authentication method is email/password)
   */
  password?: string | null | undefined;
  /**
   * The contact’s phone (required for phone/password or phone/OTP verification). Password is applicable only when authentication is phone/otp.
   */
  phone?: RegisterContactSSPhone | null | undefined;
  /**
   * The external provider's application id (applicable if using Facebook credentials)
   */
  applicationId?: string | null | undefined;
  /**
   * The access token returned from the OAuth service provider (required for Facebook and Google registration)
   */
  token?: string | null | undefined;
  /**
   * The contact’s sub
   */
  sub?: string | undefined;
};

/**
 * 3-char country code of the contact based on locale, this will be used to determine pricing and taxes
 */
export const RegisterContactSSCountryOfAgreement = {
  Abw: "ABW",
  Afg: "AFG",
  Ago: "AGO",
  Aia: "AIA",
  Ala: "ALA",
  Alb: "ALB",
  And: "AND",
  Ant: "ANT",
  Are: "ARE",
  Arg: "ARG",
  Arm: "ARM",
  Asm: "ASM",
  Ata: "ATA",
  Atf: "ATF",
  Atg: "ATG",
  Aus: "AUS",
  Aut: "AUT",
  Aze: "AZE",
  Bdi: "BDI",
  Bel: "BEL",
  Ben: "BEN",
  Bes: "BES",
  Bfa: "BFA",
  Bgd: "BGD",
  Bgr: "BGR",
  Bhr: "BHR",
  Bhs: "BHS",
  Bih: "BIH",
  Blm: "BLM",
  Blr: "BLR",
  Blz: "BLZ",
  Bmu: "BMU",
  Bol: "BOL",
  Bra: "BRA",
  Brb: "BRB",
  Brn: "BRN",
  Btn: "BTN",
  Bvt: "BVT",
  Bwa: "BWA",
  Caf: "CAF",
  Can: "CAN",
  Cck: "CCK",
  Che: "CHE",
  Chl: "CHL",
  Chn: "CHN",
  Civ: "CIV",
  Cmr: "CMR",
  Cod: "COD",
  Cog: "COG",
  Cok: "COK",
  Col: "COL",
  Com: "COM",
  Cpv: "CPV",
  Cri: "CRI",
  Cub: "CUB",
  Cuw: "CUW",
  Cxr: "CXR",
  Cym: "CYM",
  Cyp: "CYP",
  Cze: "CZE",
  Deu: "DEU",
  Dji: "DJI",
  Dma: "DMA",
  Dnk: "DNK",
  Dom: "DOM",
  Dza: "DZA",
  Ecu: "ECU",
  Egy: "EGY",
  Eri: "ERI",
  Esh: "ESH",
  Esp: "ESP",
  Est: "EST",
  Eth: "ETH",
  Fin: "FIN",
  Fji: "FJI",
  Flk: "FLK",
  Fra: "FRA",
  Fro: "FRO",
  Fsm: "FSM",
  Gab: "GAB",
  Gbr: "GBR",
  Geo: "GEO",
  Ggy: "GGY",
  Gha: "GHA",
  Gib: "GIB",
  Gin: "GIN",
  Glp: "GLP",
  Gmb: "GMB",
  Gnb: "GNB",
  Gnq: "GNQ",
  Grc: "GRC",
  Grd: "GRD",
  Grl: "GRL",
  Gtm: "GTM",
  Guf: "GUF",
  Gum: "GUM",
  Guy: "GUY",
  Hkg: "HKG",
  Hmd: "HMD",
  Hnd: "HND",
  Hrv: "HRV",
  Hti: "HTI",
  Hun: "HUN",
  Idn: "IDN",
  Imn: "IMN",
  Ind: "IND",
  Iot: "IOT",
  Irl: "IRL",
  Irn: "IRN",
  Irq: "IRQ",
  Isl: "ISL",
  Isr: "ISR",
  Ita: "ITA",
  Jam: "JAM",
  Jey: "JEY",
  Jor: "JOR",
  Jpn: "JPN",
  Kaz: "KAZ",
  Ken: "KEN",
  Kgz: "KGZ",
  Khm: "KHM",
  Kir: "KIR",
  Kna: "KNA",
  Kor: "KOR",
  Kwt: "KWT",
  Lao: "LAO",
  Lbn: "LBN",
  Lbr: "LBR",
  Lby: "LBY",
  Lca: "LCA",
  Lie: "LIE",
  Lka: "LKA",
  Lso: "LSO",
  Ltu: "LTU",
  Lux: "LUX",
  Lva: "LVA",
  Mac: "MAC",
  Maf: "MAF",
  Mar: "MAR",
  Mco: "MCO",
  Mda: "MDA",
  Mdg: "MDG",
  Mdv: "MDV",
  Mex: "MEX",
  Mhl: "MHL",
  Mkd: "MKD",
  Mli: "MLI",
  Mlt: "MLT",
  Mmr: "MMR",
  Mne: "MNE",
  Mng: "MNG",
  Mnp: "MNP",
  Moz: "MOZ",
  Mrt: "MRT",
  Msr: "MSR",
  Mtq: "MTQ",
  Mus: "MUS",
  Mwi: "MWI",
  Mys: "MYS",
  Myt: "MYT",
  Nam: "NAM",
  Ncl: "NCL",
  Ner: "NER",
  Nfk: "NFK",
  Nga: "NGA",
  Nic: "NIC",
  Niu: "NIU",
  Nld: "NLD",
  Nor: "NOR",
  Npl: "NPL",
  Nru: "NRU",
  Nzl: "NZL",
  Omn: "OMN",
  Pak: "PAK",
  Pan: "PAN",
  Pcn: "PCN",
  Per: "PER",
  Phl: "PHL",
  Plw: "PLW",
  Png: "PNG",
  Pol: "POL",
  Pri: "PRI",
  Prk: "PRK",
  Prt: "PRT",
  Pry: "PRY",
  Pse: "PSE",
  Pyf: "PYF",
  Qat: "QAT",
  Reu: "REU",
  Rks: "RKS",
  Rou: "ROU",
  Rus: "RUS",
  Rwa: "RWA",
  Sau: "SAU",
  Sdn: "SDN",
  Sen: "SEN",
  Sgp: "SGP",
  Sgs: "SGS",
  Shn: "SHN",
  Sjm: "SJM",
  Slb: "SLB",
  Sle: "SLE",
  Slv: "SLV",
  Smr: "SMR",
  Som: "SOM",
  Spm: "SPM",
  Srb: "SRB",
  Ssd: "SSD",
  Stp: "STP",
  Sur: "SUR",
  Svk: "SVK",
  Svn: "SVN",
  Swe: "SWE",
  Swz: "SWZ",
  Sxm: "SXM",
  Syc: "SYC",
  Syr: "SYR",
  Tca: "TCA",
  Tcd: "TCD",
  Tgo: "TGO",
  Tha: "THA",
  Tjk: "TJK",
  Tkl: "TKL",
  Tkm: "TKM",
  Tls: "TLS",
  Ton: "TON",
  Tto: "TTO",
  Tun: "TUN",
  Tur: "TUR",
  Tuv: "TUV",
  Twn: "TWN",
  Tza: "TZA",
  Uga: "UGA",
  Ukr: "UKR",
  Umi: "UMI",
  Ury: "URY",
  Usa: "USA",
  Uzb: "UZB",
  Vat: "VAT",
  Vct: "VCT",
  Ven: "VEN",
  Vgb: "VGB",
  Vir: "VIR",
  Vnm: "VNM",
  Vut: "VUT",
  Wlf: "WLF",
  Wsm: "WSM",
  Yem: "YEM",
  Zaf: "ZAF",
  Zmb: "ZMB",
  Zwe: "ZWE",
} as const;
/**
 * 3-char country code of the contact based on locale, this will be used to determine pricing and taxes
 */
export type RegisterContactSSCountryOfAgreement = ClosedEnum<
  typeof RegisterContactSSCountryOfAgreement
>;

/**
 * A list of custom fields whose values can be set when creating or updating entities
 */
export type RegisterContactSSCustomField = {
  /**
   * The custom field’s unique key
   */
  key?: string | undefined;
  /**
   * The custom field’s value
   */
  value?: string | undefined;
};

export type RegisterContactSSRequestBody = {
  /**
   * The contact’s first name (required when registering using email/password, email/OTP or phone/OTP)
   */
  firstName: string | null;
  /**
   * The contact’s last name (required when registering using email/password, email/OTP or phone/OTP)
   */
  lastName: string | null;
  /**
   * Details about how the contact will be identified based on app/portal configuration
   */
  identification: Identification;
  /**
   * Has the contact accepted the business terms & conditions?
   */
  acceptTermsAndConditions?: boolean | undefined;
  /**
   * Has the contact opted out from receiving emails?
   */
  emailOptOut?: boolean | undefined;
  /**
   * Has the contact opted out from receiving text messages (sms)?
   */
  smsOptOut?: boolean | undefined;
  /**
   * The referral code of the contact who referred this contact (applicable only in cases where a new contact has been referred by another). This may trigger an award for the referrring contact subject to configuration
   */
  referralCode?: string | undefined;
  /**
   * Pass code to be redeemed - optionally used on Landing page registration flow, if pass code is invalid then contact registration will not proceed
   */
  passCode?: string | null | undefined;
  /**
   * The Pin on the pass being redeemed. Applicable and required only if in App settings, both the pass’s code and Pin are selected as the pass’s attributes. If the Pin is not valid, then contact registration fails
   */
  passPin?: string | null | undefined;
  /**
   * 3-char country code of the contact based on locale, this will be used to determine pricing and taxes
   */
  countryOfAgreement?: RegisterContactSSCountryOfAgreement | undefined;
  /**
   * The custom fields of the contact
   */
  customFields?: Array<RegisterContactSSCustomField> | null | undefined;
  /**
   * The contact's selected language, used for communications, translations etc
   */
  languageCode?: string | undefined;
};

export type RegisterContactSSRequest = {
  /**
   * The publishable api key for application identification
   */
  apiKey: string;
  body?: RegisterContactSSRequestBody | undefined;
};

/**
 * Contact type - can be PERSON or COMPANY
 */
export const RegisterContactSSType = {
  Person: "PERSON",
  Company: "COMPANY",
} as const;
/**
 * Contact type - can be PERSON or COMPANY
 */
export type RegisterContactSSType = OpenEnum<typeof RegisterContactSSType>;

/**
 * The authorised contact details
 */
export type RegisterContactSSContact = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * Contact type - can be PERSON or COMPANY
   */
  type?: RegisterContactSSType | undefined;
  /**
   * The contact’s first name
   */
  firstName?: string | undefined;
  /**
   * The contact’s last name
   */
  lastName?: string | undefined;
  /**
   * Defines whether the used identity is verified
   */
  isVerified?: boolean | undefined;
  /**
   * The company name if the contact type is 'COMPANY'
   */
  companyName?: string | undefined;
};

/**
 * The organisation type
 */
export const RegisterContactSSOrganisationType = {
  Operator: "OPERATOR",
  ServiceOwner: "SERVICE_OWNER",
  TransactionProcessor: "TRANSACTION_PROCESSOR",
  Business: "BUSINESS",
  Organisation: "ORGANISATION",
  Merchant: "MERCHANT",
  Venue: "VENUE",
} as const;
/**
 * The organisation type
 */
export type RegisterContactSSOrganisationType = OpenEnum<
  typeof RegisterContactSSOrganisationType
>;

export type RegisterContactSSOrganisation = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The organisation type
   */
  type?: RegisterContactSSOrganisationType | undefined;
  /**
   * The organisation name
   */
  name?: string | undefined;
};

export type RegisterContactSSCommunity = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
};

/**
 * Created
 */
export type RegisterContactSSResponse = {
  /**
   * The access token that can be used in subsequent API calls
   */
  accessToken?: string | undefined;
  /**
   * The token that can be used to generate a new access token (when previous is expired)
   */
  refreshToken?: string | undefined;
  /**
   * The token expiration date
   */
  expirationDate?: number | undefined;
  /**
   * The authorised contact details
   */
  contact?: RegisterContactSSContact | undefined;
  /**
   * Details about the organisations that the contact has joined
   */
  organisations?: Array<RegisterContactSSOrganisation> | undefined;
  /**
   * Details about the contact communities that the contact is a member of
   */
  communities?: Array<RegisterContactSSCommunity> | undefined;
  /**
   * The obfuscated send method value (applicable only when provider is EMAIL or PHONE and an OTP is generated)
   */
  obfuscatedValue?: string | undefined;
  /**
   * The one time password auth id (applicable only when provider is EMAIL or PHONE and an OTP is generated)
   */
  authOtp?: string | undefined;
  /**
   * The contact exists in the business
   */
  existingContact?: boolean | undefined;
};

/** @internal */
export const RegisterContactSSProvider$outboundSchema: z.ZodMiniEnum<
  typeof RegisterContactSSProvider
> = z.enum(RegisterContactSSProvider);

/** @internal */
export const RegisterContactSSCountryCode$outboundSchema: z.ZodMiniEnum<
  typeof RegisterContactSSCountryCode
> = z.enum(RegisterContactSSCountryCode);

/** @internal */
export type RegisterContactSSPhone$Outbound = {
  number: string;
  country_code: string;
};

/** @internal */
export const RegisterContactSSPhone$outboundSchema: z.ZodMiniType<
  RegisterContactSSPhone$Outbound,
  RegisterContactSSPhone
> = z.pipe(
  z.object({
    number: z.string(),
    countryCode: RegisterContactSSCountryCode$outboundSchema,
  }),
  z.transform((v) => {
    return remap$(v, {
      countryCode: "country_code",
    });
  }),
);

export function registerContactSSPhoneToJSON(
  registerContactSSPhone: RegisterContactSSPhone,
): string {
  return JSON.stringify(
    RegisterContactSSPhone$outboundSchema.parse(registerContactSSPhone),
  );
}

/** @internal */
export type Identification$Outbound = {
  provider?: string | undefined;
  email: string | null;
  password?: string | null | undefined;
  phone?: RegisterContactSSPhone$Outbound | null | undefined;
  application_id?: string | null | undefined;
  token?: string | null | undefined;
  sub?: string | undefined;
};

/** @internal */
export const Identification$outboundSchema: z.ZodMiniType<
  Identification$Outbound,
  Identification
> = z.pipe(
  z.object({
    provider: z.optional(RegisterContactSSProvider$outboundSchema),
    email: z.nullable(z.string()),
    password: z.optional(z.nullable(z.string())),
    phone: z.optional(
      z.nullable(z.lazy(() => RegisterContactSSPhone$outboundSchema)),
    ),
    applicationId: z.optional(z.nullable(z.string())),
    token: z.optional(z.nullable(z.string())),
    sub: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      applicationId: "application_id",
    });
  }),
);

export function identificationToJSON(identification: Identification): string {
  return JSON.stringify(Identification$outboundSchema.parse(identification));
}

/** @internal */
export const RegisterContactSSCountryOfAgreement$outboundSchema: z.ZodMiniEnum<
  typeof RegisterContactSSCountryOfAgreement
> = z.enum(RegisterContactSSCountryOfAgreement);

/** @internal */
export type RegisterContactSSCustomField$Outbound = {
  key?: string | undefined;
  value?: string | undefined;
};

/** @internal */
export const RegisterContactSSCustomField$outboundSchema: z.ZodMiniType<
  RegisterContactSSCustomField$Outbound,
  RegisterContactSSCustomField
> = z.object({
  key: z.optional(z.string()),
  value: z.optional(z.string()),
});

export function registerContactSSCustomFieldToJSON(
  registerContactSSCustomField: RegisterContactSSCustomField,
): string {
  return JSON.stringify(
    RegisterContactSSCustomField$outboundSchema.parse(
      registerContactSSCustomField,
    ),
  );
}

/** @internal */
export type RegisterContactSSRequestBody$Outbound = {
  first_name: string | null;
  last_name: string | null;
  identification: Identification$Outbound;
  "accept_terms_&_conditions": boolean;
  email_opt_out: boolean;
  sms_opt_out: boolean;
  referral_code?: string | undefined;
  pass_code?: string | null | undefined;
  "pass_pin "?: string | null | undefined;
  country_of_agreement?: string | undefined;
  custom_fields?:
    | Array<RegisterContactSSCustomField$Outbound>
    | null
    | undefined;
  language_code: string;
};

/** @internal */
export const RegisterContactSSRequestBody$outboundSchema: z.ZodMiniType<
  RegisterContactSSRequestBody$Outbound,
  RegisterContactSSRequestBody
> = z.pipe(
  z.object({
    firstName: z.nullable(z.string()),
    lastName: z.nullable(z.string()),
    identification: z.lazy(() => Identification$outboundSchema),
    acceptTermsAndConditions: z._default(z.boolean(), true),
    emailOptOut: z._default(z.boolean(), false),
    smsOptOut: z._default(z.boolean(), false),
    referralCode: z.optional(z.string()),
    passCode: z.optional(z.nullable(z.string())),
    passPin: z.optional(z.nullable(z.string())),
    countryOfAgreement: z.optional(
      RegisterContactSSCountryOfAgreement$outboundSchema,
    ),
    customFields: z.optional(z.nullable(z.array(z.lazy(() =>
      RegisterContactSSCustomField$outboundSchema
    )))),
    languageCode: z._default(z.string(), "EN"),
  }),
  z.transform((v) => {
    return remap$(v, {
      firstName: "first_name",
      lastName: "last_name",
      acceptTermsAndConditions: "accept_terms_&_conditions",
      emailOptOut: "email_opt_out",
      smsOptOut: "sms_opt_out",
      referralCode: "referral_code",
      passCode: "pass_code",
      passPin: "pass_pin ",
      countryOfAgreement: "country_of_agreement",
      customFields: "custom_fields",
      languageCode: "language_code",
    });
  }),
);

export function registerContactSSRequestBodyToJSON(
  registerContactSSRequestBody: RegisterContactSSRequestBody,
): string {
  return JSON.stringify(
    RegisterContactSSRequestBody$outboundSchema.parse(
      registerContactSSRequestBody,
    ),
  );
}

/** @internal */
export type RegisterContactSSRequest$Outbound = {
  api_key: string;
  body?: RegisterContactSSRequestBody$Outbound | undefined;
};

/** @internal */
export const RegisterContactSSRequest$outboundSchema: z.ZodMiniType<
  RegisterContactSSRequest$Outbound,
  RegisterContactSSRequest
> = z.pipe(
  z.object({
    apiKey: z.string(),
    body: z.optional(z.lazy(() => RegisterContactSSRequestBody$outboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      apiKey: "api_key",
    });
  }),
);

export function registerContactSSRequestToJSON(
  registerContactSSRequest: RegisterContactSSRequest,
): string {
  return JSON.stringify(
    RegisterContactSSRequest$outboundSchema.parse(registerContactSSRequest),
  );
}

/** @internal */
export const RegisterContactSSType$inboundSchema: z.ZodMiniType<
  RegisterContactSSType,
  unknown
> = openEnums.inboundSchema(RegisterContactSSType);

/** @internal */
export const RegisterContactSSContact$inboundSchema: z.ZodMiniType<
  RegisterContactSSContact,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    type: types.optional(RegisterContactSSType$inboundSchema),
    first_name: types.optional(types.string()),
    last_name: types.optional(types.string()),
    is_verified: types.optional(types.boolean()),
    company_name: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "first_name": "firstName",
      "last_name": "lastName",
      "is_verified": "isVerified",
      "company_name": "companyName",
    });
  }),
);

export function registerContactSSContactFromJSON(
  jsonString: string,
): SafeParseResult<RegisterContactSSContact, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RegisterContactSSContact$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RegisterContactSSContact' from JSON`,
  );
}

/** @internal */
export const RegisterContactSSOrganisationType$inboundSchema: z.ZodMiniType<
  RegisterContactSSOrganisationType,
  unknown
> = openEnums.inboundSchema(RegisterContactSSOrganisationType);

/** @internal */
export const RegisterContactSSOrganisation$inboundSchema: z.ZodMiniType<
  RegisterContactSSOrganisation,
  unknown
> = z.object({
  id: types.optional(types.string()),
  type: types.optional(RegisterContactSSOrganisationType$inboundSchema),
  name: types.optional(types.string()),
});

export function registerContactSSOrganisationFromJSON(
  jsonString: string,
): SafeParseResult<RegisterContactSSOrganisation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RegisterContactSSOrganisation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RegisterContactSSOrganisation' from JSON`,
  );
}

/** @internal */
export const RegisterContactSSCommunity$inboundSchema: z.ZodMiniType<
  RegisterContactSSCommunity,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
});

export function registerContactSSCommunityFromJSON(
  jsonString: string,
): SafeParseResult<RegisterContactSSCommunity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RegisterContactSSCommunity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RegisterContactSSCommunity' from JSON`,
  );
}

/** @internal */
export const RegisterContactSSResponse$inboundSchema: z.ZodMiniType<
  RegisterContactSSResponse,
  unknown
> = z.pipe(
  z.object({
    access_token: types.optional(types.string()),
    refresh_token: types.optional(types.string()),
    expiration_date: types.optional(types.number()),
    contact: types.optional(
      z.lazy(() => RegisterContactSSContact$inboundSchema),
    ),
    organisations: types.optional(
      z.array(z.lazy(() => RegisterContactSSOrganisation$inboundSchema)),
    ),
    communities: types.optional(
      z.array(z.lazy(() => RegisterContactSSCommunity$inboundSchema)),
    ),
    obfuscated_value: types.optional(types.string()),
    auth_otp: types.optional(types.string()),
    existing_contact: types.optional(types.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "access_token": "accessToken",
      "refresh_token": "refreshToken",
      "expiration_date": "expirationDate",
      "obfuscated_value": "obfuscatedValue",
      "auth_otp": "authOtp",
      "existing_contact": "existingContact",
    });
  }),
);

export function registerContactSSResponseFromJSON(
  jsonString: string,
): SafeParseResult<RegisterContactSSResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RegisterContactSSResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RegisterContactSSResponse' from JSON`,
  );
}
