/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 * @generated-id: 38d13030a803
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

/**
 * Defines how the results will be ordered</br>Default:DESC
 */
export const ComCrmContactSelfServiceResourceGetCommunitiesOrder = {
  Asc: "ASC",
  Desc: "DESC",
} as const;
/**
 * Defines how the results will be ordered</br>Default:DESC
 */
export type ComCrmContactSelfServiceResourceGetCommunitiesOrder = ClosedEnum<
  typeof ComCrmContactSelfServiceResourceGetCommunitiesOrder
>;

export type ComCrmContactSelfServiceResourceGetCommunitiesRequest = {
  /**
   * The contact identifier whose communities will be retrieved
   */
  id: string;
  /**
   * Defaults to false. If set to true, the community's usage allowance per product-related item is included in the response.
   */
  includeProductAllowance?: boolean | undefined;
  /**
   *  Determine if a "total" will be returned in paging reference. If set to True, then "total" is also returned but it will return up to 10K value. If set to False, then the "total" in paging is null.
   */
  includeTotal?: boolean | undefined;
  /**
   * Defines how the results will be ordered</br>Default:DESC
   */
  order?: ComCrmContactSelfServiceResourceGetCommunitiesOrder | undefined;
  /**
   * The page number that should be retrieved</br>Default:1
   */
  page?: number | undefined;
  /**
   * The size (total records) of each page</br>Default:10
   */
  size?: number | undefined;
  /**
   * Defines on which attribute the results should be sorted</br>Default:CREATED_DATE
   */
  sort?: string | undefined;
};

export type ComCrmContactSelfServiceResourceGetCommunitiesPaging = {
  /**
   * The page number
   */
  page?: number | undefined;
  /**
   * The number of records per page
   */
  size?: number | undefined;
  /**
   * The total number of records. If "include_total" is not specified, then this total is null. If "include_total" is specified, total has a value but it is accurate up to 10K records.
   */
  total?: number | undefined;
  /**
   * Shows if there are more records available to fetch
   */
  hasMore?: boolean | undefined;
};

/**
 * The community owner's wallet details
 */
export type ComCrmContactSelfServiceResourceGetCommunitiesWallet = {
  /**
   * The wallet identifier
   */
  id?: string | undefined;
};

/**
 * The contact that is owner of the community that the related contact is a member to
 */
export type ComCrmContactSelfServiceResourceGetCommunitiesCommunityOwner = {
  /**
   * The contact identifier
   */
  id?: string | undefined;
  /**
   * The contact first name
   */
  firstName?: string | undefined;
  /**
   * The contact last name
   */
  lastName?: string | undefined;
  /**
   * The community owner's wallet details
   */
  wallet?: ComCrmContactSelfServiceResourceGetCommunitiesWallet | undefined;
  /**
   * The contact company name (applicable if community owner is COMPANY)
   */
  companyName?: string | undefined;
};

/**
 * The community relation that the contact has
 */
export type ComCrmContactSelfServiceResourceGetCommunitiesRelation = {
  /**
   * The community relation identifier
   */
  id?: string | undefined;
  /**
   * The community relation name
   */
  name?: string | undefined;
};

export const ComCrmContactSelfServiceResourceGetCommunitiesPermission = {
  ContactManagement: "CONTACT_MANAGEMENT",
  ServiceRequestsManagement: "SERVICE_REQUESTS_MANAGEMENT",
  OrdersManagement: "ORDERS_MANAGEMENT",
  FullAccess: "FULL_ACCESS",
} as const;
export type ComCrmContactSelfServiceResourceGetCommunitiesPermission = OpenEnum<
  typeof ComCrmContactSelfServiceResourceGetCommunitiesPermission
>;

export type ComCrmContactSelfServiceResourceGetCommunitiesCommercePool = {
  /**
   * The commerce pool identifier
   */
  id?: string | undefined;
  /**
   * The commerce pool name
   */
  name?: string | undefined;
  /**
   * The commerce pool description
   */
  description?: string | undefined;
};

/**
 * Defines whether money requests will require an acceptance from the community owner or will be automatically applied
 */
export const ComCrmContactSelfServiceResourceGetCommunitiesMethod = {
  Auto: "AUTO",
  Manual: "MANUAL",
} as const;
/**
 * Defines whether money requests will require an acceptance from the community owner or will be automatically applied
 */
export type ComCrmContactSelfServiceResourceGetCommunitiesMethod = OpenEnum<
  typeof ComCrmContactSelfServiceResourceGetCommunitiesMethod
>;

/**
 * Defines whether the community person will be able to use/request money from community owner wallet
 */
export type ComCrmContactSelfServiceResourceGetCommunitiesWalletSharing = {
  /**
   * Defines if wallet sharing is enabled
   */
  isEnabled?: boolean | undefined;
  /**
   * Defines the commerce pools that the community person is allowed to use/transfer wallet money
   */
  commercePools?:
    | Array<ComCrmContactSelfServiceResourceGetCommunitiesCommercePool>
    | undefined;
  /**
   * Defines whether money requests will require an acceptance from the community owner or will be automatically applied
   */
  method?: ComCrmContactSelfServiceResourceGetCommunitiesMethod | undefined;
  /**
   * Defines the maximum amount that can be transferred per calendar month
   */
  maxAmount?: number | undefined;
  /**
   * Defines the remaining amount that can be transferred per calendar month
   */
  remainingAmount?: number | undefined;
};

/**
 * How much can be consumed
 */
export type ComCrmContactSelfServiceResourceGetCommunitiesAccumulatedAllowanceCashLimits =
  {
    /**
     * Allowance per transaction
     */
    perTransaction?: number | undefined;
    /**
     * Allowance per day
     */
    perDay?: number | undefined;
    /**
     * Allowance per billing cycle
     */
    perBillingCycle?: number | undefined;
  };

/**
 * The community's accumulated cash allowance, i.e. how much can be consumed among all products which are consumed through the community. This allowance is defined only in amount of money and it's evaluated based on the usage's rating (how much it costs)
 */
export type ComCrmContactSelfServiceResourceGetCommunitiesAccumulatedAllowance =
  {
    /**
     * Currency code based on ISO 4217 standard
     */
    currency?: string | undefined;
    /**
     * How much can be consumed
     */
    cashLimits?:
      | ComCrmContactSelfServiceResourceGetCommunitiesAccumulatedAllowanceCashLimits
      | undefined;
  };

/**
 * Product setting. Allow usage to either a specific product or to products of a specific type or to products of a specific family or to products of a specific category
 */
export const ComCrmContactSelfServiceResourceGetCommunitiesItemType = {
  Product: "PRODUCT",
  Type: "TYPE",
  Family: "FAMILY",
  Category: "CATEGORY",
} as const;
/**
 * Product setting. Allow usage to either a specific product or to products of a specific type or to products of a specific family or to products of a specific category
 */
export type ComCrmContactSelfServiceResourceGetCommunitiesItemType = OpenEnum<
  typeof ComCrmContactSelfServiceResourceGetCommunitiesItemType
>;

/**
 * Measurement unit. Applicable only when a specific usage product is included in the allowance
 */
export type ComCrmContactSelfServiceResourceGetCommunitiesMeasurementUnit = {
  /**
   * Measurement unit name
   */
  name?: string | undefined;
  /**
   * Measurement unit display name
   */
  displayName?: string | undefined;
};

/**
 * How much rated usage can be consumed
 */
export type ComCrmContactSelfServiceResourceGetCommunitiesProductsAllowanceCashLimits =
  {
    /**
     * Allowance per transaction
     */
    perTransaction?: number | undefined;
    /**
     * Allowance per day
     */
    perDay?: number | undefined;
    /**
     * Allowance per billing cycle
     */
    perBillingCycle?: number | undefined;
  };

/**
 * Actual allowed and remaining usage (based on measurement units)
 */
export type ComCrmContactSelfServiceResourceGetCommunitiesUsageLimits = {
  /**
   * Allowance per transaction
   */
  perTransaction?: number | undefined;
  /**
   * Allowance per day
   */
  perDay?: number | undefined;
  /**
   * Allowance per billing cycle
   */
  perBillingCycle?: number | undefined;
};

export type ComCrmContactSelfServiceResourceGetCommunitiesProductsAllowance = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  groupId?: string | undefined;
  /**
   * Currency code based on ISO 4217 standard
   */
  currency?: string | undefined;
  /**
   * Product setting. Allow usage to either a specific product or to products of a specific type or to products of a specific family or to products of a specific category
   */
  itemType?: ComCrmContactSelfServiceResourceGetCommunitiesItemType | undefined;
  /**
   * The identifier of the item (the product or the product type or the product family or the product category)
   */
  itemId?: string | undefined;
  /**
   * The product name or product type name or product family name or product category name depending on item_type
   */
  name?: string | undefined;
  sku?: string | undefined;
  /**
   * Measurement unit. Applicable only when a specific usage product is included in the allowance
   */
  measurementUnit?:
    | ComCrmContactSelfServiceResourceGetCommunitiesMeasurementUnit
    | undefined;
  /**
   * How much rated usage can be consumed
   */
  cashLimits?:
    | ComCrmContactSelfServiceResourceGetCommunitiesProductsAllowanceCashLimits
    | undefined;
  /**
   * Actual allowed and remaining usage (based on measurement units)
   */
  usageLimits?:
    | ComCrmContactSelfServiceResourceGetCommunitiesUsageLimits
    | undefined;
};

export type ComCrmContactSelfServiceResourceGetCommunitiesOrganisation = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
};

/**
 * Defines the usage allowance
 */
export type ComCrmContactSelfServiceResourceGetCommunitiesUsageAllowance = {
  /**
   * The community's accumulated cash allowance, i.e. how much can be consumed among all products which are consumed through the community. This allowance is defined only in amount of money and it's evaluated based on the usage's rating (how much it costs)
   */
  accumulatedAllowance?:
    | ComCrmContactSelfServiceResourceGetCommunitiesAccumulatedAllowance
    | undefined;
  /**
   * If set to true, the member has the same usage allowance per product as the ownerâ€™s termed/one-time service.
   */
  sameAsOwner?: boolean | undefined;
  /**
   * List of items which can be consumed through the community. This set of items includes usage and non-traceable physical goods. If nothing is specified, then usage is allowed among all usage services/non-traceable physical goods that the business is selling
   */
  productsAllowance?:
    | Array<ComCrmContactSelfServiceResourceGetCommunitiesProductsAllowance>
    | undefined;
  /**
   * The allowed organisations to consume allowance
   */
  organisations?:
    | Array<ComCrmContactSelfServiceResourceGetCommunitiesOrganisation>
    | undefined;
};

/**
 * The community people person's relation state. A person is considered as a valid community person only after they accept the invitation to join the community.
 */
export const ComCrmContactSelfServiceResourceGetCommunitiesState = {
  Pending: "PENDING",
  Accepted: "ACCEPTED",
  Rejected: "REJECTED",
} as const;
/**
 * The community people person's relation state. A person is considered as a valid community person only after they accept the invitation to join the community.
 */
export type ComCrmContactSelfServiceResourceGetCommunitiesState = OpenEnum<
  typeof ComCrmContactSelfServiceResourceGetCommunitiesState
>;

export type ComCrmContactSelfServiceResourceGetCommunitiesContent = {
  /**
   * The contact that is owner of the community that the related contact is a member to
   */
  communityOwner?:
    | ComCrmContactSelfServiceResourceGetCommunitiesCommunityOwner
    | undefined;
  /**
   * The community relation that the contact has
   */
  relation?: ComCrmContactSelfServiceResourceGetCommunitiesRelation | undefined;
  /**
   * Defines whether the contact member will have full permissions
   */
  isAdmin?: boolean | undefined;
  /**
   * Defines the (explicit) allowed permissions that the new contact member will have
   */
  permissions?:
    | Array<ComCrmContactSelfServiceResourceGetCommunitiesPermission>
    | undefined;
  /**
   * Defines whether the community person will be able to use/request money from community owner wallet
   */
  walletSharing?:
    | ComCrmContactSelfServiceResourceGetCommunitiesWalletSharing
    | undefined;
  /**
   * Defines the usage allowance
   */
  usageAllowance?:
    | ComCrmContactSelfServiceResourceGetCommunitiesUsageAllowance
    | undefined;
  /**
   * The community people person's relation state. A person is considered as a valid community person only after they accept the invitation to join the community.
   */
  state?: ComCrmContactSelfServiceResourceGetCommunitiesState | undefined;
  /**
   * A name that groups together community members
   */
  group?: string | undefined;
};

/**
 * OK
 */
export type ComCrmContactSelfServiceResourceGetCommunitiesResponse = {
  paging?: ComCrmContactSelfServiceResourceGetCommunitiesPaging | undefined;
  content?:
    | Array<ComCrmContactSelfServiceResourceGetCommunitiesContent>
    | undefined;
};

/** @internal */
export const ComCrmContactSelfServiceResourceGetCommunitiesOrder$outboundSchema:
  z.ZodMiniEnum<typeof ComCrmContactSelfServiceResourceGetCommunitiesOrder> = z
    .enum(ComCrmContactSelfServiceResourceGetCommunitiesOrder);

/** @internal */
export type ComCrmContactSelfServiceResourceGetCommunitiesRequest$Outbound = {
  id: string;
  include_product_allowance?: boolean | undefined;
  include_total?: boolean | undefined;
  order?: string | undefined;
  page?: number | undefined;
  size?: number | undefined;
  sort?: string | undefined;
};

/** @internal */
export const ComCrmContactSelfServiceResourceGetCommunitiesRequest$outboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceGetCommunitiesRequest$Outbound,
    ComCrmContactSelfServiceResourceGetCommunitiesRequest
  > = z.pipe(
    z.object({
      id: z.string(),
      includeProductAllowance: z.optional(z.boolean()),
      includeTotal: z.optional(z.boolean()),
      order: z.optional(
        ComCrmContactSelfServiceResourceGetCommunitiesOrder$outboundSchema,
      ),
      page: z.optional(z.int()),
      size: z.optional(z.int()),
      sort: z.optional(z.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        includeProductAllowance: "include_product_allowance",
        includeTotal: "include_total",
      });
    }),
  );

export function comCrmContactSelfServiceResourceGetCommunitiesRequestToJSON(
  comCrmContactSelfServiceResourceGetCommunitiesRequest:
    ComCrmContactSelfServiceResourceGetCommunitiesRequest,
): string {
  return JSON.stringify(
    ComCrmContactSelfServiceResourceGetCommunitiesRequest$outboundSchema.parse(
      comCrmContactSelfServiceResourceGetCommunitiesRequest,
    ),
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceGetCommunitiesPaging$inboundSchema:
  z.ZodMiniType<ComCrmContactSelfServiceResourceGetCommunitiesPaging, unknown> =
    z.pipe(
      z.object({
        page: types.optional(types.number()),
        size: types.optional(types.number()),
        total: types.optional(types.number()),
        has_more: types.optional(types.boolean()),
      }),
      z.transform((v) => {
        return remap$(v, {
          "has_more": "hasMore",
        });
      }),
    );

export function comCrmContactSelfServiceResourceGetCommunitiesPagingFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceGetCommunitiesPaging,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceGetCommunitiesPaging$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmContactSelfServiceResourceGetCommunitiesPaging' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceGetCommunitiesWallet$inboundSchema:
  z.ZodMiniType<ComCrmContactSelfServiceResourceGetCommunitiesWallet, unknown> =
    z.object({
      id: types.optional(types.string()),
    });

export function comCrmContactSelfServiceResourceGetCommunitiesWalletFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceGetCommunitiesWallet,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceGetCommunitiesWallet$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmContactSelfServiceResourceGetCommunitiesWallet' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceGetCommunitiesCommunityOwner$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceGetCommunitiesCommunityOwner,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      first_name: types.optional(types.string()),
      last_name: types.optional(types.string()),
      wallet: types.optional(z.lazy(() =>
        ComCrmContactSelfServiceResourceGetCommunitiesWallet$inboundSchema
      )),
      company_name: types.optional(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "first_name": "firstName",
        "last_name": "lastName",
        "company_name": "companyName",
      });
    }),
  );

export function comCrmContactSelfServiceResourceGetCommunitiesCommunityOwnerFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceGetCommunitiesCommunityOwner,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceGetCommunitiesCommunityOwner$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceGetCommunitiesCommunityOwner' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceGetCommunitiesRelation$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceGetCommunitiesRelation,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
  });

export function comCrmContactSelfServiceResourceGetCommunitiesRelationFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceGetCommunitiesRelation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceGetCommunitiesRelation$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceGetCommunitiesRelation' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceGetCommunitiesPermission$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceGetCommunitiesPermission,
    unknown
  > = openEnums.inboundSchema(
    ComCrmContactSelfServiceResourceGetCommunitiesPermission,
  );

/** @internal */
export const ComCrmContactSelfServiceResourceGetCommunitiesCommercePool$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceGetCommunitiesCommercePool,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    description: types.optional(types.string()),
  });

export function comCrmContactSelfServiceResourceGetCommunitiesCommercePoolFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceGetCommunitiesCommercePool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceGetCommunitiesCommercePool$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceGetCommunitiesCommercePool' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceGetCommunitiesMethod$inboundSchema:
  z.ZodMiniType<ComCrmContactSelfServiceResourceGetCommunitiesMethod, unknown> =
    openEnums.inboundSchema(
      ComCrmContactSelfServiceResourceGetCommunitiesMethod,
    );

/** @internal */
export const ComCrmContactSelfServiceResourceGetCommunitiesWalletSharing$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceGetCommunitiesWalletSharing,
    unknown
  > = z.pipe(
    z.object({
      is_enabled: types.optional(types.boolean()),
      commerce_pools: types.optional(z.array(z.lazy(() =>
        ComCrmContactSelfServiceResourceGetCommunitiesCommercePool$inboundSchema
      ))),
      method: types.optional(
        ComCrmContactSelfServiceResourceGetCommunitiesMethod$inboundSchema,
      ),
      max_amount: types.optional(types.number()),
      remaining_amount: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "is_enabled": "isEnabled",
        "commerce_pools": "commercePools",
        "max_amount": "maxAmount",
        "remaining_amount": "remainingAmount",
      });
    }),
  );

export function comCrmContactSelfServiceResourceGetCommunitiesWalletSharingFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceGetCommunitiesWalletSharing,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceGetCommunitiesWalletSharing$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceGetCommunitiesWalletSharing' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceGetCommunitiesAccumulatedAllowanceCashLimits$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceGetCommunitiesAccumulatedAllowanceCashLimits,
    unknown
  > = z.pipe(
    z.object({
      per_transaction: types.optional(types.number()),
      per_day: types.optional(types.number()),
      per_billing_cycle: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "per_transaction": "perTransaction",
        "per_day": "perDay",
        "per_billing_cycle": "perBillingCycle",
      });
    }),
  );

export function comCrmContactSelfServiceResourceGetCommunitiesAccumulatedAllowanceCashLimitsFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceGetCommunitiesAccumulatedAllowanceCashLimits,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceGetCommunitiesAccumulatedAllowanceCashLimits$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceGetCommunitiesAccumulatedAllowanceCashLimits' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceGetCommunitiesAccumulatedAllowance$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceGetCommunitiesAccumulatedAllowance,
    unknown
  > = z.pipe(
    z.object({
      currency: types.optional(types.string()),
      cash_limits: types.optional(z.lazy(() =>
        ComCrmContactSelfServiceResourceGetCommunitiesAccumulatedAllowanceCashLimits$inboundSchema
      )),
    }),
    z.transform((v) => {
      return remap$(v, {
        "cash_limits": "cashLimits",
      });
    }),
  );

export function comCrmContactSelfServiceResourceGetCommunitiesAccumulatedAllowanceFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceGetCommunitiesAccumulatedAllowance,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceGetCommunitiesAccumulatedAllowance$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceGetCommunitiesAccumulatedAllowance' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceGetCommunitiesItemType$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceGetCommunitiesItemType,
    unknown
  > = openEnums.inboundSchema(
    ComCrmContactSelfServiceResourceGetCommunitiesItemType,
  );

/** @internal */
export const ComCrmContactSelfServiceResourceGetCommunitiesMeasurementUnit$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceGetCommunitiesMeasurementUnit,
    unknown
  > = z.pipe(
    z.object({
      name: types.optional(types.string()),
      display_name: types.optional(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "display_name": "displayName",
      });
    }),
  );

export function comCrmContactSelfServiceResourceGetCommunitiesMeasurementUnitFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceGetCommunitiesMeasurementUnit,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceGetCommunitiesMeasurementUnit$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceGetCommunitiesMeasurementUnit' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceGetCommunitiesProductsAllowanceCashLimits$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceGetCommunitiesProductsAllowanceCashLimits,
    unknown
  > = z.pipe(
    z.object({
      per_transaction: types.optional(types.number()),
      per_day: types.optional(types.number()),
      per_billing_cycle: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "per_transaction": "perTransaction",
        "per_day": "perDay",
        "per_billing_cycle": "perBillingCycle",
      });
    }),
  );

export function comCrmContactSelfServiceResourceGetCommunitiesProductsAllowanceCashLimitsFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceGetCommunitiesProductsAllowanceCashLimits,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceGetCommunitiesProductsAllowanceCashLimits$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceGetCommunitiesProductsAllowanceCashLimits' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceGetCommunitiesUsageLimits$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceGetCommunitiesUsageLimits,
    unknown
  > = z.pipe(
    z.object({
      per_transaction: types.optional(types.number()),
      per_day: types.optional(types.number()),
      per_billing_cycle: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "per_transaction": "perTransaction",
        "per_day": "perDay",
        "per_billing_cycle": "perBillingCycle",
      });
    }),
  );

export function comCrmContactSelfServiceResourceGetCommunitiesUsageLimitsFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceGetCommunitiesUsageLimits,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceGetCommunitiesUsageLimits$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceGetCommunitiesUsageLimits' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceGetCommunitiesProductsAllowance$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceGetCommunitiesProductsAllowance,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      group_id: types.optional(types.string()),
      currency: types.optional(types.string()),
      item_type: types.optional(
        ComCrmContactSelfServiceResourceGetCommunitiesItemType$inboundSchema,
      ),
      item_id: types.optional(types.string()),
      name: types.optional(types.string()),
      sku: types.optional(types.string()),
      measurement_unit: types.optional(z.lazy(() =>
        ComCrmContactSelfServiceResourceGetCommunitiesMeasurementUnit$inboundSchema
      )),
      cash_limits: types.optional(z.lazy(() =>
        ComCrmContactSelfServiceResourceGetCommunitiesProductsAllowanceCashLimits$inboundSchema
      )),
      usage_limits: types.optional(z.lazy(() =>
        ComCrmContactSelfServiceResourceGetCommunitiesUsageLimits$inboundSchema
      )),
    }),
    z.transform((v) => {
      return remap$(v, {
        "group_id": "groupId",
        "item_type": "itemType",
        "item_id": "itemId",
        "measurement_unit": "measurementUnit",
        "cash_limits": "cashLimits",
        "usage_limits": "usageLimits",
      });
    }),
  );

export function comCrmContactSelfServiceResourceGetCommunitiesProductsAllowanceFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceGetCommunitiesProductsAllowance,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceGetCommunitiesProductsAllowance$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceGetCommunitiesProductsAllowance' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceGetCommunitiesOrganisation$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceGetCommunitiesOrganisation,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
  });

export function comCrmContactSelfServiceResourceGetCommunitiesOrganisationFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceGetCommunitiesOrganisation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceGetCommunitiesOrganisation$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceGetCommunitiesOrganisation' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceGetCommunitiesUsageAllowance$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceGetCommunitiesUsageAllowance,
    unknown
  > = z.pipe(
    z.object({
      accumulated_allowance: types.optional(z.lazy(() =>
        ComCrmContactSelfServiceResourceGetCommunitiesAccumulatedAllowance$inboundSchema
      )),
      same_as_owner: types.optional(types.boolean()),
      products_allowance: types.optional(z.array(z.lazy(() =>
        ComCrmContactSelfServiceResourceGetCommunitiesProductsAllowance$inboundSchema
      ))),
      organisations: types.optional(z.array(z.lazy(() =>
        ComCrmContactSelfServiceResourceGetCommunitiesOrganisation$inboundSchema
      ))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "accumulated_allowance": "accumulatedAllowance",
        "same_as_owner": "sameAsOwner",
        "products_allowance": "productsAllowance",
      });
    }),
  );

export function comCrmContactSelfServiceResourceGetCommunitiesUsageAllowanceFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceGetCommunitiesUsageAllowance,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceGetCommunitiesUsageAllowance$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceGetCommunitiesUsageAllowance' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceGetCommunitiesState$inboundSchema:
  z.ZodMiniType<ComCrmContactSelfServiceResourceGetCommunitiesState, unknown> =
    openEnums.inboundSchema(
      ComCrmContactSelfServiceResourceGetCommunitiesState,
    );

/** @internal */
export const ComCrmContactSelfServiceResourceGetCommunitiesContent$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceGetCommunitiesContent,
    unknown
  > = z.pipe(
    z.object({
      community_owner: types.optional(z.lazy(() =>
        ComCrmContactSelfServiceResourceGetCommunitiesCommunityOwner$inboundSchema
      )),
      relation: types.optional(z.lazy(() =>
        ComCrmContactSelfServiceResourceGetCommunitiesRelation$inboundSchema
      )),
      is_admin: types.optional(types.boolean()),
      permissions: types.optional(
        z.array(
          ComCrmContactSelfServiceResourceGetCommunitiesPermission$inboundSchema,
        ),
      ),
      wallet_sharing: types.optional(z.lazy(() =>
        ComCrmContactSelfServiceResourceGetCommunitiesWalletSharing$inboundSchema
      )),
      usage_allowance: types.optional(z.lazy(() =>
        ComCrmContactSelfServiceResourceGetCommunitiesUsageAllowance$inboundSchema
      )),
      state: types.optional(
        ComCrmContactSelfServiceResourceGetCommunitiesState$inboundSchema,
      ),
      group: types.optional(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "community_owner": "communityOwner",
        "is_admin": "isAdmin",
        "wallet_sharing": "walletSharing",
        "usage_allowance": "usageAllowance",
      });
    }),
  );

export function comCrmContactSelfServiceResourceGetCommunitiesContentFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceGetCommunitiesContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceGetCommunitiesContent$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmContactSelfServiceResourceGetCommunitiesContent' from JSON`,
  );
}

/** @internal */
export const ComCrmContactSelfServiceResourceGetCommunitiesResponse$inboundSchema:
  z.ZodMiniType<
    ComCrmContactSelfServiceResourceGetCommunitiesResponse,
    unknown
  > = z.object({
    paging: types.optional(
      z.lazy(() =>
        ComCrmContactSelfServiceResourceGetCommunitiesPaging$inboundSchema
      ),
    ),
    content: types.optional(
      z.array(z.lazy(() =>
        ComCrmContactSelfServiceResourceGetCommunitiesContent$inboundSchema
      )),
    ),
  });

export function comCrmContactSelfServiceResourceGetCommunitiesResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmContactSelfServiceResourceGetCommunitiesResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmContactSelfServiceResourceGetCommunitiesResponse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmContactSelfServiceResourceGetCommunitiesResponse' from JSON`,
  );
}
