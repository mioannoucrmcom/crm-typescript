/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 * @generated-id: acefb8953313
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

export type ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsSecurity =
  {
    secretAPIKey: string;
  };

/**
 * Defines how the results will be ordered
 */
export const ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsOrderEnum =
  {
    Asc: "ASC",
    Desc: "DESC",
  } as const;
/**
 * Defines how the results will be ordered
 */
export type ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsOrderEnum =
  ClosedEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsOrderEnum
  >;

export type ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsRequest =
  {
    /**
     * The contactâ€™s unique identifier
     */
    id: string;
    /**
     * By default, billing information is not retunred
     */
    includeBillingInfo?: boolean | undefined;
    /**
     * Include future services for the subscription
     */
    includeFutureInfo?: boolean | undefined;
    /**
     * By default, Churned (cancelled) subscriptions are excluded. Use this parameter to get a list of Churned Subscriptions only.
     */
    includeOnlyTerminated?: boolean | undefined;
    /**
     * By default order information is not returned
     */
    includeOrderInfo?: boolean | undefined;
    /**
     * By default billing terms are not returned
     */
    includeTerms?: boolean | undefined;
    /**
     * Filter based on the subscription's state
     */
    state?: string | undefined;
    /**
     * Determine if a "total" will be returned in paging reference. If set to True, then "total" is also returned but it will return up to 10K value. If set to False, then the "total" in paging is null.
     */
    includeTotal?: boolean | undefined;
    /**
     * Defines how the results will be ordered
     */
    order?:
      | ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsOrderEnum
      | undefined;
    /**
     * The page number that should be retrieved
     */
    page?: number | undefined;
    /**
     * The size (total records) of each page
     */
    size?: number | undefined;
    /**
     * Defines on which attribute the results should be sorted
     */
    sort?: string | undefined;
  };

export type ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsPaging =
  {
    /**
     * The page number
     */
    page?: number | undefined;
    /**
     * The number of records per page
     */
    size?: number | undefined;
    /**
     * The total number of records. If "include_total" is not specified, then this total is null. If "include_total" is specified, total has a value but it is accurate up to 10K records.
     */
    total?: number | undefined;
    /**
     * Shows if there are more records available to fetch
     */
    hasMore?: boolean | undefined;
  };

/**
 * Subscription State
 */
export const ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsState =
  {
    Active: "ACTIVE",
    Churned: "CHURNED",
    Inactive: "INACTIVE",
  } as const;
/**
 * Subscription State
 */
export type ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsState =
  OpenEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsState
  >;

/**
 * Detailed billing information of the subscription
 */
export type BillingInfo = {
  /**
   * The date until which the subscription's services are billed
   */
  billUpDate?: number | undefined;
  /**
   * The next date on which the subscription will be billed
   */
  nextBillingDate?: number | undefined;
  /**
   * The date on which the next payment is expected. Usually it's the next billing date unless the subscriber's payment terms allow them a period to pay off the subscription's bill
   */
  nextPaymentDate?: number | undefined;
  /**
   * One-time services included or not. Applicable for subscritpinos with no specific billing cycle since they only include one-time services (billed only once during their ordering)
   */
  oneTimeServices?: boolean | undefined;
};

/**
 * The billing cycle's unit of time
 */
export const ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsUot =
  {
    Second: "SECOND",
    Minute: "MINUTE",
    Hour: "HOUR",
    Day: "DAY",
    Week: "WEEK",
    Month: "MONTH",
    Year: "YEAR",
    Overall: "OVERALL",
  } as const;
/**
 * The billing cycle's unit of time
 */
export type ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsUot =
  OpenEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsUot
  >;

/**
 * The subscription's billing cycle duration
 */
export type ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingPeriod =
  {
    /**
     * The billing cycle's duration
     */
    duration?: number | undefined;
    /**
     * The billing cycle's unit of time
     */
    uot?:
      | ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsUot
      | undefined;
  };

/**
 * The day of month/week until which the subscripton's services will be billed. Either a day of month or day of week is returned, depnding on the subscription's billing cycle (if it is less than a month, then a day of week is returned)
 */
export type ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingDay =
  {
    /**
     * Day of week
     */
    dayOfWeek?: string | undefined;
    /**
     * Day of month
     */
    dayOfMonth?: number | undefined;
    /**
     * Month of year
     */
    monthOfYear?: string | undefined;
  };

/**
 * Subscription's billing model
 */
export const ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingModel =
  {
    PostBill: "POST_BILL",
    PreBill: "PRE_BILL",
  } as const;
/**
 * Subscription's billing model
 */
export type ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingModel =
  OpenEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingModel
  >;

/**
 * Available payment method types
 */
export const ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsType =
  {
    Card: "CARD",
    AccountDebit: "ACCOUNT_DEBIT",
    Wallet: "WALLET",
    CrmWallet: "CRM_WALLET",
    Cash: "CASH",
    Cheque: "CHEQUE",
    ElectronicTransfer: "ELECTRONIC_TRANSFER",
  } as const;
/**
 * Available payment method types
 */
export type ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsType =
  OpenEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsType
  >;

/**
 * Payment method details
 */
export type ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsIdentity =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * A short description of the payment method. Depending on the payment method's type different information is returned:
     *
     * @remarks
     *
     *   -  Card: the brand, followed by the last 4 digits of the card plus expiration month/year
     *   -  Account debit: Name: Bank code followed by the first 5 and the last 9 digits of the account number/IBAN
     *   -  Wallet: Name: Email and/or phone used on registration
     */
    identifier?: string | undefined;
  };

/**
 * The subscription's payment method
 */
export type ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsPaymentMethod =
  {
    /**
     * Available payment method types
     */
    type?:
      | ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsType
      | undefined;
    /**
     * Payment method details
     */
    identity?:
      | ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsIdentity
      | undefined;
  };

/**
 * The subscription's billing terms
 */
export type ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsTerms =
  {
    /**
     * The subscription's billing cycle duration
     */
    billingPeriod?:
      | ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingPeriod
      | undefined;
    /**
     * The day of month/week until which the subscripton's services will be billed. Either a day of month or day of week is returned, depnding on the subscription's billing cycle (if it is less than a month, then a day of week is returned)
     */
    billingDay?:
      | ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingDay
      | undefined;
    /**
     * Subscription's billing model
     */
    billingModel?:
      | ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingModel
      | undefined;
    /**
     * The subscription's payment method
     */
    paymentMethod?:
      | ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsPaymentMethod
      | undefined;
  };

/**
 * The related order
 */
export type ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsContentOrder =
  {
    /**
     * the entity identifier
     */
    id?: string | undefined;
    /**
     * the entity number
     */
    number?: string | undefined;
  };

/**
 * The account of the Subscription. Account might be owned by a Contact or an Organisation
 */
export type ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsAccount =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The account name
     */
    name?: string | undefined;
    /**
     * The account number
     */
    number?: string | undefined;
    /**
     * Currency code based on ISO 4217 standard
     */
    currencyCode?: string | undefined;
  };

export type ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsContent =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * Subscription's code. If not specified on creating the subscirpiton, then a unique and random 16-digit code is assigned as the subscription's code
     */
    code?: string | undefined;
    /**
     * Subscription State
     */
    state?:
      | ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsState
      | undefined;
    /**
     * Number of Effective services. Recurring expenses are excluded. Service in Trial are excluded
     */
    activeServices?: number | undefined;
    /**
     * Number of devices
     */
    numberOfDevices?: number | undefined;
    /**
     * The date on which the subscription was activated for the first time
     */
    firstActivationDate?: number | undefined;
    /**
     * Detailed billing information of the subscription
     */
    billingInfo?: BillingInfo | undefined;
    /**
     * The subscription's billing terms
     */
    terms?:
      | ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsTerms
      | undefined;
    /**
     * Number of services which are scheduled to be added on the subscription
     */
    futureServices?: number | undefined;
    /**
     * Applicable for future subscirptions, i.e. subscriptions whose first service is scheduled to be added on a future date
     */
    startDate?: number | undefined;
    /**
     * Number of Inactive services. Includes Not Effective and Paused services. Recurring expenses excluded
     */
    inactiveServices?: number | undefined;
    /**
     * Number of Draft services (services ordered but never activated)
     */
    draftServices?: number | undefined;
    /**
     * Number of services which might be active on the subscription, but they are still in trial period. These services are not included in the number of active (paid) services of the subscription
     */
    trialServices?: number | undefined;
    /**
     * Determines whether usage is allowed to be consumed as part of at least one of the active services of the subscription. Usage might be allowed by one of the services, but at the time the Web API is triggered, the customer is blocked for consuming usage
     */
    usageBlocked: boolean;
    /**
     * The related order
     */
    order?:
      | ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsContentOrder
      | undefined;
    /**
     * The account of the Subscription. Account might be owned by a Contact or an Organisation
     */
    account?:
      | ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsAccount
      | undefined;
  };

/**
 * OK
 */
export type ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsResponse =
  {
    paging?:
      | ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsPaging
      | undefined;
    content?:
      | Array<
        ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsContent
      >
      | undefined;
  };

/** @internal */
export type ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsSecurity$Outbound =
  {
    Secret_API_key: string;
  };

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsSecurity$outboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsSecurity$Outbound,
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsSecurity
  > = z.pipe(
    z.object({
      secretAPIKey: z.string(),
    }),
    z.transform((v) => {
      return remap$(v, {
        secretAPIKey: "Secret_API_key",
      });
    }),
  );

export function comCrmSubscriptionSelfServiceResourceListContactSubscriptionsSecurityToJSON(
  comCrmSubscriptionSelfServiceResourceListContactSubscriptionsSecurity:
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsSecurity,
): string {
  return JSON.stringify(
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsSecurity$outboundSchema
      .parse(
        comCrmSubscriptionSelfServiceResourceListContactSubscriptionsSecurity,
      ),
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsOrderEnum$outboundSchema:
  z.ZodMiniEnum<
    typeof ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsOrderEnum
  > = z.enum(
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsOrderEnum,
  );

/** @internal */
export type ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsRequest$Outbound =
  {
    id: string;
    include_billing_info: boolean;
    include_future_info: boolean;
    include_only_terminated?: boolean | undefined;
    include_order_info: boolean;
    include_terms: boolean;
    state?: string | undefined;
    include_total: boolean;
    order: string;
    page: number;
    size: number;
    sort: string;
  };

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsRequest$outboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsRequest$Outbound,
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsRequest
  > = z.pipe(
    z.object({
      id: z.string(),
      includeBillingInfo: z._default(z.boolean(), false),
      includeFutureInfo: z._default(z.boolean(), false),
      includeOnlyTerminated: z.optional(z.boolean()),
      includeOrderInfo: z._default(z.boolean(), false),
      includeTerms: z._default(z.boolean(), false),
      state: z.optional(z.string()),
      includeTotal: z._default(z.boolean(), false),
      order: z._default(
        ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsOrderEnum$outboundSchema,
        "DESC",
      ),
      page: z._default(z.int(), 1),
      size: z._default(z.int(), 10),
      sort: z._default(z.string(), "CREATED_DATE"),
    }),
    z.transform((v) => {
      return remap$(v, {
        includeBillingInfo: "include_billing_info",
        includeFutureInfo: "include_future_info",
        includeOnlyTerminated: "include_only_terminated",
        includeOrderInfo: "include_order_info",
        includeTerms: "include_terms",
        includeTotal: "include_total",
      });
    }),
  );

export function comCrmSubscriptionSelfServiceResourceListContactSubscriptionsRequestToJSON(
  comCrmSubscriptionSelfServiceResourceListContactSubscriptionsRequest:
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsRequest,
): string {
  return JSON.stringify(
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsRequest$outboundSchema
      .parse(
        comCrmSubscriptionSelfServiceResourceListContactSubscriptionsRequest,
      ),
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsPaging$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsPaging,
    unknown
  > = z.pipe(
    z.object({
      page: types.optional(types.number()),
      size: types.optional(types.number()),
      total: types.optional(types.number()),
      has_more: types.optional(types.boolean()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "has_more": "hasMore",
      });
    }),
  );

export function comCrmSubscriptionSelfServiceResourceListContactSubscriptionsPagingFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsPaging,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsPaging$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsPaging' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsState$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsState,
    unknown
  > = openEnums.inboundSchema(
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsState,
  );

/** @internal */
export const BillingInfo$inboundSchema: z.ZodMiniType<BillingInfo, unknown> = z
  .pipe(
    z.object({
      bill_up_date: types.optional(types.number()),
      next_billing_date: types.optional(types.number()),
      next_payment_date: types.optional(types.number()),
      one_time_services: types.optional(types.boolean()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "bill_up_date": "billUpDate",
        "next_billing_date": "nextBillingDate",
        "next_payment_date": "nextPaymentDate",
        "one_time_services": "oneTimeServices",
      });
    }),
  );

export function billingInfoFromJSON(
  jsonString: string,
): SafeParseResult<BillingInfo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BillingInfo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingInfo' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsUot$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsUot,
    unknown
  > = openEnums.inboundSchema(
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsUot,
  );

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingPeriod$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingPeriod,
    unknown
  > = z.object({
    duration: types.optional(types.number()),
    uot: types.optional(
      ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsUot$inboundSchema,
    ),
  });

export function comCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingPeriodFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingPeriod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingPeriod$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingPeriod' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingDay$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingDay,
    unknown
  > = z.pipe(
    z.object({
      day_of_week: types.optional(types.string()),
      day_of_month: types.optional(types.number()),
      month_of_year: types.optional(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "day_of_week": "dayOfWeek",
        "day_of_month": "dayOfMonth",
        "month_of_year": "monthOfYear",
      });
    }),
  );

export function comCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingDayFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingDay,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingDay$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingDay' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingModel$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingModel,
    unknown
  > = openEnums.inboundSchema(
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingModel,
  );

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsType$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsType,
    unknown
  > = openEnums.inboundSchema(
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsType,
  );

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsIdentity$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsIdentity,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    identifier: types.optional(types.string()),
  });

export function comCrmSubscriptionSelfServiceResourceListContactSubscriptionsIdentityFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsIdentity,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsIdentity$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsIdentity' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsPaymentMethod$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsPaymentMethod,
    unknown
  > = z.object({
    type: types.optional(
      ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsType$inboundSchema,
    ),
    identity: types.optional(
      z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsIdentity$inboundSchema
      ),
    ),
  });

export function comCrmSubscriptionSelfServiceResourceListContactSubscriptionsPaymentMethodFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsPaymentMethod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsPaymentMethod$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsPaymentMethod' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsTerms$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsTerms,
    unknown
  > = z.pipe(
    z.object({
      billing_period: types.optional(z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingPeriod$inboundSchema
      )),
      billing_day: types.optional(z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingDay$inboundSchema
      )),
      billing_model: types.optional(
        ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsBillingModel$inboundSchema,
      ),
      payment_method: types.optional(z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsPaymentMethod$inboundSchema
      )),
    }),
    z.transform((v) => {
      return remap$(v, {
        "billing_period": "billingPeriod",
        "billing_day": "billingDay",
        "billing_model": "billingModel",
        "payment_method": "paymentMethod",
      });
    }),
  );

export function comCrmSubscriptionSelfServiceResourceListContactSubscriptionsTermsFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsTerms,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsTerms$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsTerms' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsContentOrder$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsContentOrder,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    number: types.optional(types.string()),
  });

export function comCrmSubscriptionSelfServiceResourceListContactSubscriptionsContentOrderFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsContentOrder,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsContentOrder$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsContentOrder' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsAccount$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsAccount,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      name: types.optional(types.string()),
      number: types.optional(types.string()),
      currency_code: types.optional(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "currency_code": "currencyCode",
      });
    }),
  );

export function comCrmSubscriptionSelfServiceResourceListContactSubscriptionsAccountFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsAccount,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsAccount$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsAccount' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsContent$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsContent,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      code: types.optional(types.string()),
      state: types.optional(
        ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsState$inboundSchema,
      ),
      active_services: types.optional(types.number()),
      number_of_devices: types.optional(types.number()),
      first_activation_date: types.optional(types.number()),
      billing_info: types.optional(z.lazy(() => BillingInfo$inboundSchema)),
      terms: types.optional(z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsTerms$inboundSchema
      )),
      future_services: types.optional(types.number()),
      start_date: types.optional(types.number()),
      inactive_services: types.optional(types.number()),
      draft_services: types.optional(types.number()),
      trial_services: types.optional(types.number()),
      usage_blocked: z._default(types.boolean(), false),
      order: types.optional(z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsContentOrder$inboundSchema
      )),
      account: types.optional(z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsAccount$inboundSchema
      )),
    }),
    z.transform((v) => {
      return remap$(v, {
        "active_services": "activeServices",
        "number_of_devices": "numberOfDevices",
        "first_activation_date": "firstActivationDate",
        "billing_info": "billingInfo",
        "future_services": "futureServices",
        "start_date": "startDate",
        "inactive_services": "inactiveServices",
        "draft_services": "draftServices",
        "trial_services": "trialServices",
        "usage_blocked": "usageBlocked",
      });
    }),
  );

export function comCrmSubscriptionSelfServiceResourceListContactSubscriptionsContentFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsContent$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsContent' from JSON`,
  );
}

/** @internal */
export const ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsResponse$inboundSchema:
  z.ZodMiniType<
    ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsResponse,
    unknown
  > = z.object({
    paging: types.optional(
      z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsPaging$inboundSchema
      ),
    ),
    content: types.optional(
      z.array(z.lazy(() =>
        ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsContent$inboundSchema
      )),
    ),
  });

export function comCrmSubscriptionSelfServiceResourceListContactSubscriptionsResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsResponse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmSubscriptionSelfServiceResourceListContactSubscriptionsResponse' from JSON`,
  );
}
