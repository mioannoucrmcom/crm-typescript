/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderSecurity = {
  secretAPIKey?: string | undefined;
  authorizationSelfService?: string | undefined;
};

/**
 * The type of the event
 *
 * @remarks
 *  * `DELIVERY` - Delivered to the customer’s address
 *  * `PICK_UP` - Picked up by the customer from a venue
 *  * `DIRECT_SALES` - Online sales of services
 */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderSupplyMethod = {
  Delivery: "DELIVERY",
  PickUp: "PICK_UP",
  DirectSale: "DIRECT_SALE",
} as const;
/**
 * The type of the event
 *
 * @remarks
 *  * `DELIVERY` - Delivered to the customer’s address
 *  * `PICK_UP` - Picked up by the customer from a venue
 *  * `DIRECT_SALES` - Online sales of services
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderSupplyMethod =
  ClosedEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderSupplyMethod
  >;

/**
 * The type of the event:
 *
 * @remarks
 *  * `DIRECT_DELIVERY` - Deliver locally by the business or the merchant
 *  * `COURIER_SERVICE` - Deliver by a courier service/shipping partner up
 *  * `PICKUP_POINT` - Deliver to a pick-up point
 */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderDeliveryMethod =
  {
    DirectDelivery: "DIRECT_DELIVERY",
    CourierService: "COURIER_SERVICE",
    PickupPoint: "PICKUP_POINT",
  } as const;
/**
 * The type of the event:
 *
 * @remarks
 *  * `DIRECT_DELIVERY` - Deliver locally by the business or the merchant
 *  * `COURIER_SERVICE` - Deliver by a courier service/shipping partner up
 *  * `PICKUP_POINT` - Deliver to a pick-up point
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderDeliveryMethod =
  ClosedEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderDeliveryMethod
  >;

/**
 * The Order’s Delivery service provider location id. Applicable only for Orders event-based charges with supply method delivery and delivery method courier service or pick up point.
 */
export type DeliveryServiceProviderLocation = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
};

export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderTimeUnit = {
  Second: "SECOND",
  Minute: "MINUTE",
  Hour: "HOUR",
  Day: "DAY",
  Week: "WEEK",
  Month: "MONTH",
  Year: "YEAR",
  Overall: "OVERALL",
} as const;
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderTimeUnit =
  ClosedEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderTimeUnit
  >;

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderRequestedDeliveryAt =
  {
    time?: number | undefined;
    timeUnit?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderTimeUnit
      | undefined;
    date?: number | undefined;
  };

/**
 * The type of the event
 */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderPaymentMethodType =
  {
    Card: "CARD",
    AccountDebit: "ACCOUNT_DEBIT",
    Wallet: "WALLET",
    CrmWallet: "CRM_WALLET",
    Cash: "CASH",
    Cheque: "CHEQUE",
  } as const;
/**
 * The type of the event
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderPaymentMethodType =
  ClosedEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderPaymentMethodType
  >;

export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderTypeRequest = {
  Amount: "AMOUNT",
  Percentage: "PERCENTAGE",
} as const;
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderTypeRequest =
  ClosedEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderTypeRequest
  >;

/**
 * Ad-hoc discount applied including tax
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderDiscountRequest =
  {
    amount?: number | undefined;
    type?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderTypeRequest
      | undefined;
  };

/**
 * Unlocks a promotion through a (promotion) pass by providing the pass code
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderPass = {
  /**
   * The pass code
   */
  code: string;
  /**
   * The pass pin. Required only if the pass is assiociated with a pin
   */
  pin?: string | undefined;
};

/**
 * Allows contacts to specify their preferred billing day at the time of ordering. Optional but applicable only when Anniversary billing is enabled and the order includes termed services with billing cycles longer than a week.
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderPreferredBillingDay =
  {
    /**
     * The subscription's billing day which can either be a day of a month (for subscriptions with billing cycles longer than a month) or a week day (for subscriptions with cycles of duration less than a month)
     */
    dayOfWeek?: string | undefined;
    /**
     * The subscription's billing day which can either be a day of a month (for subscriptions with billing cycles longer than a month) or a week day (for subscriptions with cycles of duration less than a month)
     */
    dayOfMonth?: number | undefined;
    /**
     * The subscription's billing month of year
     */
    monthOfYear?: string | undefined;
  };

export type Milestone = {
  /**
   * The order stage at which the milestone invoice will be issued. This stage must be one of the queue stages that include milestone settings. it’s also a required field.
   */
  stageId?: string | undefined;
  /**
   * This will be either be the value entered by the user or the value based on the queue configuration.
   */
  percentage?: number | undefined;
  /**
   * The milestone’s actual ammount to be paid on reaching a stage. Each milestone can either have a percentage or a specific amount, not both. The sum of all milestone amounts cannot exceed the order’s total cost.
   */
  amount?: number | undefined;
};

/**
 * Defines whether the price is tax inclusive or not. Defaults to the system's Taxation setting
 */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderTaxModel = {
  TaxInclusive: "TAX_INCLUSIVE",
  TaxExclusive: "TAX_EXCLUSIVE",
} as const;
/**
 * Defines whether the price is tax inclusive or not. Defaults to the system's Taxation setting
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderTaxModel =
  ClosedEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderTaxModel
  >;

export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentTaxModel =
  {
    TaxInclusive: "TAX_INCLUSIVE",
    TaxExclusive: "TAX_EXCLUSIVE",
  } as const;
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentTaxModel =
  ClosedEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentTaxModel
  >;

export type ItemComponent = {
  id?: string | undefined;
  quantity?: number | undefined;
  price?: number | undefined;
  taxModel?:
    | ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentTaxModel
    | undefined;
  priceTermsId?: string | undefined;
};

export type ItemRequest = {
  /**
   * Product identifier
   */
  id?: string | undefined;
  /**
   * Quantity of ordered items
   */
  quantity?: number | undefined;
  /**
   * The ordered item’s pricing informaiton. If not specified, then CMR.COM applies pricing rules and sets the most suitable price.
   */
  price?: number | undefined;
  /**
   * Defines whether the price is tax inclusive or not. Defaults to the system's Taxation setting
   */
  taxModel?:
    | ComCrmEstimateOrderSelfServiceResourceEstimateOrderTaxModel
    | undefined;
  /**
   * Order item notes
   */
  notes?: string | undefined;
  /**
   * Applicable and required for termed and one-time services. Also applicable for traceable physical goods which are ordered as Rentals.
   */
  priceTermsId?: string | undefined;
  /**
   * List of components that is applicable when ordering products of bundle composition or products that include modifiers.
   */
  components?: Array<ItemComponent> | undefined;
};

/**
 * The address country code
 */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderCountryCode = {
  Abw: "ABW",
  Afg: "AFG",
  Ago: "AGO",
  Aia: "AIA",
  Ala: "ALA",
  Alb: "ALB",
  And: "AND",
  Ant: "ANT",
  Are: "ARE",
  Arg: "ARG",
  Arm: "ARM",
  Asm: "ASM",
  Ata: "ATA",
  Atf: "ATF",
  Atg: "ATG",
  Aus: "AUS",
  Aut: "AUT",
  Aze: "AZE",
  Bdi: "BDI",
  Bel: "BEL",
  Ben: "BEN",
  Bes: "BES",
  Bfa: "BFA",
  Bgd: "BGD",
  Bgr: "BGR",
  Bhr: "BHR",
  Bhs: "BHS",
  Bih: "BIH",
  Blm: "BLM",
  Blr: "BLR",
  Blz: "BLZ",
  Bmu: "BMU",
  Bol: "BOL",
  Bra: "BRA",
  Brb: "BRB",
  Brn: "BRN",
  Btn: "BTN",
  Bvt: "BVT",
  Bwa: "BWA",
  Caf: "CAF",
  Can: "CAN",
  Cck: "CCK",
  Che: "CHE",
  Chl: "CHL",
  Chn: "CHN",
  Civ: "CIV",
  Cmr: "CMR",
  Cod: "COD",
  Cog: "COG",
  Cok: "COK",
  Col: "COL",
  Com: "COM",
  Cpv: "CPV",
  Cri: "CRI",
  Cub: "CUB",
  Cuw: "CUW",
  Cxr: "CXR",
  Cym: "CYM",
  Cyp: "CYP",
  Cze: "CZE",
  Deu: "DEU",
  Dji: "DJI",
  Dma: "DMA",
  Dnk: "DNK",
  Dom: "DOM",
  Dza: "DZA",
  Ecu: "ECU",
  Egy: "EGY",
  Eri: "ERI",
  Esh: "ESH",
  Esp: "ESP",
  Est: "EST",
  Eth: "ETH",
  Fin: "FIN",
  Fji: "FJI",
  Flk: "FLK",
  Fra: "FRA",
  Fro: "FRO",
  Fsm: "FSM",
  Gab: "GAB",
  Gbr: "GBR",
  Geo: "GEO",
  Ggy: "GGY",
  Gha: "GHA",
  Gib: "GIB",
  Gin: "GIN",
  Glp: "GLP",
  Gmb: "GMB",
  Gnb: "GNB",
  Gnq: "GNQ",
  Grc: "GRC",
  Grd: "GRD",
  Grl: "GRL",
  Gtm: "GTM",
  Guf: "GUF",
  Gum: "GUM",
  Guy: "GUY",
  Hkg: "HKG",
  Hmd: "HMD",
  Hnd: "HND",
  Hrv: "HRV",
  Hti: "HTI",
  Hun: "HUN",
  Idn: "IDN",
  Imn: "IMN",
  Ind: "IND",
  Iot: "IOT",
  Irl: "IRL",
  Irn: "IRN",
  Irq: "IRQ",
  Isl: "ISL",
  Isr: "ISR",
  Ita: "ITA",
  Jam: "JAM",
  Jey: "JEY",
  Jor: "JOR",
  Jpn: "JPN",
  Kaz: "KAZ",
  Ken: "KEN",
  Kgz: "KGZ",
  Khm: "KHM",
  Kir: "KIR",
  Kna: "KNA",
  Kor: "KOR",
  Kwt: "KWT",
  Lao: "LAO",
  Lbn: "LBN",
  Lbr: "LBR",
  Lby: "LBY",
  Lca: "LCA",
  Lie: "LIE",
  Lka: "LKA",
  Lso: "LSO",
  Ltu: "LTU",
  Lux: "LUX",
  Lva: "LVA",
  Mac: "MAC",
  Maf: "MAF",
  Mar: "MAR",
  Mco: "MCO",
  Mda: "MDA",
  Mdg: "MDG",
  Mdv: "MDV",
  Mex: "MEX",
  Mhl: "MHL",
  Mkd: "MKD",
  Mli: "MLI",
  Mlt: "MLT",
  Mmr: "MMR",
  Mne: "MNE",
  Mng: "MNG",
  Mnp: "MNP",
  Moz: "MOZ",
  Mrt: "MRT",
  Msr: "MSR",
  Mtq: "MTQ",
  Mus: "MUS",
  Mwi: "MWI",
  Mys: "MYS",
  Myt: "MYT",
  Nam: "NAM",
  Ncl: "NCL",
  Ner: "NER",
  Nfk: "NFK",
  Nga: "NGA",
  Nic: "NIC",
  Niu: "NIU",
  Nld: "NLD",
  Nor: "NOR",
  Npl: "NPL",
  Nru: "NRU",
  Nzl: "NZL",
  Omn: "OMN",
  Pak: "PAK",
  Pan: "PAN",
  Pcn: "PCN",
  Per: "PER",
  Phl: "PHL",
  Plw: "PLW",
  Png: "PNG",
  Pol: "POL",
  Pri: "PRI",
  Prk: "PRK",
  Prt: "PRT",
  Pry: "PRY",
  Pse: "PSE",
  Pyf: "PYF",
  Qat: "QAT",
  Reu: "REU",
  Rks: "RKS",
  Rou: "ROU",
  Rus: "RUS",
  Rwa: "RWA",
  Sau: "SAU",
  Sdn: "SDN",
  Sen: "SEN",
  Sgp: "SGP",
  Sgs: "SGS",
  Shn: "SHN",
  Sjm: "SJM",
  Slb: "SLB",
  Sle: "SLE",
  Slv: "SLV",
  Smr: "SMR",
  Som: "SOM",
  Spm: "SPM",
  Srb: "SRB",
  Ssd: "SSD",
  Stp: "STP",
  Sur: "SUR",
  Svk: "SVK",
  Svn: "SVN",
  Swe: "SWE",
  Swz: "SWZ",
  Sxm: "SXM",
  Syc: "SYC",
  Syr: "SYR",
  Tca: "TCA",
  Tcd: "TCD",
  Tgo: "TGO",
  Tha: "THA",
  Tjk: "TJK",
  Tkl: "TKL",
  Tkm: "TKM",
  Tls: "TLS",
  Ton: "TON",
  Tto: "TTO",
  Tun: "TUN",
  Tur: "TUR",
  Tuv: "TUV",
  Twn: "TWN",
  Tza: "TZA",
  Uga: "UGA",
  Ukr: "UKR",
  Umi: "UMI",
  Ury: "URY",
  Usa: "USA",
  Uzb: "UZB",
  Vat: "VAT",
  Vct: "VCT",
  Ven: "VEN",
  Vgb: "VGB",
  Vir: "VIR",
  Vnm: "VNM",
  Vut: "VUT",
  Wlf: "WLF",
  Wsm: "WSM",
  Yem: "YEM",
  Zaf: "ZAF",
  Zmb: "ZMB",
  Zwe: "ZWE",
} as const;
/**
 * The address country code
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderCountryCode =
  ClosedEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderCountryCode
  >;

/**
 * Details about the address
 */
export type CurrentLocation = {
  /**
   * The contact address unique identifier
   */
  id?: string | undefined;
  /**
   * The address type
   */
  addressType?: string | undefined;
  /**
   * The address name
   */
  addressName?: string | undefined;
  /**
   * The address line 1
   */
  addressLine1?: string | undefined;
  /**
   * The address line 2
   */
  addressLine2?: string | undefined;
  /**
   * The address state/province/county
   */
  stateProvinceCounty?: string | undefined;
  /**
   * The address town/city
   */
  townCity?: string | undefined;
  /**
   * The address postal code
   */
  postalCode?: string | undefined;
  /**
   * The address country code
   */
  countryCode?:
    | ComCrmEstimateOrderSelfServiceResourceEstimateOrderCountryCode
    | undefined;
  /**
   * The address geolocation latitude
   */
  lat?: number | undefined;
  /**
   * The address geolocation longtitude
   */
  lon?: number | undefined;
  /**
   * The address unique Google identifier
   */
  googlePlaceId?: string | undefined;
};

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderRequest = {
  accountId: string;
  /**
   * The type of the event
   *
   * @remarks
   *  * `DELIVERY` - Delivered to the customer’s address
   *  * `PICK_UP` - Picked up by the customer from a venue
   *  * `DIRECT_SALES` - Online sales of services
   */
  supplyMethod: ComCrmEstimateOrderSelfServiceResourceEstimateOrderSupplyMethod;
  /**
   * The type of the event:
   *
   * @remarks
   *  * `DIRECT_DELIVERY` - Deliver locally by the business or the merchant
   *  * `COURIER_SERVICE` - Deliver by a courier service/shipping partner up
   *  * `PICKUP_POINT` - Deliver to a pick-up point
   */
  deliveryMethod:
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderDeliveryMethod;
  /**
   * The Order’s Delivery service provider id. Applicable only for Orders event-based charges with supply method delivery and delivery method courier service or pick up point.
   */
  deliveryServiceProvider?: string | undefined;
  /**
   * The Order’s Delivery service provider location id. Applicable only for Orders event-based charges with supply method delivery and delivery method courier service or pick up point.
   */
  deliveryServiceProviderLocation?: DeliveryServiceProviderLocation | undefined;
  fulfilledBy?: string | null | undefined;
  requestedDeliveryAt?:
    | ComCrmEstimateOrderSelfServiceResourceEstimateOrderRequestedDeliveryAt
    | undefined;
  /**
   * Appicable and required when the supply method is Delivery
   */
  addressId?: string | undefined;
  notes?: string | undefined;
  /**
   * The queue id retrieval for milestone invoice payment plan
   */
  queueId?: string | undefined;
  /**
   * An order estimation id already obtained by previous calls to the same Web API. To be used during the ordering flow and in cases where the same API is triggered multiple times since the user modifies the ordered items. So the same estimation id can be reused in subsequent calls for estimating the same order
   */
  estimationId?: string | undefined;
  /**
   * The queue id retrieval for milestone invoice payment plan
   */
  useWalletFunds?: boolean | undefined;
  /**
   * Defines whether requested wallet amount to be used will be blocked or not (blocked amount is released after a specific period of time elapsed or estimates is used on a order submission)
   */
  blockWalletFunds?: boolean | undefined;
  /**
   * How much CRM.COM Wallet funds the consumer is intended to use to pay off the order.
   */
  walletFundsAmount?: number | undefined;
  /**
   * The type of the event
   */
  paymentMethodType:
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderPaymentMethodType;
  /**
   * Ad-hoc discount applied including tax
   */
  discount?:
    | ComCrmEstimateOrderSelfServiceResourceEstimateOrderDiscountRequest
    | undefined;
  /**
   * Unlocks a promotion through a (promotion) pass by providing the pass code
   */
  pass?: ComCrmEstimateOrderSelfServiceResourceEstimateOrderPass | undefined;
  /**
   * Allows contacts to specify their preferred billing day at the time of ordering. Optional but applicable only when Anniversary billing is enabled and the order includes termed services with billing cycles longer than a week.
   */
  preferredBillingDay?:
    | ComCrmEstimateOrderSelfServiceResourceEstimateOrderPreferredBillingDay
    | undefined;
  /**
   * These milestones will default to the milestones based on the queue type selected - unless they are edited by the user.
   */
  milestones?: Array<Milestone> | undefined;
  /**
   * List of ordered items. At least one must be specified.
   */
  items: Array<ItemRequest>;
  /**
   * Details about the address
   */
  currentLocation?: CurrentLocation | undefined;
};

/**
 * Details about the organisation from where such event was posted
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderFulfilledBy = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The organisation name
   */
  name?: string | undefined;
};

export const OrderEstimateUot = {
  Second: "SECOND",
  Minute: "MINUTE",
  Hour: "HOUR",
  Day: "DAY",
  Week: "WEEK",
  Month: "MONTH",
  Year: "YEAR",
  Overall: "OVERALL",
} as const;
export type OrderEstimateUot = OpenEnum<typeof OrderEstimateUot>;

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderEstimatedDelivery =
  {
    timeToDelivery?: number | undefined;
    uot?: OrderEstimateUot | undefined;
    deliveredAt?: number | undefined;
  };

/**
 * The queue information
 */
export type Queue = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
};

/**
 * Shows the reason why the order cannot be placed
 */
export const OrderFailureReason = {
  MinimumCost: "MINIMUM_COST",
  TaxCalculation: "TAX_CALCULATION",
} as const;
/**
 * Shows the reason why the order cannot be placed
 */
export type OrderFailureReason = OpenEnum<typeof OrderFailureReason>;

/**
 * An estimation on if the Order can be placed and if yes, then its detailed information that includes fulfillment and invoicing details.
 */
export type OrderEstimate = {
  /**
   * Indicates whether minimum order amount is met and order can proceed with submission.
   */
  orderingAllowed?: boolean | undefined;
  /**
   * Defines the minimum order amount as specified in the fulfillment policy of the organisation fulfilling the order.
   */
  minimumAmount?: number | undefined;
  /**
   * Details about the organisation from where such event was posted
   */
  fulfilledBy?:
    | ComCrmEstimateOrderSelfServiceResourceEstimateOrderFulfilledBy
    | undefined;
  estimatedDelivery?:
    | ComCrmEstimateOrderSelfServiceResourceEstimateOrderEstimatedDelivery
    | undefined;
  /**
   * The queue information
   */
  queue?: Queue | undefined;
  /**
   * Shows the reason why the order cannot be placed
   */
  orderFailureReason?: OrderFailureReason | undefined;
  subscriptionEstimationAmount?: number | undefined;
};

/**
 * Shows the reason for failing to calculating taxes for the invoice, typically because there's an issue with the online taxation service
 */
export const InvoiceEstimateTaxFailureReason = {
  InvalidAddress: "INVALID_ADDRESS",
  ApiError: "API_ERROR",
  CommunicationError: "COMMUNICATION_ERROR",
} as const;
/**
 * Shows the reason for failing to calculating taxes for the invoice, typically because there's an issue with the online taxation service
 */
export type InvoiceEstimateTaxFailureReason = OpenEnum<
  typeof InvoiceEstimateTaxFailureReason
>;

/**
 * Tax rate code
 */
export const InvoiceEstimateTaxesBreakdownTaxCode = {
  Vat: "VAT",
  TaxExempt: "TAX_EXEMPT",
  SalesTax: "SALES_TAX",
  Other: "OTHER",
} as const;
/**
 * Tax rate code
 */
export type InvoiceEstimateTaxesBreakdownTaxCode = OpenEnum<
  typeof InvoiceEstimateTaxesBreakdownTaxCode
>;

/**
 * The applied tax rate
 */
export type InvoiceEstimateTaxesBreakdownTaxRate = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * Tax rate name
   */
  name?: string | undefined;
  /**
   * Tax rate code
   */
  taxCode?: InvoiceEstimateTaxesBreakdownTaxCode | undefined;
  /**
   * The applied tax rate’s percentage that was valid on the date on which the rate was applied
   */
  percentage?: number | undefined;
};

/**
 * Applicable only when a Tax Exempt rate was applied. Shows whether the tax exempt rate was applied because the Contact or the Product was marked as tax exempt.
 */
export const InvoiceEstimateTaxesBreakdownTaxExemptReason = {
  Contact: "CONTACT",
  Product: "PRODUCT",
} as const;
/**
 * Applicable only when a Tax Exempt rate was applied. Shows whether the tax exempt rate was applied because the Contact or the Product was marked as tax exempt.
 */
export type InvoiceEstimateTaxesBreakdownTaxExemptReason = OpenEnum<
  typeof InvoiceEstimateTaxesBreakdownTaxExemptReason
>;

export type InvoiceEstimateTaxesBreakdown = {
  /**
   * The applied tax rate
   */
  taxRate?: InvoiceEstimateTaxesBreakdownTaxRate | undefined;
  /**
   * The applied tax amount
   */
  taxAmount?: number | undefined;
  /**
   * Applicable only when a Tax Exempt rate was applied. Shows whether the tax exempt rate was applied because the Contact or the Product was marked as tax exempt.
   */
  taxExemptReason?: InvoiceEstimateTaxesBreakdownTaxExemptReason | undefined;
};

/**
 * Invoiced period applicable only when invoicing a termed service.
 */
export type ItemPeriod = {
  /**
   * The date from which the service is invoiced/credited
   */
  from?: number | undefined;
  /**
   * The date until which the service is invoiced/credited
   */
  to?: number | undefined;
};

export type InvoiceEstimateItemDiscount = {
  /**
   * The discount amount of the line
   */
  discountAmount?: number | undefined;
  /**
   * The discount percentage of the line
   */
  discountPercentage?: number | undefined;
  discountInclTax?: number | undefined;
};

/**
 * The product’s classification
 */
export const InvoiceEstimateProductClassification = {
  TermedService: "TERMED_SERVICE",
  UsageService: "USAGE_SERVICE",
  OneTimeService: "ONE_TIME_SERVICE",
  TraceablePhysicalGood: "TRACEABLE_PHYSICAL_GOOD",
  NonTraceablePhysicalGood: "NON_TRACEABLE_PHYSICAL_GOOD",
  ExpensesService: "EXPENSES_SERVICE",
} as const;
/**
 * The product’s classification
 */
export type InvoiceEstimateProductClassification = OpenEnum<
  typeof InvoiceEstimateProductClassification
>;

export type InvoiceEstimateProduct = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * Product’s SKU
   */
  sku?: string | undefined;
  /**
   * Product’s name
   */
  name?: string | undefined;
  /**
   * The product’s classification
   */
  classification?: InvoiceEstimateProductClassification | undefined;
  /**
   * Indicates if the product is stockable
   */
  isStockable?: boolean | undefined;
};

/**
 * The product’s classification
 */
export const InvoiceEstimateBundleProductClassification = {
  TermedService: "TERMED_SERVICE",
  UsageService: "USAGE_SERVICE",
  OneTimeService: "ONE_TIME_SERVICE",
  TraceablePhysicalGood: "TRACEABLE_PHYSICAL_GOOD",
  NonTraceablePhysicalGood: "NON_TRACEABLE_PHYSICAL_GOOD",
  ExpensesService: "EXPENSES_SERVICE",
} as const;
/**
 * The product’s classification
 */
export type InvoiceEstimateBundleProductClassification = OpenEnum<
  typeof InvoiceEstimateBundleProductClassification
>;

export type ItemBundleProduct = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * Product’s SKU
   */
  sku?: string | undefined;
  /**
   * Product’s name
   */
  name?: string | undefined;
  /**
   * The product’s classification
   */
  classification?: InvoiceEstimateBundleProductClassification | undefined;
  /**
   * Indicates if the product is stockable
   */
  isStockable?: boolean | undefined;
};

/**
 * Tax rate code
 */
export const ItemTaxCode = {
  Vat: "VAT",
  TaxExempt: "TAX_EXEMPT",
  SalesTax: "SALES_TAX",
  Other: "OTHER",
} as const;
/**
 * Tax rate code
 */
export type ItemTaxCode = OpenEnum<typeof ItemTaxCode>;

/**
 * The applied tax rate
 */
export type ItemTaxRate = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * Tax rate name
   */
  name?: string | undefined;
  /**
   * Tax rate code
   */
  taxCode?: ItemTaxCode | undefined;
  /**
   * The applied tax rate’s percentage that was valid on the date on which the rate was applied
   */
  percentage?: number | undefined;
};

/**
 * Applicable only when a Tax Exempt rate was applied. Shows whether the tax exempt rate was applied because the Contact or the Product was marked as tax exempt.
 */
export const ItemTaxExemptReason = {
  Contact: "CONTACT",
  Product: "PRODUCT",
} as const;
/**
 * Applicable only when a Tax Exempt rate was applied. Shows whether the tax exempt rate was applied because the Contact or the Product was marked as tax exempt.
 */
export type ItemTaxExemptReason = OpenEnum<typeof ItemTaxExemptReason>;

export type ItemAppliedTax = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The applied tax rate
   */
  taxRate?: ItemTaxRate | undefined;
  /**
   * The applied tax amount
   */
  taxAmount?: number | undefined;
  /**
   * Applicable only when a Tax Exempt rate was applied. Shows whether the tax exempt rate was applied because the Contact or the Product was marked as tax exempt.
   */
  taxExemptReason?: ItemTaxExemptReason | undefined;
  /**
   * The tax category code assigned by Taxation Service (e.g., clothing, food).
   */
  taxCategory?: string | undefined;
  /**
   * The exempt amount for this jurisdiction as calculated by Taxation Service.
   */
  exemptAmount?: number | undefined;
  /**
   * The name of the jurisdiction (e.g., state, county, city) as returned by Taxation Service.
   */
  jurisName?: string | undefined;
  /**
   * The type of jurisdiction (e.g., State, County, City, Special) as returned by Taxation Service.
   */
  jurisType?: string | undefined;
  /**
   * The tax region identifier as returned by Taxation Service.
   */
  taxRegion?: string | undefined;
  /**
   * The type of tax applied (e.g., Sales, Use, Lodging) by Taxation Service.
   */
  taxType?: string | undefined;
};

export type InvoiceEstimateItem = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The quantity of the product
   */
  quantity?: number | undefined;
  /**
   * The price per unit of the product
   */
  unitPrice?: number | undefined;
  /**
   * The net amount
   */
  netAmount?: number | undefined;
  /**
   * Total taxed amount for this product
   */
  taxAmount?: number | undefined;
  /**
   * The sub total of the financial transaction line
   */
  subTotal?: number | undefined;
  /**
   * Invoiced period applicable only when invoicing a termed service.
   */
  period?: ItemPeriod | undefined;
  discount?: InvoiceEstimateItemDiscount | undefined;
  product?: InvoiceEstimateProduct | undefined;
  bundleProduct?: ItemBundleProduct | undefined;
  appliedTaxes?: Array<ItemAppliedTax> | undefined;
  /**
   * The price of the product as this is configured in the product catalog (including tax or not depending on the tax model)
   */
  pricing?: number | undefined;
  /**
   * The quantity of the product that is available for the customer to order
   */
  inStock?: number | undefined;
};

/**
 * Type of discount applied
 */
export const InvoiceEstimateType = {
  AdHoc: "AD_HOC",
  Promotion: "PROMOTION",
  AutoApplied: "AUTO_APPLIED",
} as const;
/**
 * Type of discount applied
 */
export type InvoiceEstimateType = OpenEnum<typeof InvoiceEstimateType>;

/**
 * The applied Promotion. Applicable when discount type is Promotion
 */
export type InvoiceEstimatePromotion = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
};

export type InvoiceEstimateDiscount = {
  /**
   * The deducted amount
   */
  amount?: number | undefined;
  /**
   * Type of discount applied
   */
  type?: InvoiceEstimateType | undefined;
  /**
   * The applied Promotion. Applicable when discount type is Promotion
   */
  promotion?: InvoiceEstimatePromotion | undefined;
};

/**
 * The outright order’s invoicing information. This invoice estimation includes only physical goods ordered as well as One-Time services. It does not include any invoicing or billing information for ordered termed services
 */
export type InvoiceEstimate = {
  /**
   * Invoice or Credit Notes issue date
   */
  issuedDate?: number | undefined;
  /**
   * Invoice due date
   */
  dueDate?: number | undefined;
  /**
   * The currency code
   */
  currencyCode?: string | undefined;
  /**
   * Total Net amount
   */
  net?: number | undefined;
  /**
   * Total discount amount
   */
  discount?: number | undefined;
  /**
   * Total tax amount
   */
  tax?: number | undefined;
  /**
   * Total amount of the invoice that will be generated. Includes taxed and disoucnt amounts
   */
  total?: number | undefined;
  walletFundsAmount?: number | undefined;
  /**
   * The amount that will be due at the time of the estimation
   */
  amountDue?: number | undefined;
  discountInclTax?: number | undefined;
  /**
   * Amount that the customer needs to pay at the time of the estimation
   */
  amountToCollect?: number | undefined;
  /**
   * Sum of all products’ prices as these are defined in the product catalog
   */
  totalPrice?: number | undefined;
  /**
   * Available account funds that can be used to pay off the Invoice. Available when the account is in credit and/or the account has a credit limit. Account funds are calculated as the account’s credit limit minus the amount in credit. for example credit limit is 100 and account credit is 50, then account fund sis returned as 150
   */
  accountCredit?: number | undefined;
  /**
   * Indicates whether taxes failed to be calculated by the online taxation service
   */
  taxCalculationFailed?: boolean | undefined;
  /**
   * Shows the reason for failing to calculating taxes for the invoice, typically because there's an issue with the online taxation service
   */
  taxFailureReason?: InvoiceEstimateTaxFailureReason | undefined;
  taxesBreakdown?: Array<InvoiceEstimateTaxesBreakdown> | undefined;
  items?: Array<InvoiceEstimateItem> | undefined;
  discounts?: Array<InvoiceEstimateDiscount> | undefined;
};

export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderSubscriptionState =
  {
    Active: "ACTIVE",
    Churned: "CHURNED",
    Inactive: "INACTIVE",
  } as const;
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderSubscriptionState =
  OpenEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderSubscriptionState
  >;

/**
 * The billing cycle's unit of time
 */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderUotTaxCalculation =
  {
    Second: "SECOND",
    Minute: "MINUTE",
    Hour: "HOUR",
    Day: "DAY",
    Week: "WEEK",
    Month: "MONTH",
    Year: "YEAR",
    Overall: "OVERALL",
  } as const;
/**
 * The billing cycle's unit of time
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderUotTaxCalculation =
  OpenEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderUotTaxCalculation
  >;

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingPeriod = {
  /**
   * The billing cycle's duration
   */
  duration?: number | undefined;
  /**
   * The billing cycle's unit of time
   */
  uot?:
    | ComCrmEstimateOrderSelfServiceResourceEstimateOrderUotTaxCalculation
    | undefined;
};

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingDay = {
  /**
   * Day of week
   */
  dayOfWeek?: string | undefined;
  /**
   * Day of month
   */
  dayOfMonth?: number | undefined;
  /**
   * Month of year
   */
  monthOfYear?: string | undefined;
};

export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingModel = {
  PreBill: "PRE_BILL",
  PostBill: "POST_BILL",
} as const;
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingModel =
  OpenEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingModel
  >;

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderTerms = {
  billingPeriod?:
    | ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingPeriod
    | undefined;
  billingDay?:
    | ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingDay
    | undefined;
  billingModel?:
    | ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingModel
    | undefined;
};

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderSubscription = {
  state?:
    | ComCrmEstimateOrderSelfServiceResourceEstimateOrderSubscriptionState
    | undefined;
  terms?: ComCrmEstimateOrderSelfServiceResourceEstimateOrderTerms | undefined;
};

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderPausedPeriod = {
  durationInDays?: number | undefined;
  startsOn?: number | undefined;
  endsOn?: number | undefined;
};

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderBilledPeriod = {
  fromDate?: number | undefined;
  toDate?: number | undefined;
};

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderTotals = {
  totalAmount?: number | undefined;
  taxAmount?: number | undefined;
  netAmount?: number | undefined;
  discountAmount?: number | undefined;
};

export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderFailureReason1 =
  {
    TaxCalculation: "TAX_CALCULATION",
  } as const;
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderFailureReason1 =
  ClosedEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderFailureReason1
  >;

/**
 * Shows the reason for failing to calculating taxes for the invoice, typically because there's an issue with the online taxation service
 */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxFailureReason =
  {
    InvalidAddress: "INVALID_ADDRESS",
    ApiError: "API_ERROR",
    CommunicationError: "COMMUNICATION_ERROR",
  } as const;
/**
 * Shows the reason for failing to calculating taxes for the invoice, typically because there's an issue with the online taxation service
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxFailureReason =
  OpenEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxFailureReason
  >;

export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdownTaxCode =
  {
    Vat: "VAT",
    TaxExempt: "TAX_EXEMPT",
    SalesTax: "SALES_TAX",
    Other: "OTHER",
  } as const;
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdownTaxCode =
  OpenEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdownTaxCode
  >;

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdownTaxRate =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    name?: string | undefined;
    taxCode?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdownTaxCode
      | undefined;
    percentage?: number | undefined;
  };

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdown =
  {
    taxRate?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdownTaxRate
      | undefined;
    taxAmount?: number | undefined;
  };

/**
 * Details about the applied discount
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemDiscount =
  {
    discountAmount?: number | undefined;
    discountPercentage?: number | undefined;
    discountInclTax?: number | undefined;
  };

/**
 * Product type classification
 */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemProductClassification =
  {
    TermedService: "TERMED_SERVICE",
    UsageService: "USAGE_SERVICE",
    OneTimeService: "ONE_TIME_SERVICE",
    TraceablePhysicalGood: "TRACEABLE_PHYSICAL_GOOD",
    NonTraceablePhysicalGood: "NON_TRACEABLE_PHYSICAL_GOOD",
    ExpensesService: "EXPENSES_SERVICE",
  } as const;
/**
 * Product type classification
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemProductClassification =
  OpenEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemProductClassification
  >;

/**
 * Details about the product
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemProduct =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The product name
     */
    name?: string | undefined;
    /**
     * The product SKU
     */
    sku?: string | undefined;
    /**
     * Product type classification
     */
    classification?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemProductClassification
      | undefined;
  };

/**
 * Product type classification
 */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemBundleProductClassification =
  {
    TermedService: "TERMED_SERVICE",
    UsageService: "USAGE_SERVICE",
    OneTimeService: "ONE_TIME_SERVICE",
    TraceablePhysicalGood: "TRACEABLE_PHYSICAL_GOOD",
    NonTraceablePhysicalGood: "NON_TRACEABLE_PHYSICAL_GOOD",
    ExpensesService: "EXPENSES_SERVICE",
  } as const;
/**
 * Product type classification
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemBundleProductClassification =
  OpenEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemBundleProductClassification
  >;

/**
 * Defines the main product that the line item is component to it (applicable only when the line item is invoiced as a component of another product)
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemBundleProduct =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The product name
     */
    name?: string | undefined;
    /**
     * The product SKU
     */
    sku?: string | undefined;
    /**
     * Product type classification
     */
    classification?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemBundleProductClassification
      | undefined;
  };

/**
 * Termed service’s debited/credited period
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemPeriod =
  {
    /**
     * The date from which the service is invoiced/credited
     */
    from?: number | undefined;
    /**
     * The date until which the service is invoiced/credited
     */
    to?: number | undefined;
  };

export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemTaxCode =
  {
    Vat: "VAT",
    TaxExempt: "TAX_EXEMPT",
    SalesTax: "SALES_TAX",
    Other: "OTHER",
  } as const;
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemTaxCode =
  OpenEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemTaxCode
  >;

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemTaxRate =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    name?: string | undefined;
    taxCode?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemTaxCode
      | undefined;
    percentage?: number | undefined;
  };

export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemTaxExemptReason =
  {
    Contact: "CONTACT",
    Product: "PRODUCT",
  } as const;
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemTaxExemptReason =
  OpenEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemTaxExemptReason
  >;

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemAppliedTax =
  {
    taxRate?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemTaxRate
      | undefined;
    taxAmount?: number | undefined;
    taxExemptReason?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemTaxExemptReason
      | undefined;
  };

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItem = {
  quantity?: number | undefined;
  unitPrice?: number | undefined;
  netAmount?: number | undefined;
  taxAmount?: number | undefined;
  subTotal?: number | undefined;
  /**
   * The price of the product as this is configured in the product catalog (including tax or not depending on the tax model)
   */
  pricing?: number | undefined;
  /**
   * Details about the applied discount
   */
  discount?:
    | ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemDiscount
    | undefined;
  /**
   * Details about the product
   */
  product?:
    | ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemProduct
    | undefined;
  /**
   * Defines the main product that the line item is component to it (applicable only when the line item is invoiced as a component of another product)
   */
  bundleProduct?:
    | ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemBundleProduct
    | undefined;
  /**
   * Termed service’s debited/credited period
   */
  period?:
    | ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemPeriod
    | undefined;
  /**
   * Details about the applied taxes
   */
  appliedTaxes?:
    | Array<
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemAppliedTax
    >
    | undefined;
};

/**
 * Type of discount applied
 */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingType =
  {
    AdHoc: "AD_HOC",
    Promotion: "PROMOTION",
    AutoApplied: "AUTO_APPLIED",
  } as const;
/**
 * Type of discount applied
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingType =
  OpenEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingType
  >;

/**
 * The applied Promotion. Applicable when discount type is Promotion
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingPromotion =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The entity name
     */
    name?: string | undefined;
  };

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingDiscount =
  {
    /**
     * The deducted amount
     */
    amount?: number | undefined;
    /**
     * Type of discount applied
     */
    type?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingType
      | undefined;
    /**
     * The applied Promotion. Applicable when discount type is Promotion
     */
    promotion?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingPromotion
      | undefined;
  };

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicing = {
  issuedDate?: number | undefined;
  dueDate?: number | undefined;
  currencyCode?: string | undefined;
  isCredit?: boolean | undefined;
  totalNetAmount?: number | undefined;
  totalDiscountAmount?: number | undefined;
  totalTaxAmount?: number | undefined;
  /**
   * Total amount of the invoice that will be generated. Includes taxed and disoucnt amounts
   */
  totalAmount?: number | undefined;
  walletFundsAmount?: number | undefined;
  /**
   * The amount that will be due at the time of the estimation
   */
  amountDue?: number | undefined;
  /**
   * Amount that the customer needs to pay at the time of the estimation
   */
  amountToCollect?: number | undefined;
  totalDiscountInclTax?: number | undefined;
  /**
   * Sum of all products’ prices as these are defined in the product catalog
   */
  totalPrice?: number | undefined;
  accountFunds?: number | undefined;
  /**
   * Indicates whether taxes failed to be calculated by the online taxation service
   */
  taxCalculationFailed?: boolean | undefined;
  /**
   * Shows the reason for failing to calculating taxes for the invoice, typically because there's an issue with the online taxation service
   */
  taxFailureReason?:
    | ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxFailureReason
    | undefined;
  taxesBreakdown?:
    | Array<
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdown
    >
    | undefined;
  lineItems?:
    | Array<ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItem>
    | undefined;
  discounts?:
    | Array<
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingDiscount
    >
    | undefined;
};

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingEstimate =
  {
    billedPeriod?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderBilledPeriod
      | undefined;
    totals?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderTotals
      | undefined;
    failureReason?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderFailureReason1
      | undefined;
    invoicing?:
      | Array<ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicing>
      | undefined;
    billingDate?: number | undefined;
  };

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderService = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
  /**
   * The entity sku
   */
  sku?: string | undefined;
};

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsAdded =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The entity name
     */
    name?: string | undefined;
    /**
     * The entity sku
     */
    sku?: string | undefined;
  };

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsRemoved =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The entity name
     */
    name?: string | undefined;
    /**
     * The entity sku
     */
    sku?: string | undefined;
  };

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsChange =
  {
    service?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderService
      | undefined;
    componentsAdded?:
      | Array<
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsAdded
      >
      | undefined;
    componentsRemoved?:
      | Array<
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsRemoved
      >
      | undefined;
  };

export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderFailureReason2 =
  {
    TaxCalculation: "TAX_CALCULATION",
  } as const;
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderFailureReason2 =
  ClosedEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderFailureReason2
  >;

/**
 * Service's State
 */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddState =
  {
    Draft: "DRAFT",
    Effective: "EFFECTIVE",
    NotEffective: "NOT_EFFECTIVE",
    Paused: "PAUSED",
    Regretted: "REGRETTED",
    Cancelled: "CANCELLED",
    Swapped: "SWAPPED",
    Removed: "REMOVED",
  } as const;
/**
 * Service's State
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddState =
  OpenEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddState
  >;

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddProduct =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The entity name
     */
    name?: string | undefined;
    /**
     * The entity sku
     */
    sku?: string | undefined;
  };

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddTrialPeriod =
  {
    startsOn?: number | undefined;
    endsOn?: number | undefined;
  };

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddDependency =
  {
    itemType?: string | undefined;
    itemId?: string | undefined;
    itemName?: string | undefined;
    itemSku?: string | undefined;
    dependency?: string | undefined;
    dependencyMet?: boolean | undefined;
    quantity?: number | undefined;
    missingQuantity?: number | undefined;
  };

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddComponentDependency =
  {
    itemType?: string | undefined;
    itemId?: string | undefined;
    itemName?: string | undefined;
    itemSku?: string | undefined;
    dependency?: string | undefined;
    dependencyMet?: boolean | undefined;
    quantity?: number | undefined;
    missingQuantity?: number | undefined;
  };

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddComponent =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    sku?: string | undefined;
    name?: string | undefined;
    quantity?: number | undefined;
    dependencies?:
      | Array<
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddComponentDependency
      >
      | undefined;
  };

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAdd = {
  /**
   * Service's State
   */
  state?:
    | ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddState
    | undefined;
  product?:
    | ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddProduct
    | undefined;
  trialPeriod?:
    | ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddTrialPeriod
    | undefined;
  quantity?: number | undefined;
  dependencies?:
    | Array<
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddDependency
    >
    | undefined;
  components?:
    | Array<
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddComponent
    >
    | undefined;
};

/**
 * Service's State
 */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemoveState =
  {
    Draft: "DRAFT",
    Effective: "EFFECTIVE",
    NotEffective: "NOT_EFFECTIVE",
    Paused: "PAUSED",
    Regretted: "REGRETTED",
    Cancelled: "CANCELLED",
    Swapped: "SWAPPED",
    Removed: "REMOVED",
  } as const;
/**
 * Service's State
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemoveState =
  OpenEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemoveState
  >;

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemoveProduct =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The entity name
     */
    name?: string | undefined;
    /**
     * The entity sku
     */
    sku?: string | undefined;
  };

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemove =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * Service's State
     */
    state?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemoveState
      | undefined;
    product?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemoveProduct
      | undefined;
  };

/**
 * Service's State
 */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeState =
  {
    Draft: "DRAFT",
    Effective: "EFFECTIVE",
    NotEffective: "NOT_EFFECTIVE",
    Paused: "PAUSED",
    Regretted: "REGRETTED",
    Cancelled: "CANCELLED",
    Swapped: "SWAPPED",
    Removed: "REMOVED",
  } as const;
/**
 * Service's State
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeState =
  OpenEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeState
  >;

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeProduct =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The entity name
     */
    name?: string | undefined;
    /**
     * The entity sku
     */
    sku?: string | undefined;
  };

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderChangeToProduct =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The entity name
     */
    name?: string | undefined;
    /**
     * The entity sku
     */
    sku?: string | undefined;
  };

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeDependency =
  {
    itemType?: string | undefined;
    itemId?: string | undefined;
    itemName?: string | undefined;
    itemSku?: string | undefined;
    dependency?: string | undefined;
    dependencyMet?: boolean | undefined;
    quantity?: number | undefined;
    missingQuantity?: number | undefined;
  };

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChange =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * Service's State
     */
    state?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeState
      | undefined;
    product?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeProduct
      | undefined;
    changeToProduct?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderChangeToProduct
      | undefined;
    quantity?: number | undefined;
    dependencies?:
      | Array<
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeDependency
      >
      | undefined;
  };

/**
 * Service's State
 */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateState =
  {
    Draft: "DRAFT",
    Effective: "EFFECTIVE",
    NotEffective: "NOT_EFFECTIVE",
    Paused: "PAUSED",
    Regretted: "REGRETTED",
    Cancelled: "CANCELLED",
    Swapped: "SWAPPED",
    Removed: "REMOVED",
  } as const;
/**
 * Service's State
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateState =
  OpenEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateState
  >;

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateProduct =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The entity name
     */
    name?: string | undefined;
    /**
     * The entity sku
     */
    sku?: string | undefined;
  };

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateTrialPeriod =
  {
    startsOn?: number | undefined;
    endsOn?: number | undefined;
  };

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateDependency =
  {
    itemType?: string | undefined;
    itemId?: string | undefined;
    itemName?: string | undefined;
    itemSku?: string | undefined;
    dependency?: string | undefined;
    dependencyMet?: boolean | undefined;
    quantity?: number | undefined;
    missingQuantity?: number | undefined;
  };

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateComponentDependency =
  {
    itemType?: string | undefined;
    itemId?: string | undefined;
    itemName?: string | undefined;
    itemSku?: string | undefined;
    dependency?: string | undefined;
    dependencyMet?: boolean | undefined;
    quantity?: number | undefined;
    missingQuantity?: number | undefined;
  };

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateComponent =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    sku?: string | undefined;
    name?: string | undefined;
    quantity?: number | undefined;
    dependencies?:
      | Array<
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateComponentDependency
      >
      | undefined;
  };

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdate =
  {
    /**
     * Service's State
     */
    state?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateState
      | undefined;
    product?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateProduct
      | undefined;
    trialPeriod?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateTrialPeriod
      | undefined;
    quantity?: number | undefined;
    dependencies?:
      | Array<
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateDependency
      >
      | undefined;
    components?:
      | Array<
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateComponent
      >
      | undefined;
  };

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderDevicesAddedProduct =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The entity name
     */
    name?: string | undefined;
    /**
     * The entity sku
     */
    sku?: string | undefined;
  };

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderDevicesAdded = {
  quantity?: number | undefined;
  product?:
    | ComCrmEstimateOrderSelfServiceResourceEstimateOrderDevicesAddedProduct
    | undefined;
  serialNumber?: Array<string> | undefined;
};

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderServiceDeliveryEstimate =
  {
    actionAllowed?: boolean | undefined;
    allowedExecutionOn?: number | undefined;
    nextBillingAt?: number | undefined;
    nextPaymentDate?: number | undefined;
    subscription?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderSubscription
      | undefined;
    pausedPeriod?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderPausedPeriod
      | undefined;
    billingEstimate?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingEstimate
      | undefined;
    componentsChange?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsChange
      | undefined;
    failureReason?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderFailureReason2
      | undefined;
    servicesToAdd?:
      | Array<ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAdd>
      | undefined;
    servicesToRemove?:
      | Array<
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemove
      >
      | undefined;
    servicesToChange?:
      | Array<
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChange
      >
      | undefined;
    servicesToUpdate?:
      | Array<
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdate
      >
      | undefined;
    devicesAdded?:
      | Array<ComCrmEstimateOrderSelfServiceResourceEstimateOrderDevicesAdded>
      | undefined;
  };

/**
 * The milestone's stage i.e. when the Invoice will be issued.
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderStage = {
  id?: string | undefined;
  name?: string | undefined;
  colour?: string | undefined;
  priority?: number | undefined;
};

export type MilestonePlanEstimate = {
  /**
   * The milestone's stage i.e. when the Invoice will be issued.
   */
  stage?: ComCrmEstimateOrderSelfServiceResourceEstimateOrderStage | undefined;
  /**
   * The milestone’s percentage amount as this is configured in the Order queue
   */
  queuePercentage?: number | undefined;
  /**
   * the milestone’s percentage for this specified queue.
   */
  percentage?: number | undefined;
  /**
   * calculated amount based on order quotation amount x by the percentage. If percentage = null then this amount = order quotation amount x queue percentage.
   */
  amount?: number | undefined;
};

/**
 * Details on why the product is considered as invalid and cannot be included in the Order
 *
 * @remarks
 *  * `VALIDITY_PERIOD` - The prodcut’s validity period has expired, i.e. the business is no longer selling this product
 *  * `AVAILABILITY` - The product is temporarily un-available for sale at/by the requested organisation e.g. is out of stock
 *  * `ORDER_CATALOGUE` - The product is not included in an valid/effective Order Catalogue.
 *  * `STOCK` - The product does not have enough stock.
 */
export const UnavailabilityReason = {
  Stock: "STOCK",
  ValidityPeriod: "VALIDITY_PERIOD",
  Availability: "AVAILABILITY",
  OrderCatalogue: "ORDER_CATALOGUE",
} as const;
/**
 * Details on why the product is considered as invalid and cannot be included in the Order
 *
 * @remarks
 *  * `VALIDITY_PERIOD` - The prodcut’s validity period has expired, i.e. the business is no longer selling this product
 *  * `AVAILABILITY` - The product is temporarily un-available for sale at/by the requested organisation e.g. is out of stock
 *  * `ORDER_CATALOGUE` - The product is not included in an valid/effective Order Catalogue.
 *  * `STOCK` - The product does not have enough stock.
 */
export type UnavailabilityReason = OpenEnum<typeof UnavailabilityReason>;

/**
 * Product included in the request’s ordered items
 */
export type InvalidProductProduct = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
  /**
   * The entity sku
   */
  sku?: string | undefined;
};

export type InvalidProduct = {
  /**
   * Details on why the product is considered as invalid and cannot be included in the Order
   *
   * @remarks
   *  * `VALIDITY_PERIOD` - The prodcut’s validity period has expired, i.e. the business is no longer selling this product
   *  * `AVAILABILITY` - The product is temporarily un-available for sale at/by the requested organisation e.g. is out of stock
   *  * `ORDER_CATALOGUE` - The product is not included in an valid/effective Order Catalogue.
   *  * `STOCK` - The product does not have enough stock.
   */
  unavailabilityReason?: UnavailabilityReason | undefined;
  /**
   * Product included in the request’s ordered items
   */
  product?: InvalidProductProduct | undefined;
  /**
   * The quantity of the product that is available for the customer to order
   */
  inStock?: number | undefined;
};

/**
 * Details about the organisation from where such event was posted
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderOrderFulfilledBy =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The organisation name
     */
    name?: string | undefined;
  };

export const OrderOrderEstimateUot = {
  Second: "SECOND",
  Minute: "MINUTE",
  Hour: "HOUR",
  Day: "DAY",
  Week: "WEEK",
  Month: "MONTH",
  Year: "YEAR",
  Overall: "OVERALL",
} as const;
export type OrderOrderEstimateUot = OpenEnum<typeof OrderOrderEstimateUot>;

export type OrderEstimatedDelivery = {
  timeToDelivery?: number | undefined;
  uot?: OrderOrderEstimateUot | undefined;
  deliveredAt?: number | undefined;
};

/**
 * The queue information
 */
export type OrderQueue = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
};

/**
 * Shows the reason why the order cannot be placed
 */
export const OrderOrderFailureReason = {
  MinimumCost: "MINIMUM_COST",
  TaxCalculation: "TAX_CALCULATION",
} as const;
/**
 * Shows the reason why the order cannot be placed
 */
export type OrderOrderFailureReason = OpenEnum<typeof OrderOrderFailureReason>;

/**
 * An estimation on if the Order can be placed and if yes, then its detailed information that includes fulfillment and invoicing details.
 */
export type OrderOrderEstimate = {
  /**
   * Indicates whether minimum order amount is met and order can proceed with submission.
   */
  orderingAllowed?: boolean | undefined;
  /**
   * Defines the minimum order amount as specified in the fulfillment policy of the organisation fulfilling the order.
   */
  minimumAmount?: number | undefined;
  /**
   * Details about the organisation from where such event was posted
   */
  fulfilledBy?:
    | ComCrmEstimateOrderSelfServiceResourceEstimateOrderOrderFulfilledBy
    | undefined;
  estimatedDelivery?: OrderEstimatedDelivery | undefined;
  /**
   * The queue information
   */
  queue?: OrderQueue | undefined;
  /**
   * Shows the reason why the order cannot be placed
   */
  orderFailureReason?: OrderOrderFailureReason | undefined;
  subscriptionEstimationAmount?: number | undefined;
};

/**
 * Shows the reason for failing to calculating taxes for the invoice, typically because there's an issue with the online taxation service
 */
export const OrderInvoiceEstimateTaxFailureReason = {
  InvalidAddress: "INVALID_ADDRESS",
  ApiError: "API_ERROR",
  CommunicationError: "COMMUNICATION_ERROR",
} as const;
/**
 * Shows the reason for failing to calculating taxes for the invoice, typically because there's an issue with the online taxation service
 */
export type OrderInvoiceEstimateTaxFailureReason = OpenEnum<
  typeof OrderInvoiceEstimateTaxFailureReason
>;

/**
 * Tax rate code
 */
export const OrderInvoiceEstimateTaxesBreakdownTaxCode = {
  Vat: "VAT",
  TaxExempt: "TAX_EXEMPT",
  SalesTax: "SALES_TAX",
  Other: "OTHER",
} as const;
/**
 * Tax rate code
 */
export type OrderInvoiceEstimateTaxesBreakdownTaxCode = OpenEnum<
  typeof OrderInvoiceEstimateTaxesBreakdownTaxCode
>;

/**
 * The applied tax rate
 */
export type OrderInvoiceEstimateTaxesBreakdownTaxRate = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * Tax rate name
   */
  name?: string | undefined;
  /**
   * Tax rate code
   */
  taxCode?: OrderInvoiceEstimateTaxesBreakdownTaxCode | undefined;
  /**
   * The applied tax rate’s percentage that was valid on the date on which the rate was applied
   */
  percentage?: number | undefined;
};

/**
 * Applicable only when a Tax Exempt rate was applied. Shows whether the tax exempt rate was applied because the Contact or the Product was marked as tax exempt.
 */
export const OrderTaxesBreakdownTaxExemptReason = {
  Contact: "CONTACT",
  Product: "PRODUCT",
} as const;
/**
 * Applicable only when a Tax Exempt rate was applied. Shows whether the tax exempt rate was applied because the Contact or the Product was marked as tax exempt.
 */
export type OrderTaxesBreakdownTaxExemptReason = OpenEnum<
  typeof OrderTaxesBreakdownTaxExemptReason
>;

export type OrderInvoiceEstimateTaxesBreakdown = {
  /**
   * The applied tax rate
   */
  taxRate?: OrderInvoiceEstimateTaxesBreakdownTaxRate | undefined;
  /**
   * The applied tax amount
   */
  taxAmount?: number | undefined;
  /**
   * Applicable only when a Tax Exempt rate was applied. Shows whether the tax exempt rate was applied because the Contact or the Product was marked as tax exempt.
   */
  taxExemptReason?: OrderTaxesBreakdownTaxExemptReason | undefined;
};

/**
 * Invoiced period applicable only when invoicing a termed service.
 */
export type OrderItemPeriod = {
  /**
   * The date from which the service is invoiced/credited
   */
  from?: number | undefined;
  /**
   * The date until which the service is invoiced/credited
   */
  to?: number | undefined;
};

export type OrderItemDiscount = {
  /**
   * The discount amount of the line
   */
  discountAmount?: number | undefined;
  /**
   * The discount percentage of the line
   */
  discountPercentage?: number | undefined;
  discountInclTax?: number | undefined;
};

/**
 * The product’s classification
 */
export const OrderInvoiceEstimateProductClassification = {
  TermedService: "TERMED_SERVICE",
  UsageService: "USAGE_SERVICE",
  OneTimeService: "ONE_TIME_SERVICE",
  TraceablePhysicalGood: "TRACEABLE_PHYSICAL_GOOD",
  NonTraceablePhysicalGood: "NON_TRACEABLE_PHYSICAL_GOOD",
  ExpensesService: "EXPENSES_SERVICE",
} as const;
/**
 * The product’s classification
 */
export type OrderInvoiceEstimateProductClassification = OpenEnum<
  typeof OrderInvoiceEstimateProductClassification
>;

export type OrderInvoiceEstimateProduct = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * Product’s SKU
   */
  sku?: string | undefined;
  /**
   * Product’s name
   */
  name?: string | undefined;
  /**
   * The product’s classification
   */
  classification?: OrderInvoiceEstimateProductClassification | undefined;
  /**
   * Indicates if the product is stockable
   */
  isStockable?: boolean | undefined;
};

/**
 * The product’s classification
 */
export const OrderInvoiceEstimateBundleProductClassification = {
  TermedService: "TERMED_SERVICE",
  UsageService: "USAGE_SERVICE",
  OneTimeService: "ONE_TIME_SERVICE",
  TraceablePhysicalGood: "TRACEABLE_PHYSICAL_GOOD",
  NonTraceablePhysicalGood: "NON_TRACEABLE_PHYSICAL_GOOD",
  ExpensesService: "EXPENSES_SERVICE",
} as const;
/**
 * The product’s classification
 */
export type OrderInvoiceEstimateBundleProductClassification = OpenEnum<
  typeof OrderInvoiceEstimateBundleProductClassification
>;

export type OrderItemBundleProduct = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * Product’s SKU
   */
  sku?: string | undefined;
  /**
   * Product’s name
   */
  name?: string | undefined;
  /**
   * The product’s classification
   */
  classification?: OrderInvoiceEstimateBundleProductClassification | undefined;
  /**
   * Indicates if the product is stockable
   */
  isStockable?: boolean | undefined;
};

/**
 * Tax rate code
 */
export const OrderItemTaxCode = {
  Vat: "VAT",
  TaxExempt: "TAX_EXEMPT",
  SalesTax: "SALES_TAX",
  Other: "OTHER",
} as const;
/**
 * Tax rate code
 */
export type OrderItemTaxCode = OpenEnum<typeof OrderItemTaxCode>;

/**
 * The applied tax rate
 */
export type OrderItemTaxRate = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * Tax rate name
   */
  name?: string | undefined;
  /**
   * Tax rate code
   */
  taxCode?: OrderItemTaxCode | undefined;
  /**
   * The applied tax rate’s percentage that was valid on the date on which the rate was applied
   */
  percentage?: number | undefined;
};

/**
 * Applicable only when a Tax Exempt rate was applied. Shows whether the tax exempt rate was applied because the Contact or the Product was marked as tax exempt.
 */
export const OrderItemTaxExemptReason = {
  Contact: "CONTACT",
  Product: "PRODUCT",
} as const;
/**
 * Applicable only when a Tax Exempt rate was applied. Shows whether the tax exempt rate was applied because the Contact or the Product was marked as tax exempt.
 */
export type OrderItemTaxExemptReason = OpenEnum<
  typeof OrderItemTaxExemptReason
>;

export type OrderItemAppliedTax = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The applied tax rate
   */
  taxRate?: OrderItemTaxRate | undefined;
  /**
   * The applied tax amount
   */
  taxAmount?: number | undefined;
  /**
   * Applicable only when a Tax Exempt rate was applied. Shows whether the tax exempt rate was applied because the Contact or the Product was marked as tax exempt.
   */
  taxExemptReason?: OrderItemTaxExemptReason | undefined;
  /**
   * The tax category code assigned by Taxation Service (e.g., clothing, food).
   */
  taxCategory?: string | undefined;
  /**
   * The exempt amount for this jurisdiction as calculated by Taxation Service.
   */
  exemptAmount?: number | undefined;
  /**
   * The name of the jurisdiction (e.g., state, county, city) as returned by Taxation Service.
   */
  jurisName?: string | undefined;
  /**
   * The type of jurisdiction (e.g., State, County, City, Special) as returned by Taxation Service.
   */
  jurisType?: string | undefined;
  /**
   * The tax region identifier as returned by Taxation Service.
   */
  taxRegion?: string | undefined;
  /**
   * The type of tax applied (e.g., Sales, Use, Lodging) by Taxation Service.
   */
  taxType?: string | undefined;
};

export type OrderItem = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The quantity of the product
   */
  quantity?: number | undefined;
  /**
   * The price per unit of the product
   */
  unitPrice?: number | undefined;
  /**
   * The net amount
   */
  netAmount?: number | undefined;
  /**
   * Total taxed amount for this product
   */
  taxAmount?: number | undefined;
  /**
   * The sub total of the financial transaction line
   */
  subTotal?: number | undefined;
  /**
   * Invoiced period applicable only when invoicing a termed service.
   */
  period?: OrderItemPeriod | undefined;
  discount?: OrderItemDiscount | undefined;
  product?: OrderInvoiceEstimateProduct | undefined;
  bundleProduct?: OrderItemBundleProduct | undefined;
  appliedTaxes?: Array<OrderItemAppliedTax> | undefined;
  /**
   * The price of the product as this is configured in the product catalog (including tax or not depending on the tax model)
   */
  pricing?: number | undefined;
  /**
   * The quantity of the product that is available for the customer to order
   */
  inStock?: number | undefined;
};

/**
 * Type of discount applied
 */
export const OrderInvoiceEstimateType = {
  AdHoc: "AD_HOC",
  Promotion: "PROMOTION",
  AutoApplied: "AUTO_APPLIED",
} as const;
/**
 * Type of discount applied
 */
export type OrderInvoiceEstimateType = OpenEnum<
  typeof OrderInvoiceEstimateType
>;

/**
 * The applied Promotion. Applicable when discount type is Promotion
 */
export type OrderInvoiceEstimatePromotion = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
};

export type OrderInvoiceEstimateDiscount = {
  /**
   * The deducted amount
   */
  amount?: number | undefined;
  /**
   * Type of discount applied
   */
  type?: OrderInvoiceEstimateType | undefined;
  /**
   * The applied Promotion. Applicable when discount type is Promotion
   */
  promotion?: OrderInvoiceEstimatePromotion | undefined;
};

/**
 * The outright order’s invoicing information. This invoice estimation includes only physical goods ordered as well as One-Time services. It does not include any invoicing or billing information for ordered termed services
 */
export type OrderInvoiceEstimate = {
  /**
   * Invoice or Credit Notes issue date
   */
  issuedDate?: number | undefined;
  /**
   * Invoice due date
   */
  dueDate?: number | undefined;
  /**
   * The currency code
   */
  currencyCode?: string | undefined;
  /**
   * Total Net amount
   */
  net?: number | undefined;
  /**
   * Total discount amount
   */
  discount?: number | undefined;
  /**
   * Total tax amount
   */
  tax?: number | undefined;
  /**
   * Total amount of the invoice that will be generated. Includes taxed and disoucnt amounts
   */
  total?: number | undefined;
  walletFundsAmount?: number | undefined;
  /**
   * The amount that will be due at the time of the estimation
   */
  amountDue?: number | undefined;
  discountInclTax?: number | undefined;
  /**
   * Amount that the customer needs to pay at the time of the estimation
   */
  amountToCollect?: number | undefined;
  /**
   * Sum of all products’ prices as these are defined in the product catalog
   */
  totalPrice?: number | undefined;
  /**
   * Available account funds that can be used to pay off the Invoice. Available when the account is in credit and/or the account has a credit limit. Account funds are calculated as the account’s credit limit minus the amount in credit. for example credit limit is 100 and account credit is 50, then account fund sis returned as 150
   */
  accountCredit?: number | undefined;
  /**
   * Indicates whether taxes failed to be calculated by the online taxation service
   */
  taxCalculationFailed?: boolean | undefined;
  /**
   * Shows the reason for failing to calculating taxes for the invoice, typically because there's an issue with the online taxation service
   */
  taxFailureReason?: OrderInvoiceEstimateTaxFailureReason | undefined;
  taxesBreakdown?: Array<OrderInvoiceEstimateTaxesBreakdown> | undefined;
  items?: Array<OrderItem> | undefined;
  discounts?: Array<OrderInvoiceEstimateDiscount> | undefined;
};

export const OrderSubscriptionState = {
  Active: "ACTIVE",
  Churned: "CHURNED",
  Inactive: "INACTIVE",
} as const;
export type OrderSubscriptionState = OpenEnum<typeof OrderSubscriptionState>;

/**
 * The billing cycle's unit of time
 */
export const OrderUotTaxCalculation = {
  Second: "SECOND",
  Minute: "MINUTE",
  Hour: "HOUR",
  Day: "DAY",
  Week: "WEEK",
  Month: "MONTH",
  Year: "YEAR",
  Overall: "OVERALL",
} as const;
/**
 * The billing cycle's unit of time
 */
export type OrderUotTaxCalculation = OpenEnum<typeof OrderUotTaxCalculation>;

export type OrderBillingPeriod = {
  /**
   * The billing cycle's duration
   */
  duration?: number | undefined;
  /**
   * The billing cycle's unit of time
   */
  uot?: OrderUotTaxCalculation | undefined;
};

export type OrderBillingDay = {
  /**
   * Day of week
   */
  dayOfWeek?: string | undefined;
  /**
   * Day of month
   */
  dayOfMonth?: number | undefined;
  /**
   * Month of year
   */
  monthOfYear?: string | undefined;
};

export const OrderBillingModel = {
  PreBill: "PRE_BILL",
  PostBill: "POST_BILL",
} as const;
export type OrderBillingModel = OpenEnum<typeof OrderBillingModel>;

export type OrderTerms = {
  billingPeriod?: OrderBillingPeriod | undefined;
  billingDay?: OrderBillingDay | undefined;
  billingModel?: OrderBillingModel | undefined;
};

export type OrderSubscription = {
  state?: OrderSubscriptionState | undefined;
  terms?: OrderTerms | undefined;
};

export type OrderPausedPeriod = {
  durationInDays?: number | undefined;
  startsOn?: number | undefined;
  endsOn?: number | undefined;
};

export type OrderBilledPeriod = {
  fromDate?: number | undefined;
  toDate?: number | undefined;
};

export type OrderTotals = {
  totalAmount?: number | undefined;
  taxAmount?: number | undefined;
  netAmount?: number | undefined;
  discountAmount?: number | undefined;
};

export const OrderFailureReason1 = {
  TaxCalculation: "TAX_CALCULATION",
} as const;
export type OrderFailureReason1 = ClosedEnum<typeof OrderFailureReason1>;

/**
 * Shows the reason for failing to calculating taxes for the invoice, typically because there's an issue with the online taxation service
 */
export const OrderInvoicingTaxFailureReason = {
  InvalidAddress: "INVALID_ADDRESS",
  ApiError: "API_ERROR",
  CommunicationError: "COMMUNICATION_ERROR",
} as const;
/**
 * Shows the reason for failing to calculating taxes for the invoice, typically because there's an issue with the online taxation service
 */
export type OrderInvoicingTaxFailureReason = OpenEnum<
  typeof OrderInvoicingTaxFailureReason
>;

export const OrderInvoicingTaxesBreakdownTaxCode = {
  Vat: "VAT",
  TaxExempt: "TAX_EXEMPT",
  SalesTax: "SALES_TAX",
  Other: "OTHER",
} as const;
export type OrderInvoicingTaxesBreakdownTaxCode = OpenEnum<
  typeof OrderInvoicingTaxesBreakdownTaxCode
>;

/** @internal */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderSecurity$Outbound =
  {
    Secret_API_key?: string | undefined;
    authorization_self_service?: string | undefined;
  };

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderSecurity$outboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderSecurity$Outbound,
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderSecurity
  > = z.pipe(
    z.object({
      secretAPIKey: z.optional(z.string()),
      authorizationSelfService: z.optional(z.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        secretAPIKey: "Secret_API_key",
        authorizationSelfService: "authorization_self_service",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderSecurityToJSON(
  comCrmEstimateOrderSelfServiceResourceEstimateOrderSecurity:
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderSecurity,
): string {
  return JSON.stringify(
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderSecurity$outboundSchema
      .parse(comCrmEstimateOrderSelfServiceResourceEstimateOrderSecurity),
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderSupplyMethod$outboundSchema:
  z.ZodMiniEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderSupplyMethod
  > = z.enum(ComCrmEstimateOrderSelfServiceResourceEstimateOrderSupplyMethod);

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderDeliveryMethod$outboundSchema:
  z.ZodMiniEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderDeliveryMethod
  > = z.enum(ComCrmEstimateOrderSelfServiceResourceEstimateOrderDeliveryMethod);

/** @internal */
export type DeliveryServiceProviderLocation$Outbound = {
  id?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const DeliveryServiceProviderLocation$outboundSchema: z.ZodMiniType<
  DeliveryServiceProviderLocation$Outbound,
  DeliveryServiceProviderLocation
> = z.object({
  id: z.optional(z.string()),
  name: z.optional(z.string()),
});

export function deliveryServiceProviderLocationToJSON(
  deliveryServiceProviderLocation: DeliveryServiceProviderLocation,
): string {
  return JSON.stringify(
    DeliveryServiceProviderLocation$outboundSchema.parse(
      deliveryServiceProviderLocation,
    ),
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderTimeUnit$outboundSchema:
  z.ZodMiniEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderTimeUnit
  > = z.enum(ComCrmEstimateOrderSelfServiceResourceEstimateOrderTimeUnit);

/** @internal */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderRequestedDeliveryAt$Outbound =
  {
    time?: number | undefined;
    time_unit?: string | undefined;
    date?: number | undefined;
  };

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderRequestedDeliveryAt$outboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderRequestedDeliveryAt$Outbound,
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderRequestedDeliveryAt
  > = z.pipe(
    z.object({
      time: z.optional(z.int()),
      timeUnit: z.optional(
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderTimeUnit$outboundSchema,
      ),
      date: z.optional(z.int()),
    }),
    z.transform((v) => {
      return remap$(v, {
        timeUnit: "time_unit",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderRequestedDeliveryAtToJSON(
  comCrmEstimateOrderSelfServiceResourceEstimateOrderRequestedDeliveryAt:
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderRequestedDeliveryAt,
): string {
  return JSON.stringify(
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderRequestedDeliveryAt$outboundSchema
      .parse(
        comCrmEstimateOrderSelfServiceResourceEstimateOrderRequestedDeliveryAt,
      ),
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderPaymentMethodType$outboundSchema:
  z.ZodMiniEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderPaymentMethodType
  > = z.enum(
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderPaymentMethodType,
  );

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderTypeRequest$outboundSchema:
  z.ZodMiniEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderTypeRequest
  > = z.enum(ComCrmEstimateOrderSelfServiceResourceEstimateOrderTypeRequest);

/** @internal */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderDiscountRequest$Outbound =
  {
    amount?: number | undefined;
    type?: string | undefined;
  };

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderDiscountRequest$outboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderDiscountRequest$Outbound,
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderDiscountRequest
  > = z.object({
    amount: z.optional(z.number()),
    type: z.optional(
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderTypeRequest$outboundSchema,
    ),
  });

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderDiscountRequestToJSON(
  comCrmEstimateOrderSelfServiceResourceEstimateOrderDiscountRequest:
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderDiscountRequest,
): string {
  return JSON.stringify(
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderDiscountRequest$outboundSchema
      .parse(
        comCrmEstimateOrderSelfServiceResourceEstimateOrderDiscountRequest,
      ),
  );
}

/** @internal */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderPass$Outbound = {
  code: string;
  pin?: string | undefined;
};

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderPass$outboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderPass$Outbound,
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderPass
  > = z.object({
    code: z.string(),
    pin: z.optional(z.string()),
  });

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderPassToJSON(
  comCrmEstimateOrderSelfServiceResourceEstimateOrderPass:
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderPass,
): string {
  return JSON.stringify(
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderPass$outboundSchema
      .parse(comCrmEstimateOrderSelfServiceResourceEstimateOrderPass),
  );
}

/** @internal */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderPreferredBillingDay$Outbound =
  {
    day_of_week?: string | undefined;
    day_of_month?: number | undefined;
    month_of_year?: string | undefined;
  };

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderPreferredBillingDay$outboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderPreferredBillingDay$Outbound,
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderPreferredBillingDay
  > = z.pipe(
    z.object({
      dayOfWeek: z.optional(z.string()),
      dayOfMonth: z.optional(z.int()),
      monthOfYear: z.optional(z.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        dayOfWeek: "day_of_week",
        dayOfMonth: "day_of_month",
        monthOfYear: "month_of_year",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderPreferredBillingDayToJSON(
  comCrmEstimateOrderSelfServiceResourceEstimateOrderPreferredBillingDay:
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderPreferredBillingDay,
): string {
  return JSON.stringify(
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderPreferredBillingDay$outboundSchema
      .parse(
        comCrmEstimateOrderSelfServiceResourceEstimateOrderPreferredBillingDay,
      ),
  );
}

/** @internal */
export type Milestone$Outbound = {
  stage_id?: string | undefined;
  percentage?: number | undefined;
  amount?: number | undefined;
};

/** @internal */
export const Milestone$outboundSchema: z.ZodMiniType<
  Milestone$Outbound,
  Milestone
> = z.pipe(
  z.object({
    stageId: z.optional(z.string()),
    percentage: z.optional(z.number()),
    amount: z.optional(z.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      stageId: "stage_id",
    });
  }),
);

export function milestoneToJSON(milestone: Milestone): string {
  return JSON.stringify(Milestone$outboundSchema.parse(milestone));
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderTaxModel$outboundSchema:
  z.ZodMiniEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderTaxModel
  > = z.enum(ComCrmEstimateOrderSelfServiceResourceEstimateOrderTaxModel);

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentTaxModel$outboundSchema:
  z.ZodMiniEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentTaxModel
  > = z.enum(
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentTaxModel,
  );

/** @internal */
export type ItemComponent$Outbound = {
  id?: string | undefined;
  quantity?: number | undefined;
  price?: number | undefined;
  tax_model?: string | undefined;
  price_terms_id?: string | undefined;
};

/** @internal */
export const ItemComponent$outboundSchema: z.ZodMiniType<
  ItemComponent$Outbound,
  ItemComponent
> = z.pipe(
  z.object({
    id: z.optional(z.string()),
    quantity: z.optional(z.number()),
    price: z.optional(z.number()),
    taxModel: z.optional(
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentTaxModel$outboundSchema,
    ),
    priceTermsId: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      taxModel: "tax_model",
      priceTermsId: "price_terms_id",
    });
  }),
);

export function itemComponentToJSON(itemComponent: ItemComponent): string {
  return JSON.stringify(ItemComponent$outboundSchema.parse(itemComponent));
}

/** @internal */
export type ItemRequest$Outbound = {
  id?: string | undefined;
  quantity?: number | undefined;
  price?: number | undefined;
  tax_model: string;
  notes?: string | undefined;
  price_terms_id?: string | undefined;
  components?: Array<ItemComponent$Outbound> | undefined;
};

/** @internal */
export const ItemRequest$outboundSchema: z.ZodMiniType<
  ItemRequest$Outbound,
  ItemRequest
> = z.pipe(
  z.object({
    id: z.optional(z.string()),
    quantity: z.optional(z.number()),
    price: z.optional(z.number()),
    taxModel: z._default(
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderTaxModel$outboundSchema,
      "TAX_INCLUSIVE",
    ),
    notes: z.optional(z.string()),
    priceTermsId: z.optional(z.string()),
    components: z.optional(z.array(z.lazy(() => ItemComponent$outboundSchema))),
  }),
  z.transform((v) => {
    return remap$(v, {
      taxModel: "tax_model",
      priceTermsId: "price_terms_id",
    });
  }),
);

export function itemRequestToJSON(itemRequest: ItemRequest): string {
  return JSON.stringify(ItemRequest$outboundSchema.parse(itemRequest));
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderCountryCode$outboundSchema:
  z.ZodMiniEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderCountryCode
  > = z.enum(ComCrmEstimateOrderSelfServiceResourceEstimateOrderCountryCode);

/** @internal */
export type CurrentLocation$Outbound = {
  id?: string | undefined;
  address_type?: string | undefined;
  address_name?: string | undefined;
  address_line_1?: string | undefined;
  address_line_2?: string | undefined;
  state_province_county?: string | undefined;
  town_city?: string | undefined;
  postal_code?: string | undefined;
  country_code?: string | undefined;
  lat?: number | undefined;
  lon?: number | undefined;
  google_place_id?: string | undefined;
};

/** @internal */
export const CurrentLocation$outboundSchema: z.ZodMiniType<
  CurrentLocation$Outbound,
  CurrentLocation
> = z.pipe(
  z.object({
    id: z.optional(z.string()),
    addressType: z.optional(z.string()),
    addressName: z.optional(z.string()),
    addressLine1: z.optional(z.string()),
    addressLine2: z.optional(z.string()),
    stateProvinceCounty: z.optional(z.string()),
    townCity: z.optional(z.string()),
    postalCode: z.optional(z.string()),
    countryCode: z.optional(
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderCountryCode$outboundSchema,
    ),
    lat: z.optional(z.number()),
    lon: z.optional(z.number()),
    googlePlaceId: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      addressType: "address_type",
      addressName: "address_name",
      addressLine1: "address_line_1",
      addressLine2: "address_line_2",
      stateProvinceCounty: "state_province_county",
      townCity: "town_city",
      postalCode: "postal_code",
      countryCode: "country_code",
      googlePlaceId: "google_place_id",
    });
  }),
);

export function currentLocationToJSON(
  currentLocation: CurrentLocation,
): string {
  return JSON.stringify(CurrentLocation$outboundSchema.parse(currentLocation));
}

/** @internal */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderRequest$Outbound =
  {
    account_id: string;
    supply_method: string;
    delivery_method: string;
    delivery_service_provider?: string | undefined;
    delivery_service_provider_location?:
      | DeliveryServiceProviderLocation$Outbound
      | undefined;
    fulfilled_by?: string | null | undefined;
    requested_delivery_at?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderRequestedDeliveryAt$Outbound
      | undefined;
    address_id?: string | undefined;
    notes?: string | undefined;
    queue_id?: string | undefined;
    estimation_id?: string | undefined;
    use_wallet_funds: boolean;
    block_wallet_funds?: boolean | undefined;
    wallet_funds_amount?: number | undefined;
    payment_method_type: string;
    discount?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderDiscountRequest$Outbound
      | undefined;
    pass?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderPass$Outbound
      | undefined;
    preferred_billing_day?:
      | ComCrmEstimateOrderSelfServiceResourceEstimateOrderPreferredBillingDay$Outbound
      | undefined;
    milestones?: Array<Milestone$Outbound> | undefined;
    items: Array<ItemRequest$Outbound>;
    current_location?: CurrentLocation$Outbound | undefined;
  };

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderRequest$outboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderRequest$Outbound,
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderRequest
  > = z.pipe(
    z.object({
      accountId: z.string(),
      supplyMethod:
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderSupplyMethod$outboundSchema,
      deliveryMethod:
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderDeliveryMethod$outboundSchema,
      deliveryServiceProvider: z.optional(z.string()),
      deliveryServiceProviderLocation: z.optional(
        z.lazy(() => DeliveryServiceProviderLocation$outboundSchema),
      ),
      fulfilledBy: z.optional(z.nullable(z.string())),
      requestedDeliveryAt: z.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderRequestedDeliveryAt$outboundSchema
      )),
      addressId: z.optional(z.string()),
      notes: z.optional(z.string()),
      queueId: z.optional(z.string()),
      estimationId: z.optional(z.string()),
      useWalletFunds: z._default(z.boolean(), false),
      blockWalletFunds: z.optional(z.boolean()),
      walletFundsAmount: z.optional(z.number()),
      paymentMethodType:
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderPaymentMethodType$outboundSchema,
      discount: z.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderDiscountRequest$outboundSchema
      )),
      pass: z.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderPass$outboundSchema
      )),
      preferredBillingDay: z.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderPreferredBillingDay$outboundSchema
      )),
      milestones: z.optional(z.array(z.lazy(() =>
        Milestone$outboundSchema
      ))),
      items: z.array(z.lazy(() =>
        ItemRequest$outboundSchema
      )),
      currentLocation: z.optional(z.lazy(() =>
        CurrentLocation$outboundSchema
      )),
    }),
    z.transform((v) => {
      return remap$(v, {
        accountId: "account_id",
        supplyMethod: "supply_method",
        deliveryMethod: "delivery_method",
        deliveryServiceProvider: "delivery_service_provider",
        deliveryServiceProviderLocation: "delivery_service_provider_location",
        fulfilledBy: "fulfilled_by",
        requestedDeliveryAt: "requested_delivery_at",
        addressId: "address_id",
        queueId: "queue_id",
        estimationId: "estimation_id",
        useWalletFunds: "use_wallet_funds",
        blockWalletFunds: "block_wallet_funds",
        walletFundsAmount: "wallet_funds_amount",
        paymentMethodType: "payment_method_type",
        preferredBillingDay: "preferred_billing_day",
        currentLocation: "current_location",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderRequestToJSON(
  comCrmEstimateOrderSelfServiceResourceEstimateOrderRequest:
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderRequest,
): string {
  return JSON.stringify(
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderRequest$outboundSchema
      .parse(comCrmEstimateOrderSelfServiceResourceEstimateOrderRequest),
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderFulfilledBy$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderFulfilledBy,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
  });

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderFulfilledByFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderFulfilledBy,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderFulfilledBy$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderFulfilledBy' from JSON`,
  );
}

/** @internal */
export const OrderEstimateUot$inboundSchema: z.ZodMiniType<
  OrderEstimateUot,
  unknown
> = openEnums.inboundSchema(OrderEstimateUot);

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderEstimatedDelivery$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderEstimatedDelivery,
    unknown
  > = z.pipe(
    z.object({
      time_to_delivery: types.optional(types.number()),
      uot: types.optional(OrderEstimateUot$inboundSchema),
      delivered_at: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "time_to_delivery": "timeToDelivery",
        "delivered_at": "deliveredAt",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderEstimatedDeliveryFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderEstimatedDelivery,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderEstimatedDelivery$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderEstimatedDelivery' from JSON`,
  );
}

/** @internal */
export const Queue$inboundSchema: z.ZodMiniType<Queue, unknown> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
});

export function queueFromJSON(
  jsonString: string,
): SafeParseResult<Queue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Queue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Queue' from JSON`,
  );
}

/** @internal */
export const OrderFailureReason$inboundSchema: z.ZodMiniType<
  OrderFailureReason,
  unknown
> = openEnums.inboundSchema(OrderFailureReason);

/** @internal */
export const OrderEstimate$inboundSchema: z.ZodMiniType<
  OrderEstimate,
  unknown
> = z.pipe(
  z.object({
    ordering_allowed: types.optional(types.boolean()),
    minimum_amount: types.optional(types.number()),
    fulfilled_by: types.optional(z.lazy(() =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderFulfilledBy$inboundSchema
    )),
    estimated_delivery: types.optional(z.lazy(() =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderEstimatedDelivery$inboundSchema
    )),
    queue: types.optional(z.lazy(() =>
      Queue$inboundSchema
    )),
    order_failure_reason: types.optional(OrderFailureReason$inboundSchema),
    subscription_estimation_amount: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "ordering_allowed": "orderingAllowed",
      "minimum_amount": "minimumAmount",
      "fulfilled_by": "fulfilledBy",
      "estimated_delivery": "estimatedDelivery",
      "order_failure_reason": "orderFailureReason",
      "subscription_estimation_amount": "subscriptionEstimationAmount",
    });
  }),
);

export function orderEstimateFromJSON(
  jsonString: string,
): SafeParseResult<OrderEstimate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderEstimate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderEstimate' from JSON`,
  );
}

/** @internal */
export const InvoiceEstimateTaxFailureReason$inboundSchema: z.ZodMiniType<
  InvoiceEstimateTaxFailureReason,
  unknown
> = openEnums.inboundSchema(InvoiceEstimateTaxFailureReason);

/** @internal */
export const InvoiceEstimateTaxesBreakdownTaxCode$inboundSchema: z.ZodMiniType<
  InvoiceEstimateTaxesBreakdownTaxCode,
  unknown
> = openEnums.inboundSchema(InvoiceEstimateTaxesBreakdownTaxCode);

/** @internal */
export const InvoiceEstimateTaxesBreakdownTaxRate$inboundSchema: z.ZodMiniType<
  InvoiceEstimateTaxesBreakdownTaxRate,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    tax_code: types.optional(
      InvoiceEstimateTaxesBreakdownTaxCode$inboundSchema,
    ),
    percentage: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "tax_code": "taxCode",
    });
  }),
);

export function invoiceEstimateTaxesBreakdownTaxRateFromJSON(
  jsonString: string,
): SafeParseResult<InvoiceEstimateTaxesBreakdownTaxRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      InvoiceEstimateTaxesBreakdownTaxRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvoiceEstimateTaxesBreakdownTaxRate' from JSON`,
  );
}

/** @internal */
export const InvoiceEstimateTaxesBreakdownTaxExemptReason$inboundSchema:
  z.ZodMiniType<InvoiceEstimateTaxesBreakdownTaxExemptReason, unknown> =
    openEnums.inboundSchema(InvoiceEstimateTaxesBreakdownTaxExemptReason);

/** @internal */
export const InvoiceEstimateTaxesBreakdown$inboundSchema: z.ZodMiniType<
  InvoiceEstimateTaxesBreakdown,
  unknown
> = z.pipe(
  z.object({
    tax_rate: types.optional(
      z.lazy(() => InvoiceEstimateTaxesBreakdownTaxRate$inboundSchema),
    ),
    tax_amount: types.optional(types.number()),
    tax_exempt_reason: types.optional(
      InvoiceEstimateTaxesBreakdownTaxExemptReason$inboundSchema,
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "tax_rate": "taxRate",
      "tax_amount": "taxAmount",
      "tax_exempt_reason": "taxExemptReason",
    });
  }),
);

export function invoiceEstimateTaxesBreakdownFromJSON(
  jsonString: string,
): SafeParseResult<InvoiceEstimateTaxesBreakdown, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvoiceEstimateTaxesBreakdown$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvoiceEstimateTaxesBreakdown' from JSON`,
  );
}

/** @internal */
export const ItemPeriod$inboundSchema: z.ZodMiniType<ItemPeriod, unknown> = z
  .object({
    from: types.optional(types.number()),
    to: types.optional(types.number()),
  });

export function itemPeriodFromJSON(
  jsonString: string,
): SafeParseResult<ItemPeriod, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ItemPeriod$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ItemPeriod' from JSON`,
  );
}

/** @internal */
export const InvoiceEstimateItemDiscount$inboundSchema: z.ZodMiniType<
  InvoiceEstimateItemDiscount,
  unknown
> = z.pipe(
  z.object({
    discount_amount: types.optional(types.number()),
    discount_percentage: types.optional(types.number()),
    discount_incl_tax: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "discount_amount": "discountAmount",
      "discount_percentage": "discountPercentage",
      "discount_incl_tax": "discountInclTax",
    });
  }),
);

export function invoiceEstimateItemDiscountFromJSON(
  jsonString: string,
): SafeParseResult<InvoiceEstimateItemDiscount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvoiceEstimateItemDiscount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvoiceEstimateItemDiscount' from JSON`,
  );
}

/** @internal */
export const InvoiceEstimateProductClassification$inboundSchema: z.ZodMiniType<
  InvoiceEstimateProductClassification,
  unknown
> = openEnums.inboundSchema(InvoiceEstimateProductClassification);

/** @internal */
export const InvoiceEstimateProduct$inboundSchema: z.ZodMiniType<
  InvoiceEstimateProduct,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    sku: types.optional(types.string()),
    name: types.optional(types.string()),
    classification: types.optional(
      InvoiceEstimateProductClassification$inboundSchema,
    ),
    is_stockable: types.optional(types.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_stockable": "isStockable",
    });
  }),
);

export function invoiceEstimateProductFromJSON(
  jsonString: string,
): SafeParseResult<InvoiceEstimateProduct, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvoiceEstimateProduct$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvoiceEstimateProduct' from JSON`,
  );
}

/** @internal */
export const InvoiceEstimateBundleProductClassification$inboundSchema:
  z.ZodMiniType<InvoiceEstimateBundleProductClassification, unknown> = openEnums
    .inboundSchema(InvoiceEstimateBundleProductClassification);

/** @internal */
export const ItemBundleProduct$inboundSchema: z.ZodMiniType<
  ItemBundleProduct,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    sku: types.optional(types.string()),
    name: types.optional(types.string()),
    classification: types.optional(
      InvoiceEstimateBundleProductClassification$inboundSchema,
    ),
    is_stockable: types.optional(types.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_stockable": "isStockable",
    });
  }),
);

export function itemBundleProductFromJSON(
  jsonString: string,
): SafeParseResult<ItemBundleProduct, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ItemBundleProduct$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ItemBundleProduct' from JSON`,
  );
}

/** @internal */
export const ItemTaxCode$inboundSchema: z.ZodMiniType<ItemTaxCode, unknown> =
  openEnums.inboundSchema(ItemTaxCode);

/** @internal */
export const ItemTaxRate$inboundSchema: z.ZodMiniType<ItemTaxRate, unknown> = z
  .pipe(
    z.object({
      id: types.optional(types.string()),
      name: types.optional(types.string()),
      tax_code: types.optional(ItemTaxCode$inboundSchema),
      percentage: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "tax_code": "taxCode",
      });
    }),
  );

export function itemTaxRateFromJSON(
  jsonString: string,
): SafeParseResult<ItemTaxRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ItemTaxRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ItemTaxRate' from JSON`,
  );
}

/** @internal */
export const ItemTaxExemptReason$inboundSchema: z.ZodMiniType<
  ItemTaxExemptReason,
  unknown
> = openEnums.inboundSchema(ItemTaxExemptReason);

/** @internal */
export const ItemAppliedTax$inboundSchema: z.ZodMiniType<
  ItemAppliedTax,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    tax_rate: types.optional(z.lazy(() => ItemTaxRate$inboundSchema)),
    tax_amount: types.optional(types.number()),
    tax_exempt_reason: types.optional(ItemTaxExemptReason$inboundSchema),
    tax_category: types.optional(types.string()),
    exempt_amount: types.optional(types.number()),
    juris_name: types.optional(types.string()),
    juris_type: types.optional(types.string()),
    tax_region: types.optional(types.string()),
    tax_type: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "tax_rate": "taxRate",
      "tax_amount": "taxAmount",
      "tax_exempt_reason": "taxExemptReason",
      "tax_category": "taxCategory",
      "exempt_amount": "exemptAmount",
      "juris_name": "jurisName",
      "juris_type": "jurisType",
      "tax_region": "taxRegion",
      "tax_type": "taxType",
    });
  }),
);

export function itemAppliedTaxFromJSON(
  jsonString: string,
): SafeParseResult<ItemAppliedTax, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ItemAppliedTax$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ItemAppliedTax' from JSON`,
  );
}

/** @internal */
export const InvoiceEstimateItem$inboundSchema: z.ZodMiniType<
  InvoiceEstimateItem,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    quantity: types.optional(types.number()),
    unit_price: types.optional(types.number()),
    net_amount: types.optional(types.number()),
    tax_amount: types.optional(types.number()),
    sub_total: types.optional(types.number()),
    period: types.optional(z.lazy(() => ItemPeriod$inboundSchema)),
    discount: types.optional(
      z.lazy(() => InvoiceEstimateItemDiscount$inboundSchema),
    ),
    product: types.optional(z.lazy(() => InvoiceEstimateProduct$inboundSchema)),
    bundle_product: types.optional(
      z.lazy(() => ItemBundleProduct$inboundSchema),
    ),
    applied_taxes: types.optional(
      z.array(z.lazy(() => ItemAppliedTax$inboundSchema)),
    ),
    pricing: types.optional(types.number()),
    in_stock: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "unit_price": "unitPrice",
      "net_amount": "netAmount",
      "tax_amount": "taxAmount",
      "sub_total": "subTotal",
      "bundle_product": "bundleProduct",
      "applied_taxes": "appliedTaxes",
      "in_stock": "inStock",
    });
  }),
);

export function invoiceEstimateItemFromJSON(
  jsonString: string,
): SafeParseResult<InvoiceEstimateItem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvoiceEstimateItem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvoiceEstimateItem' from JSON`,
  );
}

/** @internal */
export const InvoiceEstimateType$inboundSchema: z.ZodMiniType<
  InvoiceEstimateType,
  unknown
> = openEnums.inboundSchema(InvoiceEstimateType);

/** @internal */
export const InvoiceEstimatePromotion$inboundSchema: z.ZodMiniType<
  InvoiceEstimatePromotion,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
});

export function invoiceEstimatePromotionFromJSON(
  jsonString: string,
): SafeParseResult<InvoiceEstimatePromotion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvoiceEstimatePromotion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvoiceEstimatePromotion' from JSON`,
  );
}

/** @internal */
export const InvoiceEstimateDiscount$inboundSchema: z.ZodMiniType<
  InvoiceEstimateDiscount,
  unknown
> = z.object({
  amount: types.optional(types.number()),
  type: types.optional(InvoiceEstimateType$inboundSchema),
  promotion: types.optional(
    z.lazy(() => InvoiceEstimatePromotion$inboundSchema),
  ),
});

export function invoiceEstimateDiscountFromJSON(
  jsonString: string,
): SafeParseResult<InvoiceEstimateDiscount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvoiceEstimateDiscount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvoiceEstimateDiscount' from JSON`,
  );
}

/** @internal */
export const InvoiceEstimate$inboundSchema: z.ZodMiniType<
  InvoiceEstimate,
  unknown
> = z.pipe(
  z.object({
    issued_date: types.optional(types.number()),
    due_date: types.optional(types.number()),
    currency_code: types.optional(types.string()),
    net: types.optional(types.number()),
    discount: types.optional(types.number()),
    tax: types.optional(types.number()),
    total: types.optional(types.number()),
    wallet_funds_amount: types.optional(types.number()),
    amount_due: types.optional(types.number()),
    discount_incl_tax: types.optional(types.number()),
    amount_to_collect: types.optional(types.number()),
    total_price: types.optional(types.number()),
    account_credit: types.optional(types.number()),
    tax_calculation_failed: types.optional(types.boolean()),
    tax_failure_reason: types.optional(
      InvoiceEstimateTaxFailureReason$inboundSchema,
    ),
    taxes_breakdown: types.optional(
      z.array(z.lazy(() => InvoiceEstimateTaxesBreakdown$inboundSchema)),
    ),
    items: types.optional(
      z.array(z.lazy(() => InvoiceEstimateItem$inboundSchema)),
    ),
    discounts: types.optional(
      z.array(z.lazy(() => InvoiceEstimateDiscount$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "issued_date": "issuedDate",
      "due_date": "dueDate",
      "currency_code": "currencyCode",
      "wallet_funds_amount": "walletFundsAmount",
      "amount_due": "amountDue",
      "discount_incl_tax": "discountInclTax",
      "amount_to_collect": "amountToCollect",
      "total_price": "totalPrice",
      "account_credit": "accountCredit",
      "tax_calculation_failed": "taxCalculationFailed",
      "tax_failure_reason": "taxFailureReason",
      "taxes_breakdown": "taxesBreakdown",
    });
  }),
);

export function invoiceEstimateFromJSON(
  jsonString: string,
): SafeParseResult<InvoiceEstimate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvoiceEstimate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvoiceEstimate' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderSubscriptionState$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderSubscriptionState,
    unknown
  > = openEnums.inboundSchema(
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderSubscriptionState,
  );

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderUotTaxCalculation$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderUotTaxCalculation,
    unknown
  > = openEnums.inboundSchema(
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderUotTaxCalculation,
  );

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingPeriod$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingPeriod,
    unknown
  > = z.object({
    duration: types.optional(types.number()),
    uot: types.optional(
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderUotTaxCalculation$inboundSchema,
    ),
  });

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderBillingPeriodFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingPeriod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingPeriod$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingPeriod' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingDay$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingDay,
    unknown
  > = z.pipe(
    z.object({
      day_of_week: types.optional(types.string()),
      day_of_month: types.optional(types.number()),
      month_of_year: types.optional(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "day_of_week": "dayOfWeek",
        "day_of_month": "dayOfMonth",
        "month_of_year": "monthOfYear",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderBillingDayFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingDay,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingDay$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingDay' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingModel$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingModel,
    unknown
  > = openEnums.inboundSchema(
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingModel,
  );

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderTerms$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderTerms,
    unknown
  > = z.pipe(
    z.object({
      billing_period: types.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingPeriod$inboundSchema
      )),
      billing_day: types.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingDay$inboundSchema
      )),
      billing_model: types.optional(
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingModel$inboundSchema,
      ),
    }),
    z.transform((v) => {
      return remap$(v, {
        "billing_period": "billingPeriod",
        "billing_day": "billingDay",
        "billing_model": "billingModel",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderTermsFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderTerms,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderTerms$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderTerms' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderSubscription$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderSubscription,
    unknown
  > = z.object({
    state: types.optional(
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderSubscriptionState$inboundSchema,
    ),
    terms: types.optional(
      z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderTerms$inboundSchema
      ),
    ),
  });

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderSubscriptionFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderSubscription,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderSubscription$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderSubscription' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderPausedPeriod$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderPausedPeriod,
    unknown
  > = z.pipe(
    z.object({
      duration_in_days: types.optional(types.number()),
      starts_on: types.optional(types.number()),
      ends_on: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "duration_in_days": "durationInDays",
        "starts_on": "startsOn",
        "ends_on": "endsOn",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderPausedPeriodFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderPausedPeriod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderPausedPeriod$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderPausedPeriod' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderBilledPeriod$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderBilledPeriod,
    unknown
  > = z.pipe(
    z.object({
      from_date: types.optional(types.number()),
      to_date: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "from_date": "fromDate",
        "to_date": "toDate",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderBilledPeriodFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderBilledPeriod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderBilledPeriod$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderBilledPeriod' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderTotals$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderTotals,
    unknown
  > = z.pipe(
    z.object({
      total_amount: types.optional(types.number()),
      tax_amount: types.optional(types.number()),
      net_amount: types.optional(types.number()),
      discount_amount: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "total_amount": "totalAmount",
        "tax_amount": "taxAmount",
        "net_amount": "netAmount",
        "discount_amount": "discountAmount",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderTotalsFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderTotals,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderTotals$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderTotals' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderFailureReason1$inboundSchema:
  z.ZodMiniEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderFailureReason1
  > = z.enum(ComCrmEstimateOrderSelfServiceResourceEstimateOrderFailureReason1);

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxFailureReason$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxFailureReason,
    unknown
  > = openEnums.inboundSchema(
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxFailureReason,
  );

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdownTaxCode$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdownTaxCode,
    unknown
  > = openEnums.inboundSchema(
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdownTaxCode,
  );

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdownTaxRate$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdownTaxRate,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      name: types.optional(types.string()),
      tax_code: types.optional(
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdownTaxCode$inboundSchema,
      ),
      percentage: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "tax_code": "taxCode",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdownTaxRateFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdownTaxRate,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdownTaxRate$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdownTaxRate' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdown$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdown,
    unknown
  > = z.pipe(
    z.object({
      tax_rate: types.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdownTaxRate$inboundSchema
      )),
      tax_amount: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "tax_rate": "taxRate",
        "tax_amount": "taxAmount",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdownFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdown,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdown$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdown' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemDiscount$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemDiscount,
    unknown
  > = z.pipe(
    z.object({
      discount_amount: types.optional(types.number()),
      discount_percentage: types.optional(types.number()),
      discount_incl_tax: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "discount_amount": "discountAmount",
        "discount_percentage": "discountPercentage",
        "discount_incl_tax": "discountInclTax",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemDiscountFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemDiscount,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemDiscount$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemDiscount' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemProductClassification$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemProductClassification,
    unknown
  > = openEnums.inboundSchema(
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemProductClassification,
  );

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemProduct$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemProduct,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    sku: types.optional(types.string()),
    classification: types.optional(
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemProductClassification$inboundSchema,
    ),
  });

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemProductFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemProduct,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemProduct$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemProduct' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemBundleProductClassification$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemBundleProductClassification,
    unknown
  > = openEnums.inboundSchema(
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemBundleProductClassification,
  );

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemBundleProduct$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemBundleProduct,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    sku: types.optional(types.string()),
    classification: types.optional(
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemBundleProductClassification$inboundSchema,
    ),
  });

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemBundleProductFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemBundleProduct,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemBundleProduct$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemBundleProduct' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemPeriod$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemPeriod,
    unknown
  > = z.object({
    from: types.optional(types.number()),
    to: types.optional(types.number()),
  });

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemPeriodFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemPeriod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemPeriod$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemPeriod' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemTaxCode$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemTaxCode,
    unknown
  > = openEnums.inboundSchema(
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemTaxCode,
  );

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemTaxRate$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemTaxRate,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      name: types.optional(types.string()),
      tax_code: types.optional(
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemTaxCode$inboundSchema,
      ),
      percentage: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "tax_code": "taxCode",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemTaxRateFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemTaxRate,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemTaxRate$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemTaxRate' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemTaxExemptReason$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemTaxExemptReason,
    unknown
  > = openEnums.inboundSchema(
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemTaxExemptReason,
  );

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemAppliedTax$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemAppliedTax,
    unknown
  > = z.pipe(
    z.object({
      tax_rate: types.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemTaxRate$inboundSchema
      )),
      tax_amount: types.optional(types.number()),
      tax_exempt_reason: types.optional(
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemTaxExemptReason$inboundSchema,
      ),
    }),
    z.transform((v) => {
      return remap$(v, {
        "tax_rate": "taxRate",
        "tax_amount": "taxAmount",
        "tax_exempt_reason": "taxExemptReason",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemAppliedTaxFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemAppliedTax,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemAppliedTax$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemAppliedTax' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItem$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItem,
    unknown
  > = z.pipe(
    z.object({
      quantity: types.optional(types.number()),
      unit_price: types.optional(types.number()),
      net_amount: types.optional(types.number()),
      tax_amount: types.optional(types.number()),
      sub_total: types.optional(types.number()),
      pricing: types.optional(types.number()),
      discount: types.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemDiscount$inboundSchema
      )),
      product: types.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemProduct$inboundSchema
      )),
      bundle_product: types.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemBundleProduct$inboundSchema
      )),
      period: types.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemPeriod$inboundSchema
      )),
      applied_taxes: types.optional(z.array(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemAppliedTax$inboundSchema
      ))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "unit_price": "unitPrice",
        "net_amount": "netAmount",
        "tax_amount": "taxAmount",
        "sub_total": "subTotal",
        "bundle_product": "bundleProduct",
        "applied_taxes": "appliedTaxes",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderLineItemFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItem,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItem$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItem' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingType$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingType,
    unknown
  > = openEnums.inboundSchema(
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingType,
  );

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingPromotion$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingPromotion,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
  });

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingPromotionFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingPromotion,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingPromotion$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingPromotion' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingDiscount$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingDiscount,
    unknown
  > = z.object({
    amount: types.optional(types.number()),
    type: types.optional(
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingType$inboundSchema,
    ),
    promotion: types.optional(
      z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingPromotion$inboundSchema
      ),
    ),
  });

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingDiscountFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingDiscount,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingDiscount$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingDiscount' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicing$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicing,
    unknown
  > = z.pipe(
    z.object({
      issued_date: types.optional(types.number()),
      due_date: types.optional(types.number()),
      currency_code: types.optional(types.string()),
      is_credit: types.optional(types.boolean()),
      total_net_amount: types.optional(types.number()),
      total_discount_amount: types.optional(types.number()),
      total_tax_amount: types.optional(types.number()),
      total_amount: types.optional(types.number()),
      wallet_funds_amount: types.optional(types.number()),
      amount_due: types.optional(types.number()),
      amount_to_collect: types.optional(types.number()),
      total_discount_incl_tax: types.optional(types.number()),
      total_price: types.optional(types.number()),
      account_funds: types.optional(types.number()),
      tax_calculation_failed: types.optional(types.boolean()),
      tax_failure_reason: types.optional(
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxFailureReason$inboundSchema,
      ),
      taxes_breakdown: types.optional(z.array(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingTaxesBreakdown$inboundSchema
      ))),
      line_items: types.optional(z.array(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderLineItem$inboundSchema
      ))),
      discounts: types.optional(z.array(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingDiscount$inboundSchema
      ))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "issued_date": "issuedDate",
        "due_date": "dueDate",
        "currency_code": "currencyCode",
        "is_credit": "isCredit",
        "total_net_amount": "totalNetAmount",
        "total_discount_amount": "totalDiscountAmount",
        "total_tax_amount": "totalTaxAmount",
        "total_amount": "totalAmount",
        "wallet_funds_amount": "walletFundsAmount",
        "amount_due": "amountDue",
        "amount_to_collect": "amountToCollect",
        "total_discount_incl_tax": "totalDiscountInclTax",
        "total_price": "totalPrice",
        "account_funds": "accountFunds",
        "tax_calculation_failed": "taxCalculationFailed",
        "tax_failure_reason": "taxFailureReason",
        "taxes_breakdown": "taxesBreakdown",
        "line_items": "lineItems",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicingFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicing,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicing$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicing' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingEstimate$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingEstimate,
    unknown
  > = z.pipe(
    z.object({
      billed_period: types.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderBilledPeriod$inboundSchema
      )),
      totals: types.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderTotals$inboundSchema
      )),
      failure_reason: types.optional(
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderFailureReason1$inboundSchema,
      ),
      invoicing: types.optional(z.array(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderInvoicing$inboundSchema
      ))),
      billing_date: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "billed_period": "billedPeriod",
        "failure_reason": "failureReason",
        "billing_date": "billingDate",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderBillingEstimateFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingEstimate,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingEstimate$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingEstimate' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderService$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderService,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    sku: types.optional(types.string()),
  });

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderServiceFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderService,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderService$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderService' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsAdded$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsAdded,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    sku: types.optional(types.string()),
  });

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsAddedFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsAdded,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsAdded$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsAdded' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsRemoved$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsRemoved,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    sku: types.optional(types.string()),
  });

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsRemovedFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsRemoved,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsRemoved$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsRemoved' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsChange$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsChange,
    unknown
  > = z.pipe(
    z.object({
      service: types.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderService$inboundSchema
      )),
      components_added: types.optional(z.array(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsAdded$inboundSchema
      ))),
      components_removed: types.optional(z.array(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsRemoved$inboundSchema
      ))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "components_added": "componentsAdded",
        "components_removed": "componentsRemoved",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsChangeFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsChange,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsChange$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsChange' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderFailureReason2$inboundSchema:
  z.ZodMiniEnum<
    typeof ComCrmEstimateOrderSelfServiceResourceEstimateOrderFailureReason2
  > = z.enum(ComCrmEstimateOrderSelfServiceResourceEstimateOrderFailureReason2);

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddState$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddState,
    unknown
  > = openEnums.inboundSchema(
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddState,
  );

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddProduct$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddProduct,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    sku: types.optional(types.string()),
  });

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddProductFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddProduct,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddProduct$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddProduct' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddTrialPeriod$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddTrialPeriod,
    unknown
  > = z.pipe(
    z.object({
      starts_on: types.optional(types.number()),
      ends_on: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "starts_on": "startsOn",
        "ends_on": "endsOn",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddTrialPeriodFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddTrialPeriod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddTrialPeriod$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddTrialPeriod' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddDependency$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddDependency,
    unknown
  > = z.pipe(
    z.object({
      item_type: types.optional(types.string()),
      item_id: types.optional(types.string()),
      item_name: types.optional(types.string()),
      item_sku: types.optional(types.string()),
      dependency: types.optional(types.string()),
      dependency_met: types.optional(types.boolean()),
      quantity: types.optional(types.number()),
      missing_quantity: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "item_type": "itemType",
        "item_id": "itemId",
        "item_name": "itemName",
        "item_sku": "itemSku",
        "dependency_met": "dependencyMet",
        "missing_quantity": "missingQuantity",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddDependencyFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddDependency,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddDependency$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddDependency' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddComponentDependency$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddComponentDependency,
    unknown
  > = z.pipe(
    z.object({
      item_type: types.optional(types.string()),
      item_id: types.optional(types.string()),
      item_name: types.optional(types.string()),
      item_sku: types.optional(types.string()),
      dependency: types.optional(types.string()),
      dependency_met: types.optional(types.boolean()),
      quantity: types.optional(types.number()),
      missing_quantity: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "item_type": "itemType",
        "item_id": "itemId",
        "item_name": "itemName",
        "item_sku": "itemSku",
        "dependency_met": "dependencyMet",
        "missing_quantity": "missingQuantity",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddComponentDependencyFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddComponentDependency,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddComponentDependency$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddComponentDependency' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddComponent$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddComponent,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    sku: types.optional(types.string()),
    name: types.optional(types.string()),
    quantity: types.optional(types.number()),
    dependencies: types.optional(
      z.array(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddComponentDependency$inboundSchema
      )),
    ),
  });

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddComponentFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddComponent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddComponent$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddComponent' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAdd$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAdd,
    unknown
  > = z.pipe(
    z.object({
      state: types.optional(
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddState$inboundSchema,
      ),
      product: types.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddProduct$inboundSchema
      )),
      trial_period: types.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddTrialPeriod$inboundSchema
      )),
      quantity: types.optional(types.number()),
      dependencies: types.optional(z.array(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddDependency$inboundSchema
      ))),
      components: types.optional(z.array(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddComponent$inboundSchema
      ))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "trial_period": "trialPeriod",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAddFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAdd,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAdd$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAdd' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemoveState$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemoveState,
    unknown
  > = openEnums.inboundSchema(
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemoveState,
  );

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemoveProduct$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemoveProduct,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    sku: types.optional(types.string()),
  });

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemoveProductFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemoveProduct,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemoveProduct$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemoveProduct' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemove$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemove,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    state: types.optional(
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemoveState$inboundSchema,
    ),
    product: types.optional(
      z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemoveProduct$inboundSchema
      ),
    ),
  });

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemoveFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemove,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemove$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemove' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeState$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeState,
    unknown
  > = openEnums.inboundSchema(
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeState,
  );

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeProduct$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeProduct,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    sku: types.optional(types.string()),
  });

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeProductFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeProduct,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeProduct$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeProduct' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderChangeToProduct$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderChangeToProduct,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    sku: types.optional(types.string()),
  });

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderChangeToProductFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderChangeToProduct,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderChangeToProduct$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderChangeToProduct' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeDependency$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeDependency,
    unknown
  > = z.pipe(
    z.object({
      item_type: types.optional(types.string()),
      item_id: types.optional(types.string()),
      item_name: types.optional(types.string()),
      item_sku: types.optional(types.string()),
      dependency: types.optional(types.string()),
      dependency_met: types.optional(types.boolean()),
      quantity: types.optional(types.number()),
      missing_quantity: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "item_type": "itemType",
        "item_id": "itemId",
        "item_name": "itemName",
        "item_sku": "itemSku",
        "dependency_met": "dependencyMet",
        "missing_quantity": "missingQuantity",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeDependencyFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeDependency,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeDependency$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeDependency' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChange$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChange,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      state: types.optional(
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeState$inboundSchema,
      ),
      product: types.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeProduct$inboundSchema
      )),
      change_to_product: types.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderChangeToProduct$inboundSchema
      )),
      quantity: types.optional(types.number()),
      dependencies: types.optional(z.array(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeDependency$inboundSchema
      ))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "change_to_product": "changeToProduct",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChangeFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChange,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChange$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChange' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateState$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateState,
    unknown
  > = openEnums.inboundSchema(
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateState,
  );

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateProduct$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateProduct,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    sku: types.optional(types.string()),
  });

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateProductFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateProduct,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateProduct$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateProduct' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateTrialPeriod$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateTrialPeriod,
    unknown
  > = z.pipe(
    z.object({
      starts_on: types.optional(types.number()),
      ends_on: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "starts_on": "startsOn",
        "ends_on": "endsOn",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateTrialPeriodFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateTrialPeriod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateTrialPeriod$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateTrialPeriod' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateDependency$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateDependency,
    unknown
  > = z.pipe(
    z.object({
      item_type: types.optional(types.string()),
      item_id: types.optional(types.string()),
      item_name: types.optional(types.string()),
      item_sku: types.optional(types.string()),
      dependency: types.optional(types.string()),
      dependency_met: types.optional(types.boolean()),
      quantity: types.optional(types.number()),
      missing_quantity: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "item_type": "itemType",
        "item_id": "itemId",
        "item_name": "itemName",
        "item_sku": "itemSku",
        "dependency_met": "dependencyMet",
        "missing_quantity": "missingQuantity",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateDependencyFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateDependency,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateDependency$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateDependency' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateComponentDependency$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateComponentDependency,
    unknown
  > = z.pipe(
    z.object({
      item_type: types.optional(types.string()),
      item_id: types.optional(types.string()),
      item_name: types.optional(types.string()),
      item_sku: types.optional(types.string()),
      dependency: types.optional(types.string()),
      dependency_met: types.optional(types.boolean()),
      quantity: types.optional(types.number()),
      missing_quantity: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "item_type": "itemType",
        "item_id": "itemId",
        "item_name": "itemName",
        "item_sku": "itemSku",
        "dependency_met": "dependencyMet",
        "missing_quantity": "missingQuantity",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateComponentDependencyFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateComponentDependency,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateComponentDependency$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateComponentDependency' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateComponent$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateComponent,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    sku: types.optional(types.string()),
    name: types.optional(types.string()),
    quantity: types.optional(types.number()),
    dependencies: types.optional(
      z.array(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateComponentDependency$inboundSchema
      )),
    ),
  });

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateComponentFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateComponent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateComponent$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateComponent' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdate$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdate,
    unknown
  > = z.pipe(
    z.object({
      state: types.optional(
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateState$inboundSchema,
      ),
      product: types.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateProduct$inboundSchema
      )),
      trial_period: types.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateTrialPeriod$inboundSchema
      )),
      quantity: types.optional(types.number()),
      dependencies: types.optional(z.array(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateDependency$inboundSchema
      ))),
      components: types.optional(z.array(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateComponent$inboundSchema
      ))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "trial_period": "trialPeriod",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdateFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdate,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdate$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdate' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderDevicesAddedProduct$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderDevicesAddedProduct,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    sku: types.optional(types.string()),
  });

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderDevicesAddedProductFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderDevicesAddedProduct,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderDevicesAddedProduct$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderDevicesAddedProduct' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderDevicesAdded$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderDevicesAdded,
    unknown
  > = z.pipe(
    z.object({
      quantity: types.optional(types.number()),
      product: types.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderDevicesAddedProduct$inboundSchema
      )),
      serial_number: types.optional(z.array(types.string())),
    }),
    z.transform((v) => {
      return remap$(v, {
        "serial_number": "serialNumber",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderDevicesAddedFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderDevicesAdded,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderDevicesAdded$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderDevicesAdded' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderServiceDeliveryEstimate$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderServiceDeliveryEstimate,
    unknown
  > = z.pipe(
    z.object({
      action_allowed: types.optional(types.boolean()),
      allowed_execution_on: types.optional(types.number()),
      next_billing_at: types.optional(types.number()),
      next_payment_date: types.optional(types.number()),
      subscription: types.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderSubscription$inboundSchema
      )),
      paused_period: types.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderPausedPeriod$inboundSchema
      )),
      billing_estimate: types.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderBillingEstimate$inboundSchema
      )),
      components_change: types.optional(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderComponentsChange$inboundSchema
      )),
      failure_reason: types.optional(
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderFailureReason2$inboundSchema,
      ),
      services_to_add: types.optional(z.array(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToAdd$inboundSchema
      ))),
      services_to_remove: types.optional(z.array(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToRemove$inboundSchema
      ))),
      services_to_change: types.optional(z.array(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToChange$inboundSchema
      ))),
      services_to_update: types.optional(z.array(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderServicesToUpdate$inboundSchema
      ))),
      devices_added: types.optional(z.array(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderDevicesAdded$inboundSchema
      ))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "action_allowed": "actionAllowed",
        "allowed_execution_on": "allowedExecutionOn",
        "next_billing_at": "nextBillingAt",
        "next_payment_date": "nextPaymentDate",
        "paused_period": "pausedPeriod",
        "billing_estimate": "billingEstimate",
        "components_change": "componentsChange",
        "failure_reason": "failureReason",
        "services_to_add": "servicesToAdd",
        "services_to_remove": "servicesToRemove",
        "services_to_change": "servicesToChange",
        "services_to_update": "servicesToUpdate",
        "devices_added": "devicesAdded",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderServiceDeliveryEstimateFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderServiceDeliveryEstimate,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderServiceDeliveryEstimate$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderServiceDeliveryEstimate' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderStage$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderStage,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    colour: types.optional(types.string()),
    priority: types.optional(types.number()),
  });

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderStageFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderStage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderStage$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderStage' from JSON`,
  );
}

/** @internal */
export const MilestonePlanEstimate$inboundSchema: z.ZodMiniType<
  MilestonePlanEstimate,
  unknown
> = z.pipe(
  z.object({
    stage: types.optional(z.lazy(() =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderStage$inboundSchema
    )),
    queue_percentage: types.optional(types.number()),
    percentage: types.optional(types.number()),
    amount: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "queue_percentage": "queuePercentage",
    });
  }),
);

export function milestonePlanEstimateFromJSON(
  jsonString: string,
): SafeParseResult<MilestonePlanEstimate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MilestonePlanEstimate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MilestonePlanEstimate' from JSON`,
  );
}

/** @internal */
export const UnavailabilityReason$inboundSchema: z.ZodMiniType<
  UnavailabilityReason,
  unknown
> = openEnums.inboundSchema(UnavailabilityReason);

/** @internal */
export const InvalidProductProduct$inboundSchema: z.ZodMiniType<
  InvalidProductProduct,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
  sku: types.optional(types.string()),
});

export function invalidProductProductFromJSON(
  jsonString: string,
): SafeParseResult<InvalidProductProduct, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvalidProductProduct$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvalidProductProduct' from JSON`,
  );
}

/** @internal */
export const InvalidProduct$inboundSchema: z.ZodMiniType<
  InvalidProduct,
  unknown
> = z.pipe(
  z.object({
    unavailability_reason: types.optional(UnavailabilityReason$inboundSchema),
    product: types.optional(z.lazy(() => InvalidProductProduct$inboundSchema)),
    in_stock: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "unavailability_reason": "unavailabilityReason",
      "in_stock": "inStock",
    });
  }),
);

export function invalidProductFromJSON(
  jsonString: string,
): SafeParseResult<InvalidProduct, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvalidProduct$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvalidProduct' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderOrderFulfilledBy$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderOrderFulfilledBy,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
  });

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderOrderFulfilledByFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderOrderFulfilledBy,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderOrderFulfilledBy$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderOrderFulfilledBy' from JSON`,
  );
}

/** @internal */
export const OrderOrderEstimateUot$inboundSchema: z.ZodMiniType<
  OrderOrderEstimateUot,
  unknown
> = openEnums.inboundSchema(OrderOrderEstimateUot);

/** @internal */
export const OrderEstimatedDelivery$inboundSchema: z.ZodMiniType<
  OrderEstimatedDelivery,
  unknown
> = z.pipe(
  z.object({
    time_to_delivery: types.optional(types.number()),
    uot: types.optional(OrderOrderEstimateUot$inboundSchema),
    delivered_at: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "time_to_delivery": "timeToDelivery",
      "delivered_at": "deliveredAt",
    });
  }),
);

export function orderEstimatedDeliveryFromJSON(
  jsonString: string,
): SafeParseResult<OrderEstimatedDelivery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderEstimatedDelivery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderEstimatedDelivery' from JSON`,
  );
}

/** @internal */
export const OrderQueue$inboundSchema: z.ZodMiniType<OrderQueue, unknown> = z
  .object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
  });

export function orderQueueFromJSON(
  jsonString: string,
): SafeParseResult<OrderQueue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderQueue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderQueue' from JSON`,
  );
}

/** @internal */
export const OrderOrderFailureReason$inboundSchema: z.ZodMiniType<
  OrderOrderFailureReason,
  unknown
> = openEnums.inboundSchema(OrderOrderFailureReason);

/** @internal */
export const OrderOrderEstimate$inboundSchema: z.ZodMiniType<
  OrderOrderEstimate,
  unknown
> = z.pipe(
  z.object({
    ordering_allowed: types.optional(types.boolean()),
    minimum_amount: types.optional(types.number()),
    fulfilled_by: types.optional(z.lazy(() =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderOrderFulfilledBy$inboundSchema
    )),
    estimated_delivery: types.optional(z.lazy(() =>
      OrderEstimatedDelivery$inboundSchema
    )),
    queue: types.optional(z.lazy(() =>
      OrderQueue$inboundSchema
    )),
    order_failure_reason: types.optional(OrderOrderFailureReason$inboundSchema),
    subscription_estimation_amount: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "ordering_allowed": "orderingAllowed",
      "minimum_amount": "minimumAmount",
      "fulfilled_by": "fulfilledBy",
      "estimated_delivery": "estimatedDelivery",
      "order_failure_reason": "orderFailureReason",
      "subscription_estimation_amount": "subscriptionEstimationAmount",
    });
  }),
);

export function orderOrderEstimateFromJSON(
  jsonString: string,
): SafeParseResult<OrderOrderEstimate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderOrderEstimate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderOrderEstimate' from JSON`,
  );
}

/** @internal */
export const OrderInvoiceEstimateTaxFailureReason$inboundSchema: z.ZodMiniType<
  OrderInvoiceEstimateTaxFailureReason,
  unknown
> = openEnums.inboundSchema(OrderInvoiceEstimateTaxFailureReason);

/** @internal */
export const OrderInvoiceEstimateTaxesBreakdownTaxCode$inboundSchema:
  z.ZodMiniType<OrderInvoiceEstimateTaxesBreakdownTaxCode, unknown> = openEnums
    .inboundSchema(OrderInvoiceEstimateTaxesBreakdownTaxCode);

/** @internal */
export const OrderInvoiceEstimateTaxesBreakdownTaxRate$inboundSchema:
  z.ZodMiniType<OrderInvoiceEstimateTaxesBreakdownTaxRate, unknown> = z.pipe(
    z.object({
      id: types.optional(types.string()),
      name: types.optional(types.string()),
      tax_code: types.optional(
        OrderInvoiceEstimateTaxesBreakdownTaxCode$inboundSchema,
      ),
      percentage: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "tax_code": "taxCode",
      });
    }),
  );

export function orderInvoiceEstimateTaxesBreakdownTaxRateFromJSON(
  jsonString: string,
): SafeParseResult<
  OrderInvoiceEstimateTaxesBreakdownTaxRate,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OrderInvoiceEstimateTaxesBreakdownTaxRate$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OrderInvoiceEstimateTaxesBreakdownTaxRate' from JSON`,
  );
}

/** @internal */
export const OrderTaxesBreakdownTaxExemptReason$inboundSchema: z.ZodMiniType<
  OrderTaxesBreakdownTaxExemptReason,
  unknown
> = openEnums.inboundSchema(OrderTaxesBreakdownTaxExemptReason);

/** @internal */
export const OrderInvoiceEstimateTaxesBreakdown$inboundSchema: z.ZodMiniType<
  OrderInvoiceEstimateTaxesBreakdown,
  unknown
> = z.pipe(
  z.object({
    tax_rate: types.optional(
      z.lazy(() => OrderInvoiceEstimateTaxesBreakdownTaxRate$inboundSchema),
    ),
    tax_amount: types.optional(types.number()),
    tax_exempt_reason: types.optional(
      OrderTaxesBreakdownTaxExemptReason$inboundSchema,
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "tax_rate": "taxRate",
      "tax_amount": "taxAmount",
      "tax_exempt_reason": "taxExemptReason",
    });
  }),
);

export function orderInvoiceEstimateTaxesBreakdownFromJSON(
  jsonString: string,
): SafeParseResult<OrderInvoiceEstimateTaxesBreakdown, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OrderInvoiceEstimateTaxesBreakdown$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderInvoiceEstimateTaxesBreakdown' from JSON`,
  );
}

/** @internal */
export const OrderItemPeriod$inboundSchema: z.ZodMiniType<
  OrderItemPeriod,
  unknown
> = z.object({
  from: types.optional(types.number()),
  to: types.optional(types.number()),
});

export function orderItemPeriodFromJSON(
  jsonString: string,
): SafeParseResult<OrderItemPeriod, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderItemPeriod$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderItemPeriod' from JSON`,
  );
}

/** @internal */
export const OrderItemDiscount$inboundSchema: z.ZodMiniType<
  OrderItemDiscount,
  unknown
> = z.pipe(
  z.object({
    discount_amount: types.optional(types.number()),
    discount_percentage: types.optional(types.number()),
    discount_incl_tax: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "discount_amount": "discountAmount",
      "discount_percentage": "discountPercentage",
      "discount_incl_tax": "discountInclTax",
    });
  }),
);

export function orderItemDiscountFromJSON(
  jsonString: string,
): SafeParseResult<OrderItemDiscount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderItemDiscount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderItemDiscount' from JSON`,
  );
}

/** @internal */
export const OrderInvoiceEstimateProductClassification$inboundSchema:
  z.ZodMiniType<OrderInvoiceEstimateProductClassification, unknown> = openEnums
    .inboundSchema(OrderInvoiceEstimateProductClassification);

/** @internal */
export const OrderInvoiceEstimateProduct$inboundSchema: z.ZodMiniType<
  OrderInvoiceEstimateProduct,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    sku: types.optional(types.string()),
    name: types.optional(types.string()),
    classification: types.optional(
      OrderInvoiceEstimateProductClassification$inboundSchema,
    ),
    is_stockable: types.optional(types.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_stockable": "isStockable",
    });
  }),
);

export function orderInvoiceEstimateProductFromJSON(
  jsonString: string,
): SafeParseResult<OrderInvoiceEstimateProduct, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderInvoiceEstimateProduct$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderInvoiceEstimateProduct' from JSON`,
  );
}

/** @internal */
export const OrderInvoiceEstimateBundleProductClassification$inboundSchema:
  z.ZodMiniType<OrderInvoiceEstimateBundleProductClassification, unknown> =
    openEnums.inboundSchema(OrderInvoiceEstimateBundleProductClassification);

/** @internal */
export const OrderItemBundleProduct$inboundSchema: z.ZodMiniType<
  OrderItemBundleProduct,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    sku: types.optional(types.string()),
    name: types.optional(types.string()),
    classification: types.optional(
      OrderInvoiceEstimateBundleProductClassification$inboundSchema,
    ),
    is_stockable: types.optional(types.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_stockable": "isStockable",
    });
  }),
);

export function orderItemBundleProductFromJSON(
  jsonString: string,
): SafeParseResult<OrderItemBundleProduct, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderItemBundleProduct$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderItemBundleProduct' from JSON`,
  );
}

/** @internal */
export const OrderItemTaxCode$inboundSchema: z.ZodMiniType<
  OrderItemTaxCode,
  unknown
> = openEnums.inboundSchema(OrderItemTaxCode);

/** @internal */
export const OrderItemTaxRate$inboundSchema: z.ZodMiniType<
  OrderItemTaxRate,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    tax_code: types.optional(OrderItemTaxCode$inboundSchema),
    percentage: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "tax_code": "taxCode",
    });
  }),
);

export function orderItemTaxRateFromJSON(
  jsonString: string,
): SafeParseResult<OrderItemTaxRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderItemTaxRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderItemTaxRate' from JSON`,
  );
}

/** @internal */
export const OrderItemTaxExemptReason$inboundSchema: z.ZodMiniType<
  OrderItemTaxExemptReason,
  unknown
> = openEnums.inboundSchema(OrderItemTaxExemptReason);

/** @internal */
export const OrderItemAppliedTax$inboundSchema: z.ZodMiniType<
  OrderItemAppliedTax,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    tax_rate: types.optional(z.lazy(() => OrderItemTaxRate$inboundSchema)),
    tax_amount: types.optional(types.number()),
    tax_exempt_reason: types.optional(OrderItemTaxExemptReason$inboundSchema),
    tax_category: types.optional(types.string()),
    exempt_amount: types.optional(types.number()),
    juris_name: types.optional(types.string()),
    juris_type: types.optional(types.string()),
    tax_region: types.optional(types.string()),
    tax_type: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "tax_rate": "taxRate",
      "tax_amount": "taxAmount",
      "tax_exempt_reason": "taxExemptReason",
      "tax_category": "taxCategory",
      "exempt_amount": "exemptAmount",
      "juris_name": "jurisName",
      "juris_type": "jurisType",
      "tax_region": "taxRegion",
      "tax_type": "taxType",
    });
  }),
);

export function orderItemAppliedTaxFromJSON(
  jsonString: string,
): SafeParseResult<OrderItemAppliedTax, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderItemAppliedTax$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderItemAppliedTax' from JSON`,
  );
}

/** @internal */
export const OrderItem$inboundSchema: z.ZodMiniType<OrderItem, unknown> = z
  .pipe(
    z.object({
      id: types.optional(types.string()),
      quantity: types.optional(types.number()),
      unit_price: types.optional(types.number()),
      net_amount: types.optional(types.number()),
      tax_amount: types.optional(types.number()),
      sub_total: types.optional(types.number()),
      period: types.optional(z.lazy(() => OrderItemPeriod$inboundSchema)),
      discount: types.optional(z.lazy(() => OrderItemDiscount$inboundSchema)),
      product: types.optional(
        z.lazy(() => OrderInvoiceEstimateProduct$inboundSchema),
      ),
      bundle_product: types.optional(
        z.lazy(() => OrderItemBundleProduct$inboundSchema),
      ),
      applied_taxes: types.optional(
        z.array(z.lazy(() => OrderItemAppliedTax$inboundSchema)),
      ),
      pricing: types.optional(types.number()),
      in_stock: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "unit_price": "unitPrice",
        "net_amount": "netAmount",
        "tax_amount": "taxAmount",
        "sub_total": "subTotal",
        "bundle_product": "bundleProduct",
        "applied_taxes": "appliedTaxes",
        "in_stock": "inStock",
      });
    }),
  );

export function orderItemFromJSON(
  jsonString: string,
): SafeParseResult<OrderItem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderItem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderItem' from JSON`,
  );
}

/** @internal */
export const OrderInvoiceEstimateType$inboundSchema: z.ZodMiniType<
  OrderInvoiceEstimateType,
  unknown
> = openEnums.inboundSchema(OrderInvoiceEstimateType);

/** @internal */
export const OrderInvoiceEstimatePromotion$inboundSchema: z.ZodMiniType<
  OrderInvoiceEstimatePromotion,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
});

export function orderInvoiceEstimatePromotionFromJSON(
  jsonString: string,
): SafeParseResult<OrderInvoiceEstimatePromotion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderInvoiceEstimatePromotion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderInvoiceEstimatePromotion' from JSON`,
  );
}

/** @internal */
export const OrderInvoiceEstimateDiscount$inboundSchema: z.ZodMiniType<
  OrderInvoiceEstimateDiscount,
  unknown
> = z.object({
  amount: types.optional(types.number()),
  type: types.optional(OrderInvoiceEstimateType$inboundSchema),
  promotion: types.optional(
    z.lazy(() => OrderInvoiceEstimatePromotion$inboundSchema),
  ),
});

export function orderInvoiceEstimateDiscountFromJSON(
  jsonString: string,
): SafeParseResult<OrderInvoiceEstimateDiscount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderInvoiceEstimateDiscount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderInvoiceEstimateDiscount' from JSON`,
  );
}

/** @internal */
export const OrderInvoiceEstimate$inboundSchema: z.ZodMiniType<
  OrderInvoiceEstimate,
  unknown
> = z.pipe(
  z.object({
    issued_date: types.optional(types.number()),
    due_date: types.optional(types.number()),
    currency_code: types.optional(types.string()),
    net: types.optional(types.number()),
    discount: types.optional(types.number()),
    tax: types.optional(types.number()),
    total: types.optional(types.number()),
    wallet_funds_amount: types.optional(types.number()),
    amount_due: types.optional(types.number()),
    discount_incl_tax: types.optional(types.number()),
    amount_to_collect: types.optional(types.number()),
    total_price: types.optional(types.number()),
    account_credit: types.optional(types.number()),
    tax_calculation_failed: types.optional(types.boolean()),
    tax_failure_reason: types.optional(
      OrderInvoiceEstimateTaxFailureReason$inboundSchema,
    ),
    taxes_breakdown: types.optional(
      z.array(z.lazy(() => OrderInvoiceEstimateTaxesBreakdown$inboundSchema)),
    ),
    items: types.optional(z.array(z.lazy(() => OrderItem$inboundSchema))),
    discounts: types.optional(
      z.array(z.lazy(() => OrderInvoiceEstimateDiscount$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "issued_date": "issuedDate",
      "due_date": "dueDate",
      "currency_code": "currencyCode",
      "wallet_funds_amount": "walletFundsAmount",
      "amount_due": "amountDue",
      "discount_incl_tax": "discountInclTax",
      "amount_to_collect": "amountToCollect",
      "total_price": "totalPrice",
      "account_credit": "accountCredit",
      "tax_calculation_failed": "taxCalculationFailed",
      "tax_failure_reason": "taxFailureReason",
      "taxes_breakdown": "taxesBreakdown",
    });
  }),
);

export function orderInvoiceEstimateFromJSON(
  jsonString: string,
): SafeParseResult<OrderInvoiceEstimate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderInvoiceEstimate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderInvoiceEstimate' from JSON`,
  );
}

/** @internal */
export const OrderSubscriptionState$inboundSchema: z.ZodMiniType<
  OrderSubscriptionState,
  unknown
> = openEnums.inboundSchema(OrderSubscriptionState);

/** @internal */
export const OrderUotTaxCalculation$inboundSchema: z.ZodMiniType<
  OrderUotTaxCalculation,
  unknown
> = openEnums.inboundSchema(OrderUotTaxCalculation);

/** @internal */
export const OrderBillingPeriod$inboundSchema: z.ZodMiniType<
  OrderBillingPeriod,
  unknown
> = z.object({
  duration: types.optional(types.number()),
  uot: types.optional(OrderUotTaxCalculation$inboundSchema),
});

export function orderBillingPeriodFromJSON(
  jsonString: string,
): SafeParseResult<OrderBillingPeriod, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderBillingPeriod$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderBillingPeriod' from JSON`,
  );
}

/** @internal */
export const OrderBillingDay$inboundSchema: z.ZodMiniType<
  OrderBillingDay,
  unknown
> = z.pipe(
  z.object({
    day_of_week: types.optional(types.string()),
    day_of_month: types.optional(types.number()),
    month_of_year: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "day_of_week": "dayOfWeek",
      "day_of_month": "dayOfMonth",
      "month_of_year": "monthOfYear",
    });
  }),
);

export function orderBillingDayFromJSON(
  jsonString: string,
): SafeParseResult<OrderBillingDay, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderBillingDay$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderBillingDay' from JSON`,
  );
}

/** @internal */
export const OrderBillingModel$inboundSchema: z.ZodMiniType<
  OrderBillingModel,
  unknown
> = openEnums.inboundSchema(OrderBillingModel);

/** @internal */
export const OrderTerms$inboundSchema: z.ZodMiniType<OrderTerms, unknown> = z
  .pipe(
    z.object({
      billing_period: types.optional(
        z.lazy(() => OrderBillingPeriod$inboundSchema),
      ),
      billing_day: types.optional(z.lazy(() => OrderBillingDay$inboundSchema)),
      billing_model: types.optional(OrderBillingModel$inboundSchema),
    }),
    z.transform((v) => {
      return remap$(v, {
        "billing_period": "billingPeriod",
        "billing_day": "billingDay",
        "billing_model": "billingModel",
      });
    }),
  );

export function orderTermsFromJSON(
  jsonString: string,
): SafeParseResult<OrderTerms, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderTerms$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderTerms' from JSON`,
  );
}

/** @internal */
export const OrderSubscription$inboundSchema: z.ZodMiniType<
  OrderSubscription,
  unknown
> = z.object({
  state: types.optional(OrderSubscriptionState$inboundSchema),
  terms: types.optional(z.lazy(() => OrderTerms$inboundSchema)),
});

export function orderSubscriptionFromJSON(
  jsonString: string,
): SafeParseResult<OrderSubscription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderSubscription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderSubscription' from JSON`,
  );
}

/** @internal */
export const OrderPausedPeriod$inboundSchema: z.ZodMiniType<
  OrderPausedPeriod,
  unknown
> = z.pipe(
  z.object({
    duration_in_days: types.optional(types.number()),
    starts_on: types.optional(types.number()),
    ends_on: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "duration_in_days": "durationInDays",
      "starts_on": "startsOn",
      "ends_on": "endsOn",
    });
  }),
);

export function orderPausedPeriodFromJSON(
  jsonString: string,
): SafeParseResult<OrderPausedPeriod, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderPausedPeriod$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderPausedPeriod' from JSON`,
  );
}

/** @internal */
export const OrderBilledPeriod$inboundSchema: z.ZodMiniType<
  OrderBilledPeriod,
  unknown
> = z.pipe(
  z.object({
    from_date: types.optional(types.number()),
    to_date: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "from_date": "fromDate",
      "to_date": "toDate",
    });
  }),
);

export function orderBilledPeriodFromJSON(
  jsonString: string,
): SafeParseResult<OrderBilledPeriod, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderBilledPeriod$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderBilledPeriod' from JSON`,
  );
}

/** @internal */
export const OrderTotals$inboundSchema: z.ZodMiniType<OrderTotals, unknown> = z
  .pipe(
    z.object({
      total_amount: types.optional(types.number()),
      tax_amount: types.optional(types.number()),
      net_amount: types.optional(types.number()),
      discount_amount: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "total_amount": "totalAmount",
        "tax_amount": "taxAmount",
        "net_amount": "netAmount",
        "discount_amount": "discountAmount",
      });
    }),
  );

export function orderTotalsFromJSON(
  jsonString: string,
): SafeParseResult<OrderTotals, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderTotals$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderTotals' from JSON`,
  );
}

/** @internal */
export const OrderFailureReason1$inboundSchema: z.ZodMiniEnum<
  typeof OrderFailureReason1
> = z.enum(OrderFailureReason1);

/** @internal */
export const OrderInvoicingTaxFailureReason$inboundSchema: z.ZodMiniType<
  OrderInvoicingTaxFailureReason,
  unknown
> = openEnums.inboundSchema(OrderInvoicingTaxFailureReason);

/** @internal */
export const OrderInvoicingTaxesBreakdownTaxCode$inboundSchema: z.ZodMiniType<
  OrderInvoicingTaxesBreakdownTaxCode,
  unknown
> = openEnums.inboundSchema(OrderInvoicingTaxesBreakdownTaxCode);
