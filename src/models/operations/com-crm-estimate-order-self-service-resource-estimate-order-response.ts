/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";
import {
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderServiceDeliveryEstimate,
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderServiceDeliveryEstimate$inboundSchema,
  InvalidProduct,
  InvalidProduct$inboundSchema,
  InvoiceEstimate,
  InvoiceEstimate$inboundSchema,
  MilestonePlanEstimate,
  MilestonePlanEstimate$inboundSchema,
  OrderBilledPeriod,
  OrderBilledPeriod$inboundSchema,
  OrderEstimate,
  OrderEstimate$inboundSchema,
  OrderFailureReason1,
  OrderFailureReason1$inboundSchema,
  OrderInvoiceEstimate,
  OrderInvoiceEstimate$inboundSchema,
  OrderInvoicingTaxesBreakdownTaxCode,
  OrderInvoicingTaxesBreakdownTaxCode$inboundSchema,
  OrderInvoicingTaxFailureReason,
  OrderInvoicingTaxFailureReason$inboundSchema,
  OrderOrderEstimate,
  OrderOrderEstimate$inboundSchema,
  OrderPausedPeriod,
  OrderPausedPeriod$inboundSchema,
  OrderSubscription,
  OrderSubscription$inboundSchema,
  OrderTotals,
  OrderTotals$inboundSchema,
} from "./order-invoicing-taxes-breakdown-tax-code.js";

export type OrderInvoicingTaxesBreakdownTaxRate = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  name?: string | undefined;
  taxCode?: OrderInvoicingTaxesBreakdownTaxCode | undefined;
  percentage?: number | undefined;
};

export type OrderInvoicingTaxesBreakdown = {
  taxRate?: OrderInvoicingTaxesBreakdownTaxRate | undefined;
  taxAmount?: number | undefined;
};

/**
 * Details about the applied discount
 */
export type OrderLineItemDiscount = {
  discountAmount?: number | undefined;
  discountPercentage?: number | undefined;
  discountInclTax?: number | undefined;
};

/**
 * Product type classification
 */
export const OrderLineItemProductClassification = {
  TermedService: "TERMED_SERVICE",
  UsageService: "USAGE_SERVICE",
  OneTimeService: "ONE_TIME_SERVICE",
  TraceablePhysicalGood: "TRACEABLE_PHYSICAL_GOOD",
  NonTraceablePhysicalGood: "NON_TRACEABLE_PHYSICAL_GOOD",
  ExpensesService: "EXPENSES_SERVICE",
} as const;
/**
 * Product type classification
 */
export type OrderLineItemProductClassification = OpenEnum<
  typeof OrderLineItemProductClassification
>;

/**
 * Details about the product
 */
export type OrderLineItemProduct = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The product name
   */
  name?: string | undefined;
  /**
   * The product SKU
   */
  sku?: string | undefined;
  /**
   * Product type classification
   */
  classification?: OrderLineItemProductClassification | undefined;
};

/**
 * Product type classification
 */
export const OrderLineItemBundleProductClassification = {
  TermedService: "TERMED_SERVICE",
  UsageService: "USAGE_SERVICE",
  OneTimeService: "ONE_TIME_SERVICE",
  TraceablePhysicalGood: "TRACEABLE_PHYSICAL_GOOD",
  NonTraceablePhysicalGood: "NON_TRACEABLE_PHYSICAL_GOOD",
  ExpensesService: "EXPENSES_SERVICE",
} as const;
/**
 * Product type classification
 */
export type OrderLineItemBundleProductClassification = OpenEnum<
  typeof OrderLineItemBundleProductClassification
>;

/**
 * Defines the main product that the line item is component to it (applicable only when the line item is invoiced as a component of another product)
 */
export type OrderLineItemBundleProduct = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The product name
   */
  name?: string | undefined;
  /**
   * The product SKU
   */
  sku?: string | undefined;
  /**
   * Product type classification
   */
  classification?: OrderLineItemBundleProductClassification | undefined;
};

/**
 * Termed service’s debited/credited period
 */
export type OrderLineItemPeriod = {
  /**
   * The date from which the service is invoiced/credited
   */
  from?: number | undefined;
  /**
   * The date until which the service is invoiced/credited
   */
  to?: number | undefined;
};

export const OrderLineItemTaxCode = {
  Vat: "VAT",
  TaxExempt: "TAX_EXEMPT",
  SalesTax: "SALES_TAX",
  Other: "OTHER",
} as const;
export type OrderLineItemTaxCode = OpenEnum<typeof OrderLineItemTaxCode>;

export type OrderLineItemTaxRate = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  name?: string | undefined;
  taxCode?: OrderLineItemTaxCode | undefined;
  percentage?: number | undefined;
};

export const OrderLineItemTaxExemptReason = {
  Contact: "CONTACT",
  Product: "PRODUCT",
} as const;
export type OrderLineItemTaxExemptReason = OpenEnum<
  typeof OrderLineItemTaxExemptReason
>;

export type OrderLineItemAppliedTax = {
  taxRate?: OrderLineItemTaxRate | undefined;
  taxAmount?: number | undefined;
  taxExemptReason?: OrderLineItemTaxExemptReason | undefined;
};

export type OrderLineItem = {
  quantity?: number | undefined;
  unitPrice?: number | undefined;
  netAmount?: number | undefined;
  taxAmount?: number | undefined;
  subTotal?: number | undefined;
  /**
   * The price of the product as this is configured in the product catalog (including tax or not depending on the tax model)
   */
  pricing?: number | undefined;
  /**
   * Details about the applied discount
   */
  discount?: OrderLineItemDiscount | undefined;
  /**
   * Details about the product
   */
  product?: OrderLineItemProduct | undefined;
  /**
   * Defines the main product that the line item is component to it (applicable only when the line item is invoiced as a component of another product)
   */
  bundleProduct?: OrderLineItemBundleProduct | undefined;
  /**
   * Termed service’s debited/credited period
   */
  period?: OrderLineItemPeriod | undefined;
  /**
   * Details about the applied taxes
   */
  appliedTaxes?: Array<OrderLineItemAppliedTax> | undefined;
};

/**
 * Type of discount applied
 */
export const OrderInvoicingType = {
  AdHoc: "AD_HOC",
  Promotion: "PROMOTION",
  AutoApplied: "AUTO_APPLIED",
} as const;
/**
 * Type of discount applied
 */
export type OrderInvoicingType = OpenEnum<typeof OrderInvoicingType>;

/**
 * The applied Promotion. Applicable when discount type is Promotion
 */
export type OrderInvoicingPromotion = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
};

export type OrderInvoicingDiscount = {
  /**
   * The deducted amount
   */
  amount?: number | undefined;
  /**
   * Type of discount applied
   */
  type?: OrderInvoicingType | undefined;
  /**
   * The applied Promotion. Applicable when discount type is Promotion
   */
  promotion?: OrderInvoicingPromotion | undefined;
};

export type OrderInvoicing = {
  issuedDate?: number | undefined;
  dueDate?: number | undefined;
  currencyCode?: string | undefined;
  isCredit?: boolean | undefined;
  totalNetAmount?: number | undefined;
  totalDiscountAmount?: number | undefined;
  totalTaxAmount?: number | undefined;
  /**
   * Total amount of the invoice that will be generated. Includes taxed and disoucnt amounts
   */
  totalAmount?: number | undefined;
  walletFundsAmount?: number | undefined;
  /**
   * The amount that will be due at the time of the estimation
   */
  amountDue?: number | undefined;
  /**
   * Amount that the customer needs to pay at the time of the estimation
   */
  amountToCollect?: number | undefined;
  totalDiscountInclTax?: number | undefined;
  /**
   * Sum of all products’ prices as these are defined in the product catalog
   */
  totalPrice?: number | undefined;
  accountFunds?: number | undefined;
  /**
   * Indicates whether taxes failed to be calculated by the online taxation service
   */
  taxCalculationFailed?: boolean | undefined;
  /**
   * Shows the reason for failing to calculating taxes for the invoice, typically because there's an issue with the online taxation service
   */
  taxFailureReason?: OrderInvoicingTaxFailureReason | undefined;
  taxesBreakdown?: Array<OrderInvoicingTaxesBreakdown> | undefined;
  lineItems?: Array<OrderLineItem> | undefined;
  discounts?: Array<OrderInvoicingDiscount> | undefined;
};

export type OrderBillingEstimate = {
  billedPeriod?: OrderBilledPeriod | undefined;
  totals?: OrderTotals | undefined;
  failureReason?: OrderFailureReason1 | undefined;
  invoicing?: Array<OrderInvoicing> | undefined;
  billingDate?: number | undefined;
};

export type OrderService = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
  /**
   * The entity sku
   */
  sku?: string | undefined;
};

export type OrderComponentsAdded = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
  /**
   * The entity sku
   */
  sku?: string | undefined;
};

export type OrderComponentsRemoved = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
  /**
   * The entity sku
   */
  sku?: string | undefined;
};

export type OrderComponentsChange = {
  service?: OrderService | undefined;
  componentsAdded?: Array<OrderComponentsAdded> | undefined;
  componentsRemoved?: Array<OrderComponentsRemoved> | undefined;
};

export const OrderFailureReason2 = {
  TaxCalculation: "TAX_CALCULATION",
} as const;
export type OrderFailureReason2 = ClosedEnum<typeof OrderFailureReason2>;

/**
 * Service's State
 */
export const OrderServicesToAddState = {
  Draft: "DRAFT",
  Effective: "EFFECTIVE",
  NotEffective: "NOT_EFFECTIVE",
  Paused: "PAUSED",
  Regretted: "REGRETTED",
  Cancelled: "CANCELLED",
  Swapped: "SWAPPED",
  Removed: "REMOVED",
} as const;
/**
 * Service's State
 */
export type OrderServicesToAddState = OpenEnum<typeof OrderServicesToAddState>;

export type OrderServicesToAddProduct = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
  /**
   * The entity sku
   */
  sku?: string | undefined;
};

export type OrderServicesToAddTrialPeriod = {
  startsOn?: number | undefined;
  endsOn?: number | undefined;
};

export type OrderServicesToAddDependency = {
  itemType?: string | undefined;
  itemId?: string | undefined;
  itemName?: string | undefined;
  itemSku?: string | undefined;
  dependency?: string | undefined;
  dependencyMet?: boolean | undefined;
  quantity?: number | undefined;
  missingQuantity?: number | undefined;
};

export type OrderServicesToAddComponentDependency = {
  itemType?: string | undefined;
  itemId?: string | undefined;
  itemName?: string | undefined;
  itemSku?: string | undefined;
  dependency?: string | undefined;
  dependencyMet?: boolean | undefined;
  quantity?: number | undefined;
  missingQuantity?: number | undefined;
};

export type OrderServicesToAddComponent = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  sku?: string | undefined;
  name?: string | undefined;
  quantity?: number | undefined;
  dependencies?: Array<OrderServicesToAddComponentDependency> | undefined;
};

export type OrderServicesToAdd = {
  /**
   * Service's State
   */
  state?: OrderServicesToAddState | undefined;
  product?: OrderServicesToAddProduct | undefined;
  trialPeriod?: OrderServicesToAddTrialPeriod | undefined;
  quantity?: number | undefined;
  dependencies?: Array<OrderServicesToAddDependency> | undefined;
  components?: Array<OrderServicesToAddComponent> | undefined;
};

/**
 * Service's State
 */
export const OrderServicesToRemoveState = {
  Draft: "DRAFT",
  Effective: "EFFECTIVE",
  NotEffective: "NOT_EFFECTIVE",
  Paused: "PAUSED",
  Regretted: "REGRETTED",
  Cancelled: "CANCELLED",
  Swapped: "SWAPPED",
  Removed: "REMOVED",
} as const;
/**
 * Service's State
 */
export type OrderServicesToRemoveState = OpenEnum<
  typeof OrderServicesToRemoveState
>;

export type OrderServicesToRemoveProduct = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
  /**
   * The entity sku
   */
  sku?: string | undefined;
};

export type OrderServicesToRemove = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * Service's State
   */
  state?: OrderServicesToRemoveState | undefined;
  product?: OrderServicesToRemoveProduct | undefined;
};

/**
 * Service's State
 */
export const OrderServicesToChangeState = {
  Draft: "DRAFT",
  Effective: "EFFECTIVE",
  NotEffective: "NOT_EFFECTIVE",
  Paused: "PAUSED",
  Regretted: "REGRETTED",
  Cancelled: "CANCELLED",
  Swapped: "SWAPPED",
  Removed: "REMOVED",
} as const;
/**
 * Service's State
 */
export type OrderServicesToChangeState = OpenEnum<
  typeof OrderServicesToChangeState
>;

export type OrderServicesToChangeProduct = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
  /**
   * The entity sku
   */
  sku?: string | undefined;
};

export type OrderChangeToProduct = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
  /**
   * The entity sku
   */
  sku?: string | undefined;
};

export type OrderServicesToChangeDependency = {
  itemType?: string | undefined;
  itemId?: string | undefined;
  itemName?: string | undefined;
  itemSku?: string | undefined;
  dependency?: string | undefined;
  dependencyMet?: boolean | undefined;
  quantity?: number | undefined;
  missingQuantity?: number | undefined;
};

export type OrderServicesToChange = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * Service's State
   */
  state?: OrderServicesToChangeState | undefined;
  product?: OrderServicesToChangeProduct | undefined;
  changeToProduct?: OrderChangeToProduct | undefined;
  quantity?: number | undefined;
  dependencies?: Array<OrderServicesToChangeDependency> | undefined;
};

/**
 * Service's State
 */
export const OrderServicesToUpdateState = {
  Draft: "DRAFT",
  Effective: "EFFECTIVE",
  NotEffective: "NOT_EFFECTIVE",
  Paused: "PAUSED",
  Regretted: "REGRETTED",
  Cancelled: "CANCELLED",
  Swapped: "SWAPPED",
  Removed: "REMOVED",
} as const;
/**
 * Service's State
 */
export type OrderServicesToUpdateState = OpenEnum<
  typeof OrderServicesToUpdateState
>;

export type OrderServicesToUpdateProduct = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
  /**
   * The entity sku
   */
  sku?: string | undefined;
};

export type OrderServicesToUpdateTrialPeriod = {
  startsOn?: number | undefined;
  endsOn?: number | undefined;
};

export type OrderServicesToUpdateDependency = {
  itemType?: string | undefined;
  itemId?: string | undefined;
  itemName?: string | undefined;
  itemSku?: string | undefined;
  dependency?: string | undefined;
  dependencyMet?: boolean | undefined;
  quantity?: number | undefined;
  missingQuantity?: number | undefined;
};

export type OrderServicesToUpdateComponentDependency = {
  itemType?: string | undefined;
  itemId?: string | undefined;
  itemName?: string | undefined;
  itemSku?: string | undefined;
  dependency?: string | undefined;
  dependencyMet?: boolean | undefined;
  quantity?: number | undefined;
  missingQuantity?: number | undefined;
};

export type OrderServicesToUpdateComponent = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  sku?: string | undefined;
  name?: string | undefined;
  quantity?: number | undefined;
  dependencies?: Array<OrderServicesToUpdateComponentDependency> | undefined;
};

export type OrderServicesToUpdate = {
  /**
   * Service's State
   */
  state?: OrderServicesToUpdateState | undefined;
  product?: OrderServicesToUpdateProduct | undefined;
  trialPeriod?: OrderServicesToUpdateTrialPeriod | undefined;
  quantity?: number | undefined;
  dependencies?: Array<OrderServicesToUpdateDependency> | undefined;
  components?: Array<OrderServicesToUpdateComponent> | undefined;
};

export type OrderDevicesAddedProduct = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
  /**
   * The entity sku
   */
  sku?: string | undefined;
};

export type OrderDevicesAdded = {
  quantity?: number | undefined;
  product?: OrderDevicesAddedProduct | undefined;
  serialNumber?: Array<string> | undefined;
};

export type OrderServiceDeliveryEstimate = {
  actionAllowed?: boolean | undefined;
  allowedExecutionOn?: number | undefined;
  nextBillingAt?: number | undefined;
  nextPaymentDate?: number | undefined;
  subscription?: OrderSubscription | undefined;
  pausedPeriod?: OrderPausedPeriod | undefined;
  billingEstimate?: OrderBillingEstimate | undefined;
  componentsChange?: OrderComponentsChange | undefined;
  failureReason?: OrderFailureReason2 | undefined;
  servicesToAdd?: Array<OrderServicesToAdd> | undefined;
  servicesToRemove?: Array<OrderServicesToRemove> | undefined;
  servicesToChange?: Array<OrderServicesToChange> | undefined;
  servicesToUpdate?: Array<OrderServicesToUpdate> | undefined;
  devicesAdded?: Array<OrderDevicesAdded> | undefined;
};

/**
 * The milestone's stage i.e. when the Invoice will be issued.
 */
export type OrderStage = {
  id?: string | undefined;
  name?: string | undefined;
  colour?: string | undefined;
  priority?: number | undefined;
};

export type OrderMilestonePlanEstimate = {
  /**
   * The milestone's stage i.e. when the Invoice will be issued.
   */
  stage?: OrderStage | undefined;
  /**
   * The milestone’s percentage amount as this is configured in the Order queue
   */
  queuePercentage?: number | undefined;
  /**
   * the milestone’s percentage for this specified queue.
   */
  percentage?: number | undefined;
  /**
   * calculated amount based on order quotation amount x by the percentage. If percentage = null then this amount = order quotation amount x queue percentage.
   */
  amount?: number | undefined;
};

/**
 * Details on why the product is considered as invalid and cannot be included in the Order
 *
 * @remarks
 *  * `VALIDITY_PERIOD` - The prodcut’s validity period has expired, i.e. the business is no longer selling this product
 *  * `AVAILABILITY` - The product is temporarily un-available for sale at/by the requested organisation e.g. is out of stock
 *  * `ORDER_CATALOGUE` - The product is not included in an valid/effective Order Catalogue.
 *  * `STOCK` - The product does not have enough stock.
 */
export const OrderUnavailabilityReason = {
  Stock: "STOCK",
  ValidityPeriod: "VALIDITY_PERIOD",
  Availability: "AVAILABILITY",
  OrderCatalogue: "ORDER_CATALOGUE",
} as const;
/**
 * Details on why the product is considered as invalid and cannot be included in the Order
 *
 * @remarks
 *  * `VALIDITY_PERIOD` - The prodcut’s validity period has expired, i.e. the business is no longer selling this product
 *  * `AVAILABILITY` - The product is temporarily un-available for sale at/by the requested organisation e.g. is out of stock
 *  * `ORDER_CATALOGUE` - The product is not included in an valid/effective Order Catalogue.
 *  * `STOCK` - The product does not have enough stock.
 */
export type OrderUnavailabilityReason = OpenEnum<
  typeof OrderUnavailabilityReason
>;

/**
 * Product included in the request’s ordered items
 */
export type OrderInvalidProductProduct = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
  /**
   * The entity sku
   */
  sku?: string | undefined;
};

export type OrderInvalidProduct = {
  /**
   * Details on why the product is considered as invalid and cannot be included in the Order
   *
   * @remarks
   *  * `VALIDITY_PERIOD` - The prodcut’s validity period has expired, i.e. the business is no longer selling this product
   *  * `AVAILABILITY` - The product is temporarily un-available for sale at/by the requested organisation e.g. is out of stock
   *  * `ORDER_CATALOGUE` - The product is not included in an valid/effective Order Catalogue.
   *  * `STOCK` - The product does not have enough stock.
   */
  unavailabilityReason?: OrderUnavailabilityReason | undefined;
  /**
   * Product included in the request’s ordered items
   */
  product?: OrderInvalidProductProduct | undefined;
  /**
   * The quantity of the product that is available for the customer to order
   */
  inStock?: number | undefined;
};

export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderOrder = {
  /**
   * The estimation id
   */
  id?: string | undefined;
  /**
   * An estimation on if the Order can be placed and if yes, then its detailed information that includes fulfillment and invoicing details.
   */
  orderEstimate?: OrderOrderEstimate | undefined;
  /**
   * The outright order’s invoicing information. This invoice estimation includes only physical goods ordered as well as One-Time services. It does not include any invoicing or billing information for ordered termed services
   */
  invoiceEstimate?: OrderInvoiceEstimate | undefined;
  /**
   * Applicable only when purchasing termed services and/or renting devices.Returns detailed billing information on the ordered termed services as well as details on their subscriptions.
   */
  serviceDeliveryEstimate?: Array<OrderServiceDeliveryEstimate> | undefined;
  /**
   * The Order's milestone plans plus each milestone's amount.
   */
  milestonePlanEstimate?: Array<OrderMilestonePlanEstimate> | undefined;
  /**
   * List of ordered items which were included in the order but cannot be delivered to the consumer at the time of estimation. Invalid ordered products are excluded from the orders cost estimation.
   */
  invalidProducts?: Array<OrderInvalidProduct> | undefined;
  subscriptionEstimationAmount?: number | undefined;
};

/**
 * OK
 */
export type ComCrmEstimateOrderSelfServiceResourceEstimateOrderResponse = {
  /**
   * The estimation id
   */
  id?: string | undefined;
  /**
   * An estimation on if the Order can be placed and if yes, then its detailed information that includes fulfillment and invoicing details.
   */
  orderEstimate?: OrderEstimate | undefined;
  /**
   * The outright order’s invoicing information. This invoice estimation includes only physical goods ordered as well as One-Time services. It does not include any invoicing or billing information for ordered termed services
   */
  invoiceEstimate?: InvoiceEstimate | undefined;
  /**
   * Applicable only when purchasing termed services and/or renting devices.Returns detailed billing information on the ordered termed services as well as details on their subscriptions.
   */
  serviceDeliveryEstimate?:
    | Array<
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderServiceDeliveryEstimate
    >
    | undefined;
  /**
   * The Order's milestone plans plus each milestone's amount.
   */
  milestonePlanEstimate?: Array<MilestonePlanEstimate> | undefined;
  /**
   * List of ordered items which were included in the order but cannot be delivered to the consumer at the time of estimation. Invalid ordered products are excluded from the orders cost estimation.
   */
  invalidProducts?: Array<InvalidProduct> | undefined;
  /**
   * The Order(s) that will be created. In case where products from multiple B2B Merchants, multiple orders are returned, one for each B2B Merchant.
   */
  orders?:
    | Array<ComCrmEstimateOrderSelfServiceResourceEstimateOrderOrder>
    | undefined;
};

/** @internal */
export const OrderInvoicingTaxesBreakdownTaxRate$inboundSchema: z.ZodMiniType<
  OrderInvoicingTaxesBreakdownTaxRate,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    tax_code: types.optional(OrderInvoicingTaxesBreakdownTaxCode$inboundSchema),
    percentage: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "tax_code": "taxCode",
    });
  }),
);

export function orderInvoicingTaxesBreakdownTaxRateFromJSON(
  jsonString: string,
): SafeParseResult<OrderInvoicingTaxesBreakdownTaxRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OrderInvoicingTaxesBreakdownTaxRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderInvoicingTaxesBreakdownTaxRate' from JSON`,
  );
}

/** @internal */
export const OrderInvoicingTaxesBreakdown$inboundSchema: z.ZodMiniType<
  OrderInvoicingTaxesBreakdown,
  unknown
> = z.pipe(
  z.object({
    tax_rate: types.optional(
      z.lazy(() => OrderInvoicingTaxesBreakdownTaxRate$inboundSchema),
    ),
    tax_amount: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "tax_rate": "taxRate",
      "tax_amount": "taxAmount",
    });
  }),
);

export function orderInvoicingTaxesBreakdownFromJSON(
  jsonString: string,
): SafeParseResult<OrderInvoicingTaxesBreakdown, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderInvoicingTaxesBreakdown$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderInvoicingTaxesBreakdown' from JSON`,
  );
}

/** @internal */
export const OrderLineItemDiscount$inboundSchema: z.ZodMiniType<
  OrderLineItemDiscount,
  unknown
> = z.pipe(
  z.object({
    discount_amount: types.optional(types.number()),
    discount_percentage: types.optional(types.number()),
    discount_incl_tax: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "discount_amount": "discountAmount",
      "discount_percentage": "discountPercentage",
      "discount_incl_tax": "discountInclTax",
    });
  }),
);

export function orderLineItemDiscountFromJSON(
  jsonString: string,
): SafeParseResult<OrderLineItemDiscount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderLineItemDiscount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderLineItemDiscount' from JSON`,
  );
}

/** @internal */
export const OrderLineItemProductClassification$inboundSchema: z.ZodMiniType<
  OrderLineItemProductClassification,
  unknown
> = openEnums.inboundSchema(OrderLineItemProductClassification);

/** @internal */
export const OrderLineItemProduct$inboundSchema: z.ZodMiniType<
  OrderLineItemProduct,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
  sku: types.optional(types.string()),
  classification: types.optional(
    OrderLineItemProductClassification$inboundSchema,
  ),
});

export function orderLineItemProductFromJSON(
  jsonString: string,
): SafeParseResult<OrderLineItemProduct, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderLineItemProduct$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderLineItemProduct' from JSON`,
  );
}

/** @internal */
export const OrderLineItemBundleProductClassification$inboundSchema:
  z.ZodMiniType<OrderLineItemBundleProductClassification, unknown> = openEnums
    .inboundSchema(OrderLineItemBundleProductClassification);

/** @internal */
export const OrderLineItemBundleProduct$inboundSchema: z.ZodMiniType<
  OrderLineItemBundleProduct,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
  sku: types.optional(types.string()),
  classification: types.optional(
    OrderLineItemBundleProductClassification$inboundSchema,
  ),
});

export function orderLineItemBundleProductFromJSON(
  jsonString: string,
): SafeParseResult<OrderLineItemBundleProduct, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderLineItemBundleProduct$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderLineItemBundleProduct' from JSON`,
  );
}

/** @internal */
export const OrderLineItemPeriod$inboundSchema: z.ZodMiniType<
  OrderLineItemPeriod,
  unknown
> = z.object({
  from: types.optional(types.number()),
  to: types.optional(types.number()),
});

export function orderLineItemPeriodFromJSON(
  jsonString: string,
): SafeParseResult<OrderLineItemPeriod, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderLineItemPeriod$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderLineItemPeriod' from JSON`,
  );
}

/** @internal */
export const OrderLineItemTaxCode$inboundSchema: z.ZodMiniType<
  OrderLineItemTaxCode,
  unknown
> = openEnums.inboundSchema(OrderLineItemTaxCode);

/** @internal */
export const OrderLineItemTaxRate$inboundSchema: z.ZodMiniType<
  OrderLineItemTaxRate,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    tax_code: types.optional(OrderLineItemTaxCode$inboundSchema),
    percentage: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "tax_code": "taxCode",
    });
  }),
);

export function orderLineItemTaxRateFromJSON(
  jsonString: string,
): SafeParseResult<OrderLineItemTaxRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderLineItemTaxRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderLineItemTaxRate' from JSON`,
  );
}

/** @internal */
export const OrderLineItemTaxExemptReason$inboundSchema: z.ZodMiniType<
  OrderLineItemTaxExemptReason,
  unknown
> = openEnums.inboundSchema(OrderLineItemTaxExemptReason);

/** @internal */
export const OrderLineItemAppliedTax$inboundSchema: z.ZodMiniType<
  OrderLineItemAppliedTax,
  unknown
> = z.pipe(
  z.object({
    tax_rate: types.optional(z.lazy(() => OrderLineItemTaxRate$inboundSchema)),
    tax_amount: types.optional(types.number()),
    tax_exempt_reason: types.optional(
      OrderLineItemTaxExemptReason$inboundSchema,
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "tax_rate": "taxRate",
      "tax_amount": "taxAmount",
      "tax_exempt_reason": "taxExemptReason",
    });
  }),
);

export function orderLineItemAppliedTaxFromJSON(
  jsonString: string,
): SafeParseResult<OrderLineItemAppliedTax, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderLineItemAppliedTax$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderLineItemAppliedTax' from JSON`,
  );
}

/** @internal */
export const OrderLineItem$inboundSchema: z.ZodMiniType<
  OrderLineItem,
  unknown
> = z.pipe(
  z.object({
    quantity: types.optional(types.number()),
    unit_price: types.optional(types.number()),
    net_amount: types.optional(types.number()),
    tax_amount: types.optional(types.number()),
    sub_total: types.optional(types.number()),
    pricing: types.optional(types.number()),
    discount: types.optional(z.lazy(() => OrderLineItemDiscount$inboundSchema)),
    product: types.optional(z.lazy(() => OrderLineItemProduct$inboundSchema)),
    bundle_product: types.optional(
      z.lazy(() => OrderLineItemBundleProduct$inboundSchema),
    ),
    period: types.optional(z.lazy(() => OrderLineItemPeriod$inboundSchema)),
    applied_taxes: types.optional(
      z.array(z.lazy(() => OrderLineItemAppliedTax$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "unit_price": "unitPrice",
      "net_amount": "netAmount",
      "tax_amount": "taxAmount",
      "sub_total": "subTotal",
      "bundle_product": "bundleProduct",
      "applied_taxes": "appliedTaxes",
    });
  }),
);

export function orderLineItemFromJSON(
  jsonString: string,
): SafeParseResult<OrderLineItem, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderLineItem$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderLineItem' from JSON`,
  );
}

/** @internal */
export const OrderInvoicingType$inboundSchema: z.ZodMiniType<
  OrderInvoicingType,
  unknown
> = openEnums.inboundSchema(OrderInvoicingType);

/** @internal */
export const OrderInvoicingPromotion$inboundSchema: z.ZodMiniType<
  OrderInvoicingPromotion,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
});

export function orderInvoicingPromotionFromJSON(
  jsonString: string,
): SafeParseResult<OrderInvoicingPromotion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderInvoicingPromotion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderInvoicingPromotion' from JSON`,
  );
}

/** @internal */
export const OrderInvoicingDiscount$inboundSchema: z.ZodMiniType<
  OrderInvoicingDiscount,
  unknown
> = z.object({
  amount: types.optional(types.number()),
  type: types.optional(OrderInvoicingType$inboundSchema),
  promotion: types.optional(
    z.lazy(() => OrderInvoicingPromotion$inboundSchema),
  ),
});

export function orderInvoicingDiscountFromJSON(
  jsonString: string,
): SafeParseResult<OrderInvoicingDiscount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderInvoicingDiscount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderInvoicingDiscount' from JSON`,
  );
}

/** @internal */
export const OrderInvoicing$inboundSchema: z.ZodMiniType<
  OrderInvoicing,
  unknown
> = z.pipe(
  z.object({
    issued_date: types.optional(types.number()),
    due_date: types.optional(types.number()),
    currency_code: types.optional(types.string()),
    is_credit: types.optional(types.boolean()),
    total_net_amount: types.optional(types.number()),
    total_discount_amount: types.optional(types.number()),
    total_tax_amount: types.optional(types.number()),
    total_amount: types.optional(types.number()),
    wallet_funds_amount: types.optional(types.number()),
    amount_due: types.optional(types.number()),
    amount_to_collect: types.optional(types.number()),
    total_discount_incl_tax: types.optional(types.number()),
    total_price: types.optional(types.number()),
    account_funds: types.optional(types.number()),
    tax_calculation_failed: types.optional(types.boolean()),
    tax_failure_reason: types.optional(
      OrderInvoicingTaxFailureReason$inboundSchema,
    ),
    taxes_breakdown: types.optional(
      z.array(z.lazy(() => OrderInvoicingTaxesBreakdown$inboundSchema)),
    ),
    line_items: types.optional(
      z.array(z.lazy(() => OrderLineItem$inboundSchema)),
    ),
    discounts: types.optional(
      z.array(z.lazy(() => OrderInvoicingDiscount$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "issued_date": "issuedDate",
      "due_date": "dueDate",
      "currency_code": "currencyCode",
      "is_credit": "isCredit",
      "total_net_amount": "totalNetAmount",
      "total_discount_amount": "totalDiscountAmount",
      "total_tax_amount": "totalTaxAmount",
      "total_amount": "totalAmount",
      "wallet_funds_amount": "walletFundsAmount",
      "amount_due": "amountDue",
      "amount_to_collect": "amountToCollect",
      "total_discount_incl_tax": "totalDiscountInclTax",
      "total_price": "totalPrice",
      "account_funds": "accountFunds",
      "tax_calculation_failed": "taxCalculationFailed",
      "tax_failure_reason": "taxFailureReason",
      "taxes_breakdown": "taxesBreakdown",
      "line_items": "lineItems",
    });
  }),
);

export function orderInvoicingFromJSON(
  jsonString: string,
): SafeParseResult<OrderInvoicing, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderInvoicing$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderInvoicing' from JSON`,
  );
}

/** @internal */
export const OrderBillingEstimate$inboundSchema: z.ZodMiniType<
  OrderBillingEstimate,
  unknown
> = z.pipe(
  z.object({
    billed_period: types.optional(OrderBilledPeriod$inboundSchema),
    totals: types.optional(OrderTotals$inboundSchema),
    failure_reason: types.optional(OrderFailureReason1$inboundSchema),
    invoicing: types.optional(
      z.array(z.lazy(() => OrderInvoicing$inboundSchema)),
    ),
    billing_date: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "billed_period": "billedPeriod",
      "failure_reason": "failureReason",
      "billing_date": "billingDate",
    });
  }),
);

export function orderBillingEstimateFromJSON(
  jsonString: string,
): SafeParseResult<OrderBillingEstimate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderBillingEstimate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderBillingEstimate' from JSON`,
  );
}

/** @internal */
export const OrderService$inboundSchema: z.ZodMiniType<OrderService, unknown> =
  z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    sku: types.optional(types.string()),
  });

export function orderServiceFromJSON(
  jsonString: string,
): SafeParseResult<OrderService, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderService$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderService' from JSON`,
  );
}

/** @internal */
export const OrderComponentsAdded$inboundSchema: z.ZodMiniType<
  OrderComponentsAdded,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
  sku: types.optional(types.string()),
});

export function orderComponentsAddedFromJSON(
  jsonString: string,
): SafeParseResult<OrderComponentsAdded, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderComponentsAdded$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderComponentsAdded' from JSON`,
  );
}

/** @internal */
export const OrderComponentsRemoved$inboundSchema: z.ZodMiniType<
  OrderComponentsRemoved,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
  sku: types.optional(types.string()),
});

export function orderComponentsRemovedFromJSON(
  jsonString: string,
): SafeParseResult<OrderComponentsRemoved, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderComponentsRemoved$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderComponentsRemoved' from JSON`,
  );
}

/** @internal */
export const OrderComponentsChange$inboundSchema: z.ZodMiniType<
  OrderComponentsChange,
  unknown
> = z.pipe(
  z.object({
    service: types.optional(z.lazy(() => OrderService$inboundSchema)),
    components_added: types.optional(
      z.array(z.lazy(() => OrderComponentsAdded$inboundSchema)),
    ),
    components_removed: types.optional(
      z.array(z.lazy(() => OrderComponentsRemoved$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "components_added": "componentsAdded",
      "components_removed": "componentsRemoved",
    });
  }),
);

export function orderComponentsChangeFromJSON(
  jsonString: string,
): SafeParseResult<OrderComponentsChange, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderComponentsChange$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderComponentsChange' from JSON`,
  );
}

/** @internal */
export const OrderFailureReason2$inboundSchema: z.ZodMiniEnum<
  typeof OrderFailureReason2
> = z.enum(OrderFailureReason2);

/** @internal */
export const OrderServicesToAddState$inboundSchema: z.ZodMiniType<
  OrderServicesToAddState,
  unknown
> = openEnums.inboundSchema(OrderServicesToAddState);

/** @internal */
export const OrderServicesToAddProduct$inboundSchema: z.ZodMiniType<
  OrderServicesToAddProduct,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
  sku: types.optional(types.string()),
});

export function orderServicesToAddProductFromJSON(
  jsonString: string,
): SafeParseResult<OrderServicesToAddProduct, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderServicesToAddProduct$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderServicesToAddProduct' from JSON`,
  );
}

/** @internal */
export const OrderServicesToAddTrialPeriod$inboundSchema: z.ZodMiniType<
  OrderServicesToAddTrialPeriod,
  unknown
> = z.pipe(
  z.object({
    starts_on: types.optional(types.number()),
    ends_on: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "starts_on": "startsOn",
      "ends_on": "endsOn",
    });
  }),
);

export function orderServicesToAddTrialPeriodFromJSON(
  jsonString: string,
): SafeParseResult<OrderServicesToAddTrialPeriod, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderServicesToAddTrialPeriod$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderServicesToAddTrialPeriod' from JSON`,
  );
}

/** @internal */
export const OrderServicesToAddDependency$inboundSchema: z.ZodMiniType<
  OrderServicesToAddDependency,
  unknown
> = z.pipe(
  z.object({
    item_type: types.optional(types.string()),
    item_id: types.optional(types.string()),
    item_name: types.optional(types.string()),
    item_sku: types.optional(types.string()),
    dependency: types.optional(types.string()),
    dependency_met: types.optional(types.boolean()),
    quantity: types.optional(types.number()),
    missing_quantity: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "item_type": "itemType",
      "item_id": "itemId",
      "item_name": "itemName",
      "item_sku": "itemSku",
      "dependency_met": "dependencyMet",
      "missing_quantity": "missingQuantity",
    });
  }),
);

export function orderServicesToAddDependencyFromJSON(
  jsonString: string,
): SafeParseResult<OrderServicesToAddDependency, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderServicesToAddDependency$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderServicesToAddDependency' from JSON`,
  );
}

/** @internal */
export const OrderServicesToAddComponentDependency$inboundSchema: z.ZodMiniType<
  OrderServicesToAddComponentDependency,
  unknown
> = z.pipe(
  z.object({
    item_type: types.optional(types.string()),
    item_id: types.optional(types.string()),
    item_name: types.optional(types.string()),
    item_sku: types.optional(types.string()),
    dependency: types.optional(types.string()),
    dependency_met: types.optional(types.boolean()),
    quantity: types.optional(types.number()),
    missing_quantity: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "item_type": "itemType",
      "item_id": "itemId",
      "item_name": "itemName",
      "item_sku": "itemSku",
      "dependency_met": "dependencyMet",
      "missing_quantity": "missingQuantity",
    });
  }),
);

export function orderServicesToAddComponentDependencyFromJSON(
  jsonString: string,
): SafeParseResult<OrderServicesToAddComponentDependency, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      OrderServicesToAddComponentDependency$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderServicesToAddComponentDependency' from JSON`,
  );
}

/** @internal */
export const OrderServicesToAddComponent$inboundSchema: z.ZodMiniType<
  OrderServicesToAddComponent,
  unknown
> = z.object({
  id: types.optional(types.string()),
  sku: types.optional(types.string()),
  name: types.optional(types.string()),
  quantity: types.optional(types.number()),
  dependencies: types.optional(
    z.array(z.lazy(() => OrderServicesToAddComponentDependency$inboundSchema)),
  ),
});

export function orderServicesToAddComponentFromJSON(
  jsonString: string,
): SafeParseResult<OrderServicesToAddComponent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderServicesToAddComponent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderServicesToAddComponent' from JSON`,
  );
}

/** @internal */
export const OrderServicesToAdd$inboundSchema: z.ZodMiniType<
  OrderServicesToAdd,
  unknown
> = z.pipe(
  z.object({
    state: types.optional(OrderServicesToAddState$inboundSchema),
    product: types.optional(
      z.lazy(() => OrderServicesToAddProduct$inboundSchema),
    ),
    trial_period: types.optional(
      z.lazy(() => OrderServicesToAddTrialPeriod$inboundSchema),
    ),
    quantity: types.optional(types.number()),
    dependencies: types.optional(
      z.array(z.lazy(() => OrderServicesToAddDependency$inboundSchema)),
    ),
    components: types.optional(
      z.array(z.lazy(() => OrderServicesToAddComponent$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "trial_period": "trialPeriod",
    });
  }),
);

export function orderServicesToAddFromJSON(
  jsonString: string,
): SafeParseResult<OrderServicesToAdd, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderServicesToAdd$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderServicesToAdd' from JSON`,
  );
}

/** @internal */
export const OrderServicesToRemoveState$inboundSchema: z.ZodMiniType<
  OrderServicesToRemoveState,
  unknown
> = openEnums.inboundSchema(OrderServicesToRemoveState);

/** @internal */
export const OrderServicesToRemoveProduct$inboundSchema: z.ZodMiniType<
  OrderServicesToRemoveProduct,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
  sku: types.optional(types.string()),
});

export function orderServicesToRemoveProductFromJSON(
  jsonString: string,
): SafeParseResult<OrderServicesToRemoveProduct, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderServicesToRemoveProduct$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderServicesToRemoveProduct' from JSON`,
  );
}

/** @internal */
export const OrderServicesToRemove$inboundSchema: z.ZodMiniType<
  OrderServicesToRemove,
  unknown
> = z.object({
  id: types.optional(types.string()),
  state: types.optional(OrderServicesToRemoveState$inboundSchema),
  product: types.optional(
    z.lazy(() => OrderServicesToRemoveProduct$inboundSchema),
  ),
});

export function orderServicesToRemoveFromJSON(
  jsonString: string,
): SafeParseResult<OrderServicesToRemove, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderServicesToRemove$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderServicesToRemove' from JSON`,
  );
}

/** @internal */
export const OrderServicesToChangeState$inboundSchema: z.ZodMiniType<
  OrderServicesToChangeState,
  unknown
> = openEnums.inboundSchema(OrderServicesToChangeState);

/** @internal */
export const OrderServicesToChangeProduct$inboundSchema: z.ZodMiniType<
  OrderServicesToChangeProduct,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
  sku: types.optional(types.string()),
});

export function orderServicesToChangeProductFromJSON(
  jsonString: string,
): SafeParseResult<OrderServicesToChangeProduct, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderServicesToChangeProduct$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderServicesToChangeProduct' from JSON`,
  );
}

/** @internal */
export const OrderChangeToProduct$inboundSchema: z.ZodMiniType<
  OrderChangeToProduct,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
  sku: types.optional(types.string()),
});

export function orderChangeToProductFromJSON(
  jsonString: string,
): SafeParseResult<OrderChangeToProduct, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderChangeToProduct$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderChangeToProduct' from JSON`,
  );
}

/** @internal */
export const OrderServicesToChangeDependency$inboundSchema: z.ZodMiniType<
  OrderServicesToChangeDependency,
  unknown
> = z.pipe(
  z.object({
    item_type: types.optional(types.string()),
    item_id: types.optional(types.string()),
    item_name: types.optional(types.string()),
    item_sku: types.optional(types.string()),
    dependency: types.optional(types.string()),
    dependency_met: types.optional(types.boolean()),
    quantity: types.optional(types.number()),
    missing_quantity: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "item_type": "itemType",
      "item_id": "itemId",
      "item_name": "itemName",
      "item_sku": "itemSku",
      "dependency_met": "dependencyMet",
      "missing_quantity": "missingQuantity",
    });
  }),
);

export function orderServicesToChangeDependencyFromJSON(
  jsonString: string,
): SafeParseResult<OrderServicesToChangeDependency, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderServicesToChangeDependency$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderServicesToChangeDependency' from JSON`,
  );
}

/** @internal */
export const OrderServicesToChange$inboundSchema: z.ZodMiniType<
  OrderServicesToChange,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    state: types.optional(OrderServicesToChangeState$inboundSchema),
    product: types.optional(
      z.lazy(() => OrderServicesToChangeProduct$inboundSchema),
    ),
    change_to_product: types.optional(
      z.lazy(() => OrderChangeToProduct$inboundSchema),
    ),
    quantity: types.optional(types.number()),
    dependencies: types.optional(
      z.array(z.lazy(() => OrderServicesToChangeDependency$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "change_to_product": "changeToProduct",
    });
  }),
);

export function orderServicesToChangeFromJSON(
  jsonString: string,
): SafeParseResult<OrderServicesToChange, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderServicesToChange$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderServicesToChange' from JSON`,
  );
}

/** @internal */
export const OrderServicesToUpdateState$inboundSchema: z.ZodMiniType<
  OrderServicesToUpdateState,
  unknown
> = openEnums.inboundSchema(OrderServicesToUpdateState);

/** @internal */
export const OrderServicesToUpdateProduct$inboundSchema: z.ZodMiniType<
  OrderServicesToUpdateProduct,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
  sku: types.optional(types.string()),
});

export function orderServicesToUpdateProductFromJSON(
  jsonString: string,
): SafeParseResult<OrderServicesToUpdateProduct, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderServicesToUpdateProduct$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderServicesToUpdateProduct' from JSON`,
  );
}

/** @internal */
export const OrderServicesToUpdateTrialPeriod$inboundSchema: z.ZodMiniType<
  OrderServicesToUpdateTrialPeriod,
  unknown
> = z.pipe(
  z.object({
    starts_on: types.optional(types.number()),
    ends_on: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "starts_on": "startsOn",
      "ends_on": "endsOn",
    });
  }),
);

export function orderServicesToUpdateTrialPeriodFromJSON(
  jsonString: string,
): SafeParseResult<OrderServicesToUpdateTrialPeriod, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderServicesToUpdateTrialPeriod$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderServicesToUpdateTrialPeriod' from JSON`,
  );
}

/** @internal */
export const OrderServicesToUpdateDependency$inboundSchema: z.ZodMiniType<
  OrderServicesToUpdateDependency,
  unknown
> = z.pipe(
  z.object({
    item_type: types.optional(types.string()),
    item_id: types.optional(types.string()),
    item_name: types.optional(types.string()),
    item_sku: types.optional(types.string()),
    dependency: types.optional(types.string()),
    dependency_met: types.optional(types.boolean()),
    quantity: types.optional(types.number()),
    missing_quantity: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "item_type": "itemType",
      "item_id": "itemId",
      "item_name": "itemName",
      "item_sku": "itemSku",
      "dependency_met": "dependencyMet",
      "missing_quantity": "missingQuantity",
    });
  }),
);

export function orderServicesToUpdateDependencyFromJSON(
  jsonString: string,
): SafeParseResult<OrderServicesToUpdateDependency, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderServicesToUpdateDependency$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderServicesToUpdateDependency' from JSON`,
  );
}

/** @internal */
export const OrderServicesToUpdateComponentDependency$inboundSchema:
  z.ZodMiniType<OrderServicesToUpdateComponentDependency, unknown> = z.pipe(
    z.object({
      item_type: types.optional(types.string()),
      item_id: types.optional(types.string()),
      item_name: types.optional(types.string()),
      item_sku: types.optional(types.string()),
      dependency: types.optional(types.string()),
      dependency_met: types.optional(types.boolean()),
      quantity: types.optional(types.number()),
      missing_quantity: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "item_type": "itemType",
        "item_id": "itemId",
        "item_name": "itemName",
        "item_sku": "itemSku",
        "dependency_met": "dependencyMet",
        "missing_quantity": "missingQuantity",
      });
    }),
  );

export function orderServicesToUpdateComponentDependencyFromJSON(
  jsonString: string,
): SafeParseResult<
  OrderServicesToUpdateComponentDependency,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      OrderServicesToUpdateComponentDependency$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'OrderServicesToUpdateComponentDependency' from JSON`,
  );
}

/** @internal */
export const OrderServicesToUpdateComponent$inboundSchema: z.ZodMiniType<
  OrderServicesToUpdateComponent,
  unknown
> = z.object({
  id: types.optional(types.string()),
  sku: types.optional(types.string()),
  name: types.optional(types.string()),
  quantity: types.optional(types.number()),
  dependencies: types.optional(
    z.array(
      z.lazy(() => OrderServicesToUpdateComponentDependency$inboundSchema),
    ),
  ),
});

export function orderServicesToUpdateComponentFromJSON(
  jsonString: string,
): SafeParseResult<OrderServicesToUpdateComponent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderServicesToUpdateComponent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderServicesToUpdateComponent' from JSON`,
  );
}

/** @internal */
export const OrderServicesToUpdate$inboundSchema: z.ZodMiniType<
  OrderServicesToUpdate,
  unknown
> = z.pipe(
  z.object({
    state: types.optional(OrderServicesToUpdateState$inboundSchema),
    product: types.optional(
      z.lazy(() => OrderServicesToUpdateProduct$inboundSchema),
    ),
    trial_period: types.optional(
      z.lazy(() => OrderServicesToUpdateTrialPeriod$inboundSchema),
    ),
    quantity: types.optional(types.number()),
    dependencies: types.optional(
      z.array(z.lazy(() => OrderServicesToUpdateDependency$inboundSchema)),
    ),
    components: types.optional(
      z.array(z.lazy(() => OrderServicesToUpdateComponent$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "trial_period": "trialPeriod",
    });
  }),
);

export function orderServicesToUpdateFromJSON(
  jsonString: string,
): SafeParseResult<OrderServicesToUpdate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderServicesToUpdate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderServicesToUpdate' from JSON`,
  );
}

/** @internal */
export const OrderDevicesAddedProduct$inboundSchema: z.ZodMiniType<
  OrderDevicesAddedProduct,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
  sku: types.optional(types.string()),
});

export function orderDevicesAddedProductFromJSON(
  jsonString: string,
): SafeParseResult<OrderDevicesAddedProduct, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderDevicesAddedProduct$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderDevicesAddedProduct' from JSON`,
  );
}

/** @internal */
export const OrderDevicesAdded$inboundSchema: z.ZodMiniType<
  OrderDevicesAdded,
  unknown
> = z.pipe(
  z.object({
    quantity: types.optional(types.number()),
    product: types.optional(
      z.lazy(() => OrderDevicesAddedProduct$inboundSchema),
    ),
    serial_number: types.optional(z.array(types.string())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "serial_number": "serialNumber",
    });
  }),
);

export function orderDevicesAddedFromJSON(
  jsonString: string,
): SafeParseResult<OrderDevicesAdded, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderDevicesAdded$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderDevicesAdded' from JSON`,
  );
}

/** @internal */
export const OrderServiceDeliveryEstimate$inboundSchema: z.ZodMiniType<
  OrderServiceDeliveryEstimate,
  unknown
> = z.pipe(
  z.object({
    action_allowed: types.optional(types.boolean()),
    allowed_execution_on: types.optional(types.number()),
    next_billing_at: types.optional(types.number()),
    next_payment_date: types.optional(types.number()),
    subscription: types.optional(OrderSubscription$inboundSchema),
    paused_period: types.optional(OrderPausedPeriod$inboundSchema),
    billing_estimate: types.optional(
      z.lazy(() => OrderBillingEstimate$inboundSchema),
    ),
    components_change: types.optional(
      z.lazy(() => OrderComponentsChange$inboundSchema),
    ),
    failure_reason: types.optional(OrderFailureReason2$inboundSchema),
    services_to_add: types.optional(
      z.array(z.lazy(() => OrderServicesToAdd$inboundSchema)),
    ),
    services_to_remove: types.optional(
      z.array(z.lazy(() => OrderServicesToRemove$inboundSchema)),
    ),
    services_to_change: types.optional(
      z.array(z.lazy(() => OrderServicesToChange$inboundSchema)),
    ),
    services_to_update: types.optional(
      z.array(z.lazy(() => OrderServicesToUpdate$inboundSchema)),
    ),
    devices_added: types.optional(
      z.array(z.lazy(() => OrderDevicesAdded$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "action_allowed": "actionAllowed",
      "allowed_execution_on": "allowedExecutionOn",
      "next_billing_at": "nextBillingAt",
      "next_payment_date": "nextPaymentDate",
      "paused_period": "pausedPeriod",
      "billing_estimate": "billingEstimate",
      "components_change": "componentsChange",
      "failure_reason": "failureReason",
      "services_to_add": "servicesToAdd",
      "services_to_remove": "servicesToRemove",
      "services_to_change": "servicesToChange",
      "services_to_update": "servicesToUpdate",
      "devices_added": "devicesAdded",
    });
  }),
);

export function orderServiceDeliveryEstimateFromJSON(
  jsonString: string,
): SafeParseResult<OrderServiceDeliveryEstimate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderServiceDeliveryEstimate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderServiceDeliveryEstimate' from JSON`,
  );
}

/** @internal */
export const OrderStage$inboundSchema: z.ZodMiniType<OrderStage, unknown> = z
  .object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    colour: types.optional(types.string()),
    priority: types.optional(types.number()),
  });

export function orderStageFromJSON(
  jsonString: string,
): SafeParseResult<OrderStage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderStage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderStage' from JSON`,
  );
}

/** @internal */
export const OrderMilestonePlanEstimate$inboundSchema: z.ZodMiniType<
  OrderMilestonePlanEstimate,
  unknown
> = z.pipe(
  z.object({
    stage: types.optional(z.lazy(() => OrderStage$inboundSchema)),
    queue_percentage: types.optional(types.number()),
    percentage: types.optional(types.number()),
    amount: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "queue_percentage": "queuePercentage",
    });
  }),
);

export function orderMilestonePlanEstimateFromJSON(
  jsonString: string,
): SafeParseResult<OrderMilestonePlanEstimate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderMilestonePlanEstimate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderMilestonePlanEstimate' from JSON`,
  );
}

/** @internal */
export const OrderUnavailabilityReason$inboundSchema: z.ZodMiniType<
  OrderUnavailabilityReason,
  unknown
> = openEnums.inboundSchema(OrderUnavailabilityReason);

/** @internal */
export const OrderInvalidProductProduct$inboundSchema: z.ZodMiniType<
  OrderInvalidProductProduct,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
  sku: types.optional(types.string()),
});

export function orderInvalidProductProductFromJSON(
  jsonString: string,
): SafeParseResult<OrderInvalidProductProduct, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderInvalidProductProduct$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderInvalidProductProduct' from JSON`,
  );
}

/** @internal */
export const OrderInvalidProduct$inboundSchema: z.ZodMiniType<
  OrderInvalidProduct,
  unknown
> = z.pipe(
  z.object({
    unavailability_reason: types.optional(
      OrderUnavailabilityReason$inboundSchema,
    ),
    product: types.optional(
      z.lazy(() => OrderInvalidProductProduct$inboundSchema),
    ),
    in_stock: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "unavailability_reason": "unavailabilityReason",
      "in_stock": "inStock",
    });
  }),
);

export function orderInvalidProductFromJSON(
  jsonString: string,
): SafeParseResult<OrderInvalidProduct, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderInvalidProduct$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderInvalidProduct' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderOrder$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderOrder,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      order_estimate: types.optional(OrderOrderEstimate$inboundSchema),
      invoice_estimate: types.optional(OrderInvoiceEstimate$inboundSchema),
      service_delivery_estimate: types.optional(
        z.array(z.lazy(() => OrderServiceDeliveryEstimate$inboundSchema)),
      ),
      milestone_plan_estimate: types.optional(
        z.array(z.lazy(() => OrderMilestonePlanEstimate$inboundSchema)),
      ),
      invalid_products: types.optional(
        z.array(z.lazy(() => OrderInvalidProduct$inboundSchema)),
      ),
      subscription_estimation_amount: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "order_estimate": "orderEstimate",
        "invoice_estimate": "invoiceEstimate",
        "service_delivery_estimate": "serviceDeliveryEstimate",
        "milestone_plan_estimate": "milestonePlanEstimate",
        "invalid_products": "invalidProducts",
        "subscription_estimation_amount": "subscriptionEstimationAmount",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderOrderFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderOrder,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderOrder$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderOrder' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateOrderSelfServiceResourceEstimateOrderResponse$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateOrderSelfServiceResourceEstimateOrderResponse,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      order_estimate: types.optional(OrderEstimate$inboundSchema),
      invoice_estimate: types.optional(InvoiceEstimate$inboundSchema),
      service_delivery_estimate: types.optional(
        z.array(
          ComCrmEstimateOrderSelfServiceResourceEstimateOrderServiceDeliveryEstimate$inboundSchema,
        ),
      ),
      milestone_plan_estimate: types.optional(
        z.array(MilestonePlanEstimate$inboundSchema),
      ),
      invalid_products: types.optional(z.array(InvalidProduct$inboundSchema)),
      orders: types.optional(z.array(z.lazy(() =>
        ComCrmEstimateOrderSelfServiceResourceEstimateOrderOrder$inboundSchema
      ))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "order_estimate": "orderEstimate",
        "invoice_estimate": "invoiceEstimate",
        "service_delivery_estimate": "serviceDeliveryEstimate",
        "milestone_plan_estimate": "milestonePlanEstimate",
        "invalid_products": "invalidProducts",
      });
    }),
  );

export function comCrmEstimateOrderSelfServiceResourceEstimateOrderResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateOrderSelfServiceResourceEstimateOrderResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateOrderSelfServiceResourceEstimateOrderResponse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateOrderSelfServiceResourceEstimateOrderResponse' from JSON`,
  );
}
