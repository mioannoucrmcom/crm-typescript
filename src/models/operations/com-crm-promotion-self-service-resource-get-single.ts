/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

export type ComCrmPromotionSelfServiceResourceGetSingleRequest = {
  /**
   * The promotion identifier that will be retrieved
   */
  id: string;
};

/**
 * Promotion state
 */
export const ComCrmPromotionSelfServiceResourceGetSingleState = {
  Active: "ACTIVE",
  Inactive: "INACTIVE",
} as const;
/**
 * Promotion state
 */
export type ComCrmPromotionSelfServiceResourceGetSingleState = OpenEnum<
  typeof ComCrmPromotionSelfServiceResourceGetSingleState
>;

/**
 * Determines when the Promotion is available and will be applied. A Promotion is applied only when purchases are performed within this period.
 */
export type ComCrmPromotionSelfServiceResourceGetSingleAvailability = {
  /**
   * Contacts get the Promotion on orders performed from this date onward
   */
  fromDate?: number | undefined;
  /**
   * Promotion applied on orders up until this date
   */
  toDate?: number | undefined;
};

/**
 * The contact for which the Promotion is applied. Either a Contact or a Segment can be specified in a Promotion
 */
export type ComCrmPromotionSelfServiceResourceGetSingleContact = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
};

export type Segment = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The name of the Segment
   */
  name?: string | undefined;
  /**
   * The description of the Segment
   */
  description?: string | undefined;
  /**
   * The number of contacts retrieved from the Segment
   */
  size?: number | undefined;
};

/**
 * The type of the Organisation
 */
export const ComCrmPromotionSelfServiceResourceGetSingleTargetsType = {
  Operator: "OPERATOR",
  ServiceOwner: "SERVICE_OWNER",
  TransactionProcessor: "TRANSACTION_PROCESSOR",
  Business: "BUSINESS",
  Organisation: "ORGANISATION",
  Merchant: "MERCHANT",
  Venue: "VENUE",
} as const;
/**
 * The type of the Organisation
 */
export type ComCrmPromotionSelfServiceResourceGetSingleTargetsType = OpenEnum<
  typeof ComCrmPromotionSelfServiceResourceGetSingleTargetsType
>;

export type ComCrmPromotionSelfServiceResourceGetSingleOrganisation = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The name of the Organisation
   */
  name?: string | undefined;
  /**
   * The type of the Organisation
   */
  type?: ComCrmPromotionSelfServiceResourceGetSingleTargetsType | undefined;
};

/**
 * Promotion is applied if the purchase is performed within the specified period of time. Either a fixed period or promotion availability must be specified
 */
export type FixedPeriod = {
  /**
   * Promotion applied if purchase is performed from this date (inclusive) and onwards
   */
  startDate: number;
  /**
   * If specified, then the purchase must be performed up until this date (Optional)
   */
  endDate?: number | null | undefined;
};

export type TimingsAvailability = {
  /**
   * Day of week. Allowed values are 1 to 7, where 1 is Sunday
   */
  day?: number | undefined;
  /**
   * Month during which promotion is applied. Allowed values are 1-12, where 1 is January
   */
  month?: number | undefined;
  /**
   * Starting time
   */
  startTime?: string | undefined;
  /**
   * End time
   */
  endTime?: string | undefined;
};

/**
 * Promotion timings
 */
export type Timings = {
  /**
   * Promotion is applied if the purchase is performed within the specified period of time. Either a fixed period or promotion availability must be specified
   */
  fixedPeriod: FixedPeriod | null;
  /**
   * Promotion is applied if the purchase is performed within the specified day(s), month(s) and/or times. Either a fixed period or promotion availability must be specified. Each availibility option should be unique
   */
  availability: Array<TimingsAvailability> | null;
};

/**
 * The Promotion’s target conditions i.e. the required conditions for the contact to get the discount.
 */
export type ComCrmPromotionSelfServiceResourceGetSingleTargets = {
  /**
   * The contact for which the Promotion is applied. Either a Contact or a Segment can be specified in a Promotion
   */
  contact?: ComCrmPromotionSelfServiceResourceGetSingleContact | undefined;
  /**
   * Either Segments or a specific Contact can be specified per Promotion
   */
  segments?: Array<Segment> | undefined;
  /**
   * Promotion Location Conditions
   */
  organisations?:
    | Array<ComCrmPromotionSelfServiceResourceGetSingleOrganisation>
    | undefined;
  /**
   * Promotion timings
   */
  timings?: Timings | undefined;
};

/**
 * Logical operator used amount the product conditions
 */
export const Operator = {
  And: "AND",
  Or: "OR",
} as const;
/**
 * Logical operator used amount the product conditions
 */
export type Operator = OpenEnum<typeof Operator>;

export const ConditionOperator = {
  And: "AND",
  Or: "OR",
} as const;
export type ConditionOperator = OpenEnum<typeof ConditionOperator>;

/**
 * The type of the product condition
 */
export const ConditionItemType = {
  Sku: "SKU",
  Type: "TYPE",
  Family: "FAMILY",
  Brand: "BRAND",
} as const;
/**
 * The type of the product condition
 */
export type ConditionItemType = OpenEnum<typeof ConditionItemType>;

/**
 * The product that should be included in the basket
 */
export type ConditionProduct = {
  /**
   * The type of the product condition
   */
  itemType: ConditionItemType;
  /**
   * The identifier of the product/type/brand/family.
   */
  itemId: string;
  /**
   * The product’s SKU. Applicable only when item type is set to Product
   */
  sku?: string | undefined;
  /**
   * The name of the product/type/brand/family
   */
  name?: string | undefined;
};

/**
 * Billing cycle unit of time
 */
export const BillingCycleUot = {
  Second: "SECOND",
  Minute: "MINUTE",
  Hour: "HOUR",
  Day: "DAY",
  Week: "WEEK",
  Month: "MONTH",
  Year: "YEAR",
  Overall: "OVERALL",
} as const;
/**
 * Billing cycle unit of time
 */
export type BillingCycleUot = OpenEnum<typeof BillingCycleUot>;

/**
 * The billing cycle of the basket item. Applicable only for termed services. The billing cycle is the one specified in the service’s price terms selected on ordering
 */
export type BillingCycle = {
  /**
   * Billing cycle duration
   */
  duration: number;
  /**
   * Billing cycle unit of time
   */
  uot: BillingCycleUot;
};

/**
 * Contract period unit of time
 */
export const ConditionContractPeriodUot = {
  Second: "SECOND",
  Minute: "MINUTE",
  Hour: "HOUR",
  Day: "DAY",
  Week: "WEEK",
  Month: "MONTH",
  Year: "YEAR",
  Overall: "OVERALL",
} as const;
/**
 * Contract period unit of time
 */
export type ConditionContractPeriodUot = OpenEnum<
  typeof ConditionContractPeriodUot
>;

/**
 * The contract period of the basket item. Applicable only for termed services. The contract period is the one specified in the service’s price terms selected on ordering
 */
export type ComCrmPromotionSelfServiceResourceGetSingleContractPeriod = {
  /**
   * Contract period duration
   */
  duration?: number | undefined;
  /**
   * Contract period unit of time
   */
  uot?: ConditionContractPeriodUot | undefined;
};

export type ComCrmPromotionSelfServiceResourceGetSingleService = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * Product SKU
   */
  sku?: string | undefined;
  /**
   * Product name
   */
  name?: string | undefined;
  /**
   * Minimum reuqired subscription services quantity to get the promotion
   */
  quantity?: number | undefined;
};

export type Condition = {
  /**
   * The condition name
   */
  condition?: string | undefined;
  operator?: ConditionOperator | undefined;
  /**
   * The product that should be included in the basket
   */
  product?: ConditionProduct | undefined;
  /**
   * The minimum required quantity of items to be included in the basket for the promotion to be applied
   */
  quantity?: number | undefined;
  /**
   * The minimum required basket items cost. Cost is defined in the business’s base currency
   */
  value?: number | undefined;
  /**
   * The billing cycle of the basket item. Applicable only for termed services. The billing cycle is the one specified in the service’s price terms selected on ordering
   */
  billingCycle?: BillingCycle | undefined;
  /**
   * The contract period of the basket item. Applicable only for termed services. The contract period is the one specified in the service’s price terms selected on ordering
   */
  contractPeriod?:
    | ComCrmPromotionSelfServiceResourceGetSingleContractPeriod
    | undefined;
  /**
   * List of services to which a contact must already be subscribed to in order to get the promotion. Only termed services can be specified. Available and applicable only when the basket item is a termed service or a product type of Termed service classification.
   */
  services?:
    | Array<ComCrmPromotionSelfServiceResourceGetSingleService>
    | undefined;
};

export type Group = {
  /**
   * The group’s name. Each group name must be unique
   */
  group?: string | undefined;
  /**
   * Logical operator used amount the product conditions
   */
  operator?: Operator | undefined;
  /**
   * List of product conditions. Mulitple conditions can be added, each one referring to a single product. All product conditions must be met to apply the promotion
   */
  conditions?: Array<Condition> | undefined;
};

/**
 * Products that should be included in the basket for the Promotion to be applied. Product conditions are defined as groups of conditions. In Each group there’s a product setting and the conditions that should be met. Multiple groups can be added, logically separated by AND/OR operators.
 */
export type Products = {
  /**
   * Groups of product conditions.
   */
  groups?: Array<Group> | undefined;
};

export const ComCrmPromotionSelfServiceResourceGetSinglePaymentMethodType = {
  Cash: "CASH",
  Card: "CARD",
  Account: "ACCOUNT",
  AccountDebit: "ACCOUNT_DEBIT",
  A2A: "A2A",
  Phone: "PHONE",
  Token: "TOKEN",
  Wallet: "WALLET",
  Cheque: "CHEQUE",
  ElectronicTransfer: "ELECTRONIC_TRANSFER",
  CrmWallet: "CRM_WALLET",
  OneTimeCardPayment: "ONE_TIME_CARD_PAYMENT",
} as const;
export type ComCrmPromotionSelfServiceResourceGetSinglePaymentMethodType =
  OpenEnum<typeof ComCrmPromotionSelfServiceResourceGetSinglePaymentMethodType>;

/**
 * The type of the event:
 *
 * @remarks
 *  * `DELIVERY` - Delivered to the customer’s address
 *  * `PICK_UP` - Picked up by the customer from a venue
 *  * `DIRECT_SALE` - Online sales of services
 */
export const ComCrmPromotionSelfServiceResourceGetSingleSupplyMethod = {
  Delivery: "DELIVERY",
  PickUp: "PICK_UP",
  DirectSale: "DIRECT_SALE",
} as const;
/**
 * The type of the event:
 *
 * @remarks
 *  * `DELIVERY` - Delivered to the customer’s address
 *  * `PICK_UP` - Picked up by the customer from a venue
 *  * `DIRECT_SALE` - Online sales of services
 */
export type ComCrmPromotionSelfServiceResourceGetSingleSupplyMethod = OpenEnum<
  typeof ComCrmPromotionSelfServiceResourceGetSingleSupplyMethod
>;

export type Rule = {
  /**
   * Contact should pay using one of the specified payment method types to get the offering
   */
  paymentMethodTypes?:
    | Array<ComCrmPromotionSelfServiceResourceGetSinglePaymentMethodType>
    | undefined;
  /**
   * Purchase is fulfilled using one of the specified supply methods for the contact to get the offering
   */
  supplyMethods?:
    | Array<ComCrmPromotionSelfServiceResourceGetSingleSupplyMethod>
    | undefined;
  /**
   * Minimum required basket total amount for the promotion to be applied. The amount is always set in the business’s base currency
   */
  value?: number | undefined;
  /**
   * Miminum required quantity of basket items
   */
  quantity?: number | undefined;
};

export type Basket = {
  /**
   * Products that should be included in the basket for the Promotion to be applied. Product conditions are defined as groups of conditions. In Each group there’s a product setting and the conditions that should be met. Multiple groups can be added, logically separated by AND/OR operators.
   */
  products?: Products | undefined;
  /**
   * Rules that -if specified- should be met in order for the Promotion to be applied.
   */
  rules?: Array<Rule> | undefined;
};

/**
 * Information about the creative type
 */
export const ComCrmPromotionSelfServiceResourceGetSingleUsageType = {
  Logo: "LOGO",
  Background: "BACKGROUND",
  Avatar: "AVATAR",
  Hero: "HERO",
  Marketing: "MARKETING",
  Attachment: "ATTACHMENT",
  Profileimage: "PROFILEIMAGE",
  AppleLockscreenIcon: "APPLE_LOCKSCREEN_ICON",
  AppleLogoImage: "APPLE_LOGO_IMAGE",
  AppleStripImage: "APPLE_STRIP_IMAGE",
  GoogleLogoImage: "GOOGLE_LOGO_IMAGE",
  GoogleStripImage: "GOOGLE_STRIP_IMAGE",
  LandingPageLogoImage: "LANDING_PAGE_LOGO_IMAGE",
  LandingPageHeaderImage: "LANDING_PAGE_HEADER_IMAGE",
  LandingPageBackgroundImage: "LANDING_PAGE_BACKGROUND_IMAGE",
  DeliveryImage: "DELIVERY_IMAGE",
  PickupImage: "PICKUP_IMAGE",
  DirectSaleImage: "DIRECT_SALE_IMAGE",
  WalletImage: "WALLET_IMAGE",
  LandingPageImage: "LANDING_PAGE_IMAGE",
  AppLogo: "APP_LOGO",
  PartnerLogo: "PARTNER_LOGO",
  Carousel: "CAROUSEL",
  Shortcut: "SHORTCUT",
  ShortcutImage: "SHORTCUT_IMAGE",
  EmbeddedLinkImage: "EMBEDDED_LINK_IMAGE",
  Image: "IMAGE",
  AppLoaderImage: "APP_LOADER_IMAGE",
  MobileBackgroundImage: "MOBILE_BACKGROUND_IMAGE",
} as const;
/**
 * Information about the creative type
 */
export type ComCrmPromotionSelfServiceResourceGetSingleUsageType = OpenEnum<
  typeof ComCrmPromotionSelfServiceResourceGetSingleUsageType
>;

export type ComCrmPromotionSelfServiceResourceGetSingleMedia = {
  /**
   * The transformed creative width
   */
  width?: number | undefined;
  /**
   * The transformed creative height
   */
  height?: number | undefined;
  /**
   * The transformed creative URL
   */
  url?: string | undefined;
};

export type ComCrmPromotionSelfServiceResourceGetSingleCreative = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * the identifier of media
   */
  mediaGroupId?: string | undefined;
  /**
   * Information about the creative type
   */
  usageType?: ComCrmPromotionSelfServiceResourceGetSingleUsageType | undefined;
  /**
   * The creative width
   */
  width?: number | undefined;
  /**
   * The creative height
   */
  height?: number | undefined;
  /**
   * The creative format
   */
  format?: string | undefined;
  /**
   * The creative content URL
   */
  url?: string | undefined;
  /**
   * The creative public identifier
   */
  publicId?: string | undefined;
  /**
   * The media identifier
   */
  mediaId?: string | undefined;
  /**
   * The creative caption used in cases where usage_type=CAROUSEL
   */
  caption?: string | undefined;
  /**
   * The creative sort order used in cases where usage_type=CAROUSEL
   */
  sortOrder?: number | undefined;
  /**
   * Information about the creative transformations
   */
  media?: Array<ComCrmPromotionSelfServiceResourceGetSingleMedia> | undefined;
};

/**
 * Determines on which product the discount will be applied.
 */
export const OfferingItemType = {
  Sku: "SKU",
  Type: "TYPE",
  Family: "FAMILY",
  Brand: "BRAND",
} as const;
/**
 * Determines on which product the discount will be applied.
 */
export type OfferingItemType = OpenEnum<typeof OfferingItemType>;

/**
 * The product on which the discount will be applied
 */
export type OfferingProduct = {
  /**
   * The unique identifier of the product item
   */
  itemId?: string | undefined;
  /**
   * Determines on which product the discount will be applied.
   */
  itemType?: OfferingItemType | undefined;
  /**
   * The product/type/brand/family name
   */
  name?: string | undefined;
  /**
   * The product’s SKU. Applicable only for SKU item types
   */
  sku?: string | undefined;
};

/**
 * Defines whether the offering is an actual discount amount or a discount percentage
 */
export const OfferingType = {
  Amount: "AMOUNT",
  Percent: "PERCENT",
} as const;
/**
 * Defines whether the offering is an actual discount amount or a discount percentage
 */
export type OfferingType = OpenEnum<typeof OfferingType>;

/**
 * Indicates whether the offering will be applied once, for a period of time or forever.
 */
export const DurationType = {
  OneTime: "ONE_TIME",
  Forever: "FOREVER",
  Period: "PERIOD",
  VariableDiscounts: "VARIABLE_DISCOUNTS",
} as const;
/**
 * Indicates whether the offering will be applied once, for a period of time or forever.
 */
export type DurationType = OpenEnum<typeof DurationType>;

/**
 * The period’s unit of time
 */
export const PeriodUot = {
  Second: "SECOND",
  Minute: "MINUTE",
  Hour: "HOUR",
  Day: "DAY",
  Week: "WEEK",
  Month: "MONTH",
  Year: "YEAR",
  Overall: "OVERALL",
} as const;
/**
 * The period’s unit of time
 */
export type PeriodUot = OpenEnum<typeof PeriodUot>;

/**
 * Applicable and required only when the offering will be applied for a specific PERIOD
 */
export type ComCrmPromotionSelfServiceResourceGetSinglePeriod = {
  /**
   * The period’s duration
   */
  duration: number;
  /**
   * The period’s unit of time
   */
  uot: PeriodUot;
};

/**
 * Defines whether the offering is an actual discount amount or a discount percentage
 */
export const VariableDiscountType = {
  Amount: "AMOUNT",
  Percent: "PERCENT",
} as const;
/**
 * Defines whether the offering is an actual discount amount or a discount percentage
 */
export type VariableDiscountType = OpenEnum<typeof VariableDiscountType>;

/**
 * The period’s unit of time
 */
export const VariableDiscountUot = {
  Second: "SECOND",
  Minute: "MINUTE",
  Hour: "HOUR",
  Day: "DAY",
  Week: "WEEK",
  Month: "MONTH",
  Year: "YEAR",
  Overall: "OVERALL",
} as const;
/**
 * The period’s unit of time
 */
export type VariableDiscountUot = OpenEnum<typeof VariableDiscountUot>;

/**
 * Applicable and required only when the offering will be applied for a specific PERIOD
 */
export type VariableDiscountPeriod = {
  /**
   * The period’s duration
   */
  duration: number;
  /**
   * The period’s unit of time
   */
  uot: VariableDiscountUot;
};

export type VariableDiscount = {
  /**
   * Defines whether the offering is an actual discount amount or a discount percentage
   */
  type: VariableDiscountType;
  /**
   * The discount amount or percentage depending on the offerring’s type
   */
  amount: number;
  /**
   * Applicable and required only when the offering will be applied for a specific PERIOD
   */
  period: VariableDiscountPeriod;
  /**
   * Defines the discount order
   */
  periodOrder: number;
};

/**
 * How long the offering will be applied. Applicable only when the offerring’s product is a termed service
 */
export type Duration = {
  /**
   * Indicates whether the offering will be applied once, for a period of time or forever.
   */
  type: DurationType;
  /**
   * Applicable and required only when the offering will be applied for a specific PERIOD
   */
  period: ComCrmPromotionSelfServiceResourceGetSinglePeriod | null;
  /**
   * Applicable only if the offering’s duration is set to VARIABLE_DISCOUNTS. At least one must be specified
   */
  variableDiscounts?: Array<VariableDiscount> | null | undefined;
};

export type Offering = {
  /**
   * The product on which the discount will be applied
   */
  product?: OfferingProduct | undefined;
  /**
   * Defines whether the offering is an actual discount amount or a discount percentage
   */
  type?: OfferingType | undefined;
  /**
   * The discount amount or percentage depending on the offerring’s type
   */
  amount?: number | undefined;
  /**
   * How long the offering will be applied. Applicable only when the offerring’s product is a termed service
   */
  duration?: Duration | undefined;
};

/**
 * OK
 */
export type ComCrmPromotionSelfServiceResourceGetSingleResponse = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * Promotion name
   */
  name?: string | undefined;
  /**
   * Promotion state
   */
  state?: ComCrmPromotionSelfServiceResourceGetSingleState | undefined;
  /**
   * Short description of the Promotion
   */
  shortDescription?: string | undefined;
  /**
   * A more detailed description of the Promotion
   */
  longDescription?: string | undefined;
  /**
   * Determines when the Promotion is available and will be applied. A Promotion is applied only when purchases are performed within this period.
   */
  availability?:
    | ComCrmPromotionSelfServiceResourceGetSingleAvailability
    | undefined;
  /**
   * The Promotion’s target conditions i.e. the required conditions for the contact to get the discount.
   */
  targets?: ComCrmPromotionSelfServiceResourceGetSingleTargets | undefined;
  basket?: Basket | undefined;
  /**
   * A creative is an object that contains all the data required for visually rendering an image responsively. The object contains the initial image and a number of scale versions of it (srcset)
   */
  creatives?:
    | Array<ComCrmPromotionSelfServiceResourceGetSingleCreative>
    | undefined;
  offerings?: Array<Offering> | undefined;
};

/** @internal */
export type ComCrmPromotionSelfServiceResourceGetSingleRequest$Outbound = {
  id: string;
};

/** @internal */
export const ComCrmPromotionSelfServiceResourceGetSingleRequest$outboundSchema:
  z.ZodMiniType<
    ComCrmPromotionSelfServiceResourceGetSingleRequest$Outbound,
    ComCrmPromotionSelfServiceResourceGetSingleRequest
  > = z.object({
    id: z.string(),
  });

export function comCrmPromotionSelfServiceResourceGetSingleRequestToJSON(
  comCrmPromotionSelfServiceResourceGetSingleRequest:
    ComCrmPromotionSelfServiceResourceGetSingleRequest,
): string {
  return JSON.stringify(
    ComCrmPromotionSelfServiceResourceGetSingleRequest$outboundSchema.parse(
      comCrmPromotionSelfServiceResourceGetSingleRequest,
    ),
  );
}

/** @internal */
export const ComCrmPromotionSelfServiceResourceGetSingleState$inboundSchema:
  z.ZodMiniType<ComCrmPromotionSelfServiceResourceGetSingleState, unknown> =
    openEnums.inboundSchema(ComCrmPromotionSelfServiceResourceGetSingleState);

/** @internal */
export const ComCrmPromotionSelfServiceResourceGetSingleAvailability$inboundSchema:
  z.ZodMiniType<
    ComCrmPromotionSelfServiceResourceGetSingleAvailability,
    unknown
  > = z.pipe(
    z.object({
      from_date: types.optional(types.number()),
      to_date: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "from_date": "fromDate",
        "to_date": "toDate",
      });
    }),
  );

export function comCrmPromotionSelfServiceResourceGetSingleAvailabilityFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmPromotionSelfServiceResourceGetSingleAvailability,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmPromotionSelfServiceResourceGetSingleAvailability$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmPromotionSelfServiceResourceGetSingleAvailability' from JSON`,
  );
}

/** @internal */
export const ComCrmPromotionSelfServiceResourceGetSingleContact$inboundSchema:
  z.ZodMiniType<ComCrmPromotionSelfServiceResourceGetSingleContact, unknown> = z
    .object({
      id: types.optional(types.string()),
      name: types.optional(types.string()),
    });

export function comCrmPromotionSelfServiceResourceGetSingleContactFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmPromotionSelfServiceResourceGetSingleContact,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmPromotionSelfServiceResourceGetSingleContact$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmPromotionSelfServiceResourceGetSingleContact' from JSON`,
  );
}

/** @internal */
export const Segment$inboundSchema: z.ZodMiniType<Segment, unknown> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
  description: types.optional(types.string()),
  size: types.optional(types.number()),
});

export function segmentFromJSON(
  jsonString: string,
): SafeParseResult<Segment, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Segment$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Segment' from JSON`,
  );
}

/** @internal */
export const ComCrmPromotionSelfServiceResourceGetSingleTargetsType$inboundSchema:
  z.ZodMiniType<
    ComCrmPromotionSelfServiceResourceGetSingleTargetsType,
    unknown
  > = openEnums.inboundSchema(
    ComCrmPromotionSelfServiceResourceGetSingleTargetsType,
  );

/** @internal */
export const ComCrmPromotionSelfServiceResourceGetSingleOrganisation$inboundSchema:
  z.ZodMiniType<
    ComCrmPromotionSelfServiceResourceGetSingleOrganisation,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    type: types.optional(
      ComCrmPromotionSelfServiceResourceGetSingleTargetsType$inboundSchema,
    ),
  });

export function comCrmPromotionSelfServiceResourceGetSingleOrganisationFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmPromotionSelfServiceResourceGetSingleOrganisation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmPromotionSelfServiceResourceGetSingleOrganisation$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmPromotionSelfServiceResourceGetSingleOrganisation' from JSON`,
  );
}

/** @internal */
export const FixedPeriod$inboundSchema: z.ZodMiniType<FixedPeriod, unknown> = z
  .pipe(
    z.object({
      start_date: types.number(),
      end_date: z.optional(z.nullable(types.number())),
    }),
    z.transform((v) => {
      return remap$(v, {
        "start_date": "startDate",
        "end_date": "endDate",
      });
    }),
  );

export function fixedPeriodFromJSON(
  jsonString: string,
): SafeParseResult<FixedPeriod, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FixedPeriod$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FixedPeriod' from JSON`,
  );
}

/** @internal */
export const TimingsAvailability$inboundSchema: z.ZodMiniType<
  TimingsAvailability,
  unknown
> = z.pipe(
  z.object({
    day: types.optional(types.number()),
    month: types.optional(types.number()),
    start_time: types.optional(types.string()),
    end_time: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "start_time": "startTime",
      "end_time": "endTime",
    });
  }),
);

export function timingsAvailabilityFromJSON(
  jsonString: string,
): SafeParseResult<TimingsAvailability, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TimingsAvailability$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TimingsAvailability' from JSON`,
  );
}

/** @internal */
export const Timings$inboundSchema: z.ZodMiniType<Timings, unknown> = z.pipe(
  z.object({
    fixed_period: types.nullable(z.lazy(() => FixedPeriod$inboundSchema)),
    availability: types.nullable(z.array(z.lazy(() =>
      TimingsAvailability$inboundSchema
    ))),
  }),
  z.transform((v) => {
    return remap$(v, {
      "fixed_period": "fixedPeriod",
    });
  }),
);

export function timingsFromJSON(
  jsonString: string,
): SafeParseResult<Timings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Timings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Timings' from JSON`,
  );
}

/** @internal */
export const ComCrmPromotionSelfServiceResourceGetSingleTargets$inboundSchema:
  z.ZodMiniType<ComCrmPromotionSelfServiceResourceGetSingleTargets, unknown> = z
    .object({
      contact: types.optional(
        z.lazy(() =>
          ComCrmPromotionSelfServiceResourceGetSingleContact$inboundSchema
        ),
      ),
      segments: types.optional(z.array(z.lazy(() => Segment$inboundSchema))),
      organisations: types.optional(
        z.array(z.lazy(() =>
          ComCrmPromotionSelfServiceResourceGetSingleOrganisation$inboundSchema
        )),
      ),
      timings: types.optional(z.lazy(() => Timings$inboundSchema)),
    });

export function comCrmPromotionSelfServiceResourceGetSingleTargetsFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmPromotionSelfServiceResourceGetSingleTargets,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmPromotionSelfServiceResourceGetSingleTargets$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmPromotionSelfServiceResourceGetSingleTargets' from JSON`,
  );
}

/** @internal */
export const Operator$inboundSchema: z.ZodMiniType<Operator, unknown> =
  openEnums.inboundSchema(Operator);

/** @internal */
export const ConditionOperator$inboundSchema: z.ZodMiniType<
  ConditionOperator,
  unknown
> = openEnums.inboundSchema(ConditionOperator);

/** @internal */
export const ConditionItemType$inboundSchema: z.ZodMiniType<
  ConditionItemType,
  unknown
> = openEnums.inboundSchema(ConditionItemType);

/** @internal */
export const ConditionProduct$inboundSchema: z.ZodMiniType<
  ConditionProduct,
  unknown
> = z.pipe(
  z.object({
    item_type: ConditionItemType$inboundSchema,
    item_id: types.string(),
    sku: types.optional(types.string()),
    name: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "item_type": "itemType",
      "item_id": "itemId",
    });
  }),
);

export function conditionProductFromJSON(
  jsonString: string,
): SafeParseResult<ConditionProduct, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ConditionProduct$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ConditionProduct' from JSON`,
  );
}

/** @internal */
export const BillingCycleUot$inboundSchema: z.ZodMiniType<
  BillingCycleUot,
  unknown
> = openEnums.inboundSchema(BillingCycleUot);

/** @internal */
export const BillingCycle$inboundSchema: z.ZodMiniType<BillingCycle, unknown> =
  z.object({
    duration: types.number(),
    uot: BillingCycleUot$inboundSchema,
  });

export function billingCycleFromJSON(
  jsonString: string,
): SafeParseResult<BillingCycle, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BillingCycle$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BillingCycle' from JSON`,
  );
}

/** @internal */
export const ConditionContractPeriodUot$inboundSchema: z.ZodMiniType<
  ConditionContractPeriodUot,
  unknown
> = openEnums.inboundSchema(ConditionContractPeriodUot);

/** @internal */
export const ComCrmPromotionSelfServiceResourceGetSingleContractPeriod$inboundSchema:
  z.ZodMiniType<
    ComCrmPromotionSelfServiceResourceGetSingleContractPeriod,
    unknown
  > = z.object({
    duration: types.optional(types.number()),
    uot: types.optional(ConditionContractPeriodUot$inboundSchema),
  });

export function comCrmPromotionSelfServiceResourceGetSingleContractPeriodFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmPromotionSelfServiceResourceGetSingleContractPeriod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmPromotionSelfServiceResourceGetSingleContractPeriod$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmPromotionSelfServiceResourceGetSingleContractPeriod' from JSON`,
  );
}

/** @internal */
export const ComCrmPromotionSelfServiceResourceGetSingleService$inboundSchema:
  z.ZodMiniType<ComCrmPromotionSelfServiceResourceGetSingleService, unknown> = z
    .object({
      id: types.optional(types.string()),
      sku: types.optional(types.string()),
      name: types.optional(types.string()),
      quantity: types.optional(types.number()),
    });

export function comCrmPromotionSelfServiceResourceGetSingleServiceFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmPromotionSelfServiceResourceGetSingleService,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmPromotionSelfServiceResourceGetSingleService$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmPromotionSelfServiceResourceGetSingleService' from JSON`,
  );
}

/** @internal */
export const Condition$inboundSchema: z.ZodMiniType<Condition, unknown> = z
  .pipe(
    z.object({
      condition: types.optional(types.string()),
      operator: types.optional(ConditionOperator$inboundSchema),
      product: types.optional(z.lazy(() => ConditionProduct$inboundSchema)),
      quantity: types.optional(types.number()),
      value: types.optional(types.number()),
      billing_cycle: types.optional(z.lazy(() => BillingCycle$inboundSchema)),
      contract_period: types.optional(z.lazy(() =>
        ComCrmPromotionSelfServiceResourceGetSingleContractPeriod$inboundSchema
      )),
      services: types.optional(z.array(z.lazy(() =>
        ComCrmPromotionSelfServiceResourceGetSingleService$inboundSchema
      ))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "billing_cycle": "billingCycle",
        "contract_period": "contractPeriod",
      });
    }),
  );

export function conditionFromJSON(
  jsonString: string,
): SafeParseResult<Condition, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Condition$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Condition' from JSON`,
  );
}

/** @internal */
export const Group$inboundSchema: z.ZodMiniType<Group, unknown> = z.object({
  group: types.optional(types.string()),
  operator: types.optional(Operator$inboundSchema),
  conditions: types.optional(z.array(z.lazy(() => Condition$inboundSchema))),
});

export function groupFromJSON(
  jsonString: string,
): SafeParseResult<Group, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Group$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Group' from JSON`,
  );
}

/** @internal */
export const Products$inboundSchema: z.ZodMiniType<Products, unknown> = z
  .object({
    groups: types.optional(z.array(z.lazy(() => Group$inboundSchema))),
  });

export function productsFromJSON(
  jsonString: string,
): SafeParseResult<Products, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Products$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Products' from JSON`,
  );
}

/** @internal */
export const ComCrmPromotionSelfServiceResourceGetSinglePaymentMethodType$inboundSchema:
  z.ZodMiniType<
    ComCrmPromotionSelfServiceResourceGetSinglePaymentMethodType,
    unknown
  > = openEnums.inboundSchema(
    ComCrmPromotionSelfServiceResourceGetSinglePaymentMethodType,
  );

/** @internal */
export const ComCrmPromotionSelfServiceResourceGetSingleSupplyMethod$inboundSchema:
  z.ZodMiniType<
    ComCrmPromotionSelfServiceResourceGetSingleSupplyMethod,
    unknown
  > = openEnums.inboundSchema(
    ComCrmPromotionSelfServiceResourceGetSingleSupplyMethod,
  );

/** @internal */
export const Rule$inboundSchema: z.ZodMiniType<Rule, unknown> = z.pipe(
  z.object({
    payment_method_types: types.optional(
      z.array(
        ComCrmPromotionSelfServiceResourceGetSinglePaymentMethodType$inboundSchema,
      ),
    ),
    supply_methods: types.optional(
      z.array(
        ComCrmPromotionSelfServiceResourceGetSingleSupplyMethod$inboundSchema,
      ),
    ),
    value: types.optional(types.number()),
    quantity: types.optional(types.number()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "payment_method_types": "paymentMethodTypes",
      "supply_methods": "supplyMethods",
    });
  }),
);

export function ruleFromJSON(
  jsonString: string,
): SafeParseResult<Rule, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Rule$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Rule' from JSON`,
  );
}

/** @internal */
export const Basket$inboundSchema: z.ZodMiniType<Basket, unknown> = z.object({
  products: types.optional(z.lazy(() => Products$inboundSchema)),
  rules: types.optional(z.array(z.lazy(() => Rule$inboundSchema))),
});

export function basketFromJSON(
  jsonString: string,
): SafeParseResult<Basket, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Basket$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Basket' from JSON`,
  );
}

/** @internal */
export const ComCrmPromotionSelfServiceResourceGetSingleUsageType$inboundSchema:
  z.ZodMiniType<ComCrmPromotionSelfServiceResourceGetSingleUsageType, unknown> =
    openEnums.inboundSchema(
      ComCrmPromotionSelfServiceResourceGetSingleUsageType,
    );

/** @internal */
export const ComCrmPromotionSelfServiceResourceGetSingleMedia$inboundSchema:
  z.ZodMiniType<ComCrmPromotionSelfServiceResourceGetSingleMedia, unknown> = z
    .object({
      width: types.optional(types.number()),
      height: types.optional(types.number()),
      url: types.optional(types.string()),
    });

export function comCrmPromotionSelfServiceResourceGetSingleMediaFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmPromotionSelfServiceResourceGetSingleMedia,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmPromotionSelfServiceResourceGetSingleMedia$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmPromotionSelfServiceResourceGetSingleMedia' from JSON`,
  );
}

/** @internal */
export const ComCrmPromotionSelfServiceResourceGetSingleCreative$inboundSchema:
  z.ZodMiniType<ComCrmPromotionSelfServiceResourceGetSingleCreative, unknown> =
    z.pipe(
      z.object({
        id: types.optional(types.string()),
        media_group_id: types.optional(types.string()),
        usage_type: types.optional(
          ComCrmPromotionSelfServiceResourceGetSingleUsageType$inboundSchema,
        ),
        width: types.optional(types.number()),
        height: types.optional(types.number()),
        format: types.optional(types.string()),
        url: types.optional(types.string()),
        public_id: types.optional(types.string()),
        media_id: types.optional(types.string()),
        caption: types.optional(types.string()),
        sort_order: types.optional(types.number()),
        media: types.optional(z.array(z.lazy(() =>
          ComCrmPromotionSelfServiceResourceGetSingleMedia$inboundSchema
        ))),
      }),
      z.transform((v) => {
        return remap$(v, {
          "media_group_id": "mediaGroupId",
          "usage_type": "usageType",
          "public_id": "publicId",
          "media_id": "mediaId",
          "sort_order": "sortOrder",
        });
      }),
    );

export function comCrmPromotionSelfServiceResourceGetSingleCreativeFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmPromotionSelfServiceResourceGetSingleCreative,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmPromotionSelfServiceResourceGetSingleCreative$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmPromotionSelfServiceResourceGetSingleCreative' from JSON`,
  );
}

/** @internal */
export const OfferingItemType$inboundSchema: z.ZodMiniType<
  OfferingItemType,
  unknown
> = openEnums.inboundSchema(OfferingItemType);

/** @internal */
export const OfferingProduct$inboundSchema: z.ZodMiniType<
  OfferingProduct,
  unknown
> = z.pipe(
  z.object({
    item_id: types.optional(types.string()),
    item_type: types.optional(OfferingItemType$inboundSchema),
    name: types.optional(types.string()),
    sku: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "item_id": "itemId",
      "item_type": "itemType",
    });
  }),
);

export function offeringProductFromJSON(
  jsonString: string,
): SafeParseResult<OfferingProduct, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OfferingProduct$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OfferingProduct' from JSON`,
  );
}

/** @internal */
export const OfferingType$inboundSchema: z.ZodMiniType<OfferingType, unknown> =
  openEnums.inboundSchema(OfferingType);

/** @internal */
export const DurationType$inboundSchema: z.ZodMiniType<DurationType, unknown> =
  openEnums.inboundSchema(DurationType);

/** @internal */
export const PeriodUot$inboundSchema: z.ZodMiniType<PeriodUot, unknown> =
  openEnums.inboundSchema(PeriodUot);

/** @internal */
export const ComCrmPromotionSelfServiceResourceGetSinglePeriod$inboundSchema:
  z.ZodMiniType<ComCrmPromotionSelfServiceResourceGetSinglePeriod, unknown> = z
    .object({
      duration: types.number(),
      uot: PeriodUot$inboundSchema,
    });

export function comCrmPromotionSelfServiceResourceGetSinglePeriodFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmPromotionSelfServiceResourceGetSinglePeriod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmPromotionSelfServiceResourceGetSinglePeriod$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmPromotionSelfServiceResourceGetSinglePeriod' from JSON`,
  );
}

/** @internal */
export const VariableDiscountType$inboundSchema: z.ZodMiniType<
  VariableDiscountType,
  unknown
> = openEnums.inboundSchema(VariableDiscountType);

/** @internal */
export const VariableDiscountUot$inboundSchema: z.ZodMiniType<
  VariableDiscountUot,
  unknown
> = openEnums.inboundSchema(VariableDiscountUot);

/** @internal */
export const VariableDiscountPeriod$inboundSchema: z.ZodMiniType<
  VariableDiscountPeriod,
  unknown
> = z.object({
  duration: types.number(),
  uot: VariableDiscountUot$inboundSchema,
});

export function variableDiscountPeriodFromJSON(
  jsonString: string,
): SafeParseResult<VariableDiscountPeriod, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => VariableDiscountPeriod$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'VariableDiscountPeriod' from JSON`,
  );
}

/** @internal */
export const VariableDiscount$inboundSchema: z.ZodMiniType<
  VariableDiscount,
  unknown
> = z.pipe(
  z.object({
    type: VariableDiscountType$inboundSchema,
    amount: types.number(),
    period: z.lazy(() => VariableDiscountPeriod$inboundSchema),
    period_order: types.number(),
  }),
  z.transform((v) => {
    return remap$(v, {
      "period_order": "periodOrder",
    });
  }),
);

export function variableDiscountFromJSON(
  jsonString: string,
): SafeParseResult<VariableDiscount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => VariableDiscount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'VariableDiscount' from JSON`,
  );
}

/** @internal */
export const Duration$inboundSchema: z.ZodMiniType<Duration, unknown> = z.pipe(
  z.object({
    type: DurationType$inboundSchema,
    period: types.nullable(z.lazy(() =>
      ComCrmPromotionSelfServiceResourceGetSinglePeriod$inboundSchema
    )),
    variable_discounts: z.optional(z.nullable(z.array(z.lazy(() =>
      VariableDiscount$inboundSchema
    )))),
  }),
  z.transform((v) => {
    return remap$(v, {
      "variable_discounts": "variableDiscounts",
    });
  }),
);

export function durationFromJSON(
  jsonString: string,
): SafeParseResult<Duration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Duration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Duration' from JSON`,
  );
}

/** @internal */
export const Offering$inboundSchema: z.ZodMiniType<Offering, unknown> = z
  .object({
    product: types.optional(z.lazy(() => OfferingProduct$inboundSchema)),
    type: types.optional(OfferingType$inboundSchema),
    amount: types.optional(types.number()),
    duration: types.optional(z.lazy(() => Duration$inboundSchema)),
  });

export function offeringFromJSON(
  jsonString: string,
): SafeParseResult<Offering, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Offering$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Offering' from JSON`,
  );
}

/** @internal */
export const ComCrmPromotionSelfServiceResourceGetSingleResponse$inboundSchema:
  z.ZodMiniType<ComCrmPromotionSelfServiceResourceGetSingleResponse, unknown> =
    z.pipe(
      z.object({
        id: types.optional(types.string()),
        name: types.optional(types.string()),
        state: types.optional(
          ComCrmPromotionSelfServiceResourceGetSingleState$inboundSchema,
        ),
        short_description: types.optional(types.string()),
        long_description: types.optional(types.string()),
        availability: types.optional(z.lazy(() =>
          ComCrmPromotionSelfServiceResourceGetSingleAvailability$inboundSchema
        )),
        targets: types.optional(z.lazy(() =>
          ComCrmPromotionSelfServiceResourceGetSingleTargets$inboundSchema
        )),
        basket: types.optional(z.lazy(() =>
          Basket$inboundSchema
        )),
        creatives: types.optional(z.array(z.lazy(() =>
          ComCrmPromotionSelfServiceResourceGetSingleCreative$inboundSchema
        ))),
        offerings: types.optional(z.array(z.lazy(() =>
          Offering$inboundSchema
        ))),
      }),
      z.transform((v) => {
        return remap$(v, {
          "short_description": "shortDescription",
          "long_description": "longDescription",
        });
      }),
    );

export function comCrmPromotionSelfServiceResourceGetSingleResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmPromotionSelfServiceResourceGetSingleResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmPromotionSelfServiceResourceGetSingleResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmPromotionSelfServiceResourceGetSingleResponse' from JSON`,
  );
}
