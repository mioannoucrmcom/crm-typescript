/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 * @generated-id: a7d02b8b42bf
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

/**
 * The usage record's billing directive; TO BE BILLED, NOT TO BE BILLED, TO BE CREDITED
 */
export const QueryParamBillingDirective = {
  ToBeBilled: "TO_BE_BILLED",
  NotToBeBilled: "NOT_TO_BE_BILLED",
  ToBeCredited: "TO_BE_CREDITED",
} as const;
/**
 * The usage record's billing directive; TO BE BILLED, NOT TO BE BILLED, TO BE CREDITED
 */
export type QueryParamBillingDirective = ClosedEnum<
  typeof QueryParamBillingDirective
>;

/**
 * The usage record's billing state; PENDING, COMPLETED
 */
export const QueryParamBillingState = {
  Pending: "PENDING",
  Completed: "COMPLETED",
} as const;
/**
 * The usage record's billing state; PENDING, COMPLETED
 */
export type QueryParamBillingState = ClosedEnum<typeof QueryParamBillingState>;

/**
 * Filters orders based on created date
 */
export const CreatedDate = {
  CreatedDateLt: "created_date[lt]",
  CreatedDateLte: "created_date[lte]",
  CreatedDateGt: "created_date[gt]",
  CreatedDateGte: "created_date[gte]",
} as const;
/**
 * Filters orders based on created date
 */
export type CreatedDate = ClosedEnum<typeof CreatedDate>;

/**
 * Filter based on the usage date, which may fall within a given date range. The value can be a string with a date in epoch format. Each option must also include an operator. Use up to two options based on the required search
 */
export const UsageTimestamp = {
  UsageTimestampLt: "usage_timestamp[lt]",
  UsageTimestampLte: "usage_timestamp[lte]",
  UsageTimestampGt: "usage_timestamp[gt]",
  UsageTimestampGte: "usage_timestamp[gte]",
} as const;
/**
 * Filter based on the usage date, which may fall within a given date range. The value can be a string with a date in epoch format. Each option must also include an operator. Use up to two options based on the required search
 */
export type UsageTimestamp = ClosedEnum<typeof UsageTimestamp>;

/**
 * Defines how the results will be ordered
 */
export const ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsOrder =
  {
    Asc: "ASC",
    Desc: "DESC",
  } as const;
/**
 * Defines how the results will be ordered
 */
export type ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsOrder =
  ClosedEnum<
    typeof ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsOrder
  >;

export type ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsRequest =
  {
    /**
     * The contact identifier that the usage records will be retrieved for
     */
    id: string;
    /**
     * The usage record's billing directive; TO BE BILLED, NOT TO BE BILLED, TO BE CREDITED
     */
    billingDirective?: QueryParamBillingDirective | undefined;
    /**
     * The usage record's billing state; PENDING, COMPLETED
     */
    billingState?: QueryParamBillingState | undefined;
    /**
     * Filters orders based on created date
     */
    createdDate?: CreatedDate | undefined;
    /**
     * The credit note in which the usage records were included
     */
    creditNoteId?: string | undefined;
    /**
     * The invoice in which the usage records were included
     */
    invoiceId?: string | undefined;
    /**
     * The organisation at which the usage was consumed
     */
    organisationId?: string | undefined;
    /**
     * The unique identifier of the termed service or one-time service
     */
    serviceId?: string | undefined;
    /**
     * Filter based on subscription. Usage was consumed as part of a service.
     */
    subscriptionId?: string | undefined;
    /**
     * The unique identifier of the usage product
     */
    usageServiceId?: string | undefined;
    /**
     * Filter based on the usage date, which may fall within a given date range. The value can be a string with a date in epoch format. Each option must also include an operator. Use up to two options based on the required search
     */
    usageTimestamp?: UsageTimestamp | undefined;
    /**
     * Defines how the results will be ordered
     */
    order?:
      | ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsOrder
      | undefined;
    /**
     * The page number that should be retrieved
     */
    page?: number | undefined;
    /**
     * The size (total records) of each page
     */
    size?: number | undefined;
    /**
     * Defines on which attribute the results should be sorted
     */
    sort?: string | undefined;
  };

export type ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsPaging =
  {
    /**
     * The page number
     */
    page?: number | undefined;
    /**
     * The number of records per page
     */
    size?: number | undefined;
    /**
     * The total number of records. If "include_total" is not specified, then this total is null. If "include_total" is specified, total has a value but it is accurate up to 10K records.
     */
    total?: number | undefined;
    /**
     * Shows if there are more records available to fetch
     */
    hasMore?: boolean | undefined;
  };

/**
 * Currency code based on ISO 4217 standard
 */
export const ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsCurrencyCode =
  {
    Aed: "AED",
    Afn: "AFN",
    All: "ALL",
    Amd: "AMD",
    Ang: "ANG",
    Aoa: "AOA",
    Ars: "ARS",
    Aud: "AUD",
    Awg: "AWG",
    Azn: "AZN",
    Bam: "BAM",
    Bbd: "BBD",
    Bdt: "BDT",
    Bgn: "BGN",
    Bhd: "BHD",
    Bif: "BIF",
    Bmd: "BMD",
    Bnd: "BND",
    Bob: "BOB",
    Brl: "BRL",
    Bsd: "BSD",
    Btn: "BTN",
    Bwp: "BWP",
    Byr: "BYR",
    Bzd: "BZD",
    Cad: "CAD",
    Cdf: "CDF",
    Chf: "CHF",
    Clp: "CLP",
    Cny: "CNY",
    Cop: "COP",
    Crc: "CRC",
    Cuc: "CUC",
    Cup: "CUP",
    Cve: "CVE",
    Czk: "CZK",
    Djf: "DJF",
    Dkk: "DKK",
    Dop: "DOP",
    Dzd: "DZD",
    Egp: "EGP",
    Ern: "ERN",
    Etb: "ETB",
    Eur: "EUR",
    Fjd: "FJD",
    Fkp: "FKP",
    Gbp: "GBP",
    Gel: "GEL",
    Ggp: "GGP",
    Ghs: "GHS",
    Gip: "GIP",
    Gmd: "GMD",
    Gnf: "GNF",
    Gtq: "GTQ",
    Gyd: "GYD",
    Hkd: "HKD",
    Hnl: "HNL",
    Hrk: "HRK",
    Htg: "HTG",
    Huf: "HUF",
    Idr: "IDR",
    Ils: "ILS",
    Imp: "IMP",
    Inr: "INR",
    Iqd: "IQD",
    Irr: "IRR",
    Isk: "ISK",
    Jep: "JEP",
    Jmd: "JMD",
    Jod: "JOD",
    Jpy: "JPY",
    Kes: "KES",
    Kgs: "KGS",
    Khr: "KHR",
    Kmf: "KMF",
    Kpw: "KPW",
    Krw: "KRW",
    Kwd: "KWD",
    Kyd: "KYD",
    Kzt: "KZT",
    Lak: "LAK",
    Lbp: "LBP",
    Lkr: "LKR",
    Lrd: "LRD",
    Lsl: "LSL",
    Lyd: "LYD",
    Mad: "MAD",
    Mdl: "MDL",
    Mga: "MGA",
    Mkd: "MKD",
    Mmk: "MMK",
    Mnt: "MNT",
    Mop: "MOP",
    Mro: "MRO",
    Mur: "MUR",
    Mvr: "MVR",
    Mwk: "MWK",
    Mxn: "MXN",
    Myr: "MYR",
    Mzn: "MZN",
    Nad: "NAD",
    Ngn: "NGN",
    Nio: "NIO",
    Nok: "NOK",
    Npr: "NPR",
    Nzd: "NZD",
    Omr: "OMR",
    Pab: "PAB",
    Pen: "PEN",
    Pgk: "PGK",
    Php: "PHP",
    Pkr: "PKR",
    Pln: "PLN",
    Pyg: "PYG",
    Qar: "QAR",
    Ron: "RON",
    Rsd: "RSD",
    Rub: "RUB",
    Rwf: "RWF",
    Sar: "SAR",
    Sbd: "SBD",
    Scr: "SCR",
    Sdg: "SDG",
    Sek: "SEK",
    Sgd: "SGD",
    Shp: "SHP",
    Sll: "SLL",
    Sos: "SOS",
    Spl: "SPL",
    Srd: "SRD",
    Std: "STD",
    Svc: "SVC",
    Syp: "SYP",
    Szl: "SZL",
    Thb: "THB",
    Tjs: "TJS",
    Tmt: "TMT",
    Tnd: "TND",
    Top: "TOP",
    Try: "TRY",
    Ttd: "TTD",
    Tvd: "TVD",
    Twd: "TWD",
    Tzs: "TZS",
    Uah: "UAH",
    Ugx: "UGX",
    Usd: "USD",
    Uyu: "UYU",
    Uzs: "UZS",
    Vef: "VEF",
    Vnd: "VND",
    Vuv: "VUV",
    Wst: "WST",
    Xaf: "XAF",
    Xcd: "XCD",
    Xdr: "XDR",
    Xof: "XOF",
    Xpf: "XPF",
    Yer: "YER",
    Zar: "ZAR",
    Zmw: "ZMW",
    Zwd: "ZWD",
    Pts: "PTS",
  } as const;
/**
 * Currency code based on ISO 4217 standard
 */
export type ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsCurrencyCode =
  OpenEnum<
    typeof ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsCurrencyCode
  >;

/**
 * The usage record's state.
 */
export const ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsState =
  {
    Posted: "POSTED",
    Rejected: "REJECTED",
    Cancelled: "CANCELLED",
  } as const;
/**
 * The usage record's state.
 */
export type ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsState =
  OpenEnum<
    typeof ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsState
  >;

/**
 * The usage record's billing directive shows if the usage will be billed or not
 */
export const BillingDirectiveResponse = {
  ToBeBilled: "TO_BE_BILLED",
  ToBeCredited: "TO_BE_CREDITED",
  NotToBeBilled: "NOT_TO_BE_BILLED",
} as const;
/**
 * The usage record's billing directive shows if the usage will be billed or not
 */
export type BillingDirectiveResponse = OpenEnum<
  typeof BillingDirectiveResponse
>;

/**
 * The usage records's billing state, i.e. if it was charged or not.
 */
export const BillingStateResponse = {
  Pending: "PENDING",
  Completed: "COMPLETED",
} as const;
/**
 * The usage records's billing state, i.e. if it was charged or not.
 */
export type BillingStateResponse = OpenEnum<typeof BillingStateResponse>;

/**
 * The usage product consumed. Can either be a usage service or a non-traceable physical good
 */
export type UsageProduct = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
  /**
   * The entity sku
   */
  sku?: string | undefined;
};

/**
 * The termed or one-time service through which usage was consumed.
 */
export type ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsService =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The entity name
     */
    name?: string | undefined;
    /**
     * The entity sku
     */
    sku?: string | undefined;
  };

/**
 * Organisation consuming usage
 */
export type ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsOrganisation =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The entity name
     */
    name?: string | undefined;
  };

/**
 * The usage service's measurement unit.
 */
export type ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsMeasurementUnit =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * Measurement unit name
     */
    name?: string | undefined;
    /**
     * How the measurement unit is displayed in the UI
     */
    displayName?: string | undefined;
  };

/**
 * The invoice related to the usage record
 */
export type ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsInvoice =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The entity number
     */
    number?: string | undefined;
    /**
     * The entity reference number
     */
    referenceNumber?: string | undefined;
  };

export type ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsContent =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * How much usage was consumed
     */
    usageAmount?: number | undefined;
    /**
     * When usage was consumed
     */
    usageTimestamp?: number | undefined;
    /**
     * When usage was created
     */
    createdDate?: number | undefined;
    /**
     * How much the usage consumption was charged
     */
    chargedAmount?: number | undefined;
    /**
     * Currency code based on ISO 4217 standard
     */
    currencyCode?:
      | ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsCurrencyCode
      | undefined;
    /**
     * How much the usage consumption was billed
     */
    billedAmount?: number | undefined;
    /**
     * The usage record's state.
     */
    state?:
      | ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsState
      | undefined;
    /**
     * The usage record's billing directive shows if the usage will be billed or not
     */
    billingDirective?: BillingDirectiveResponse | undefined;
    /**
     * The usage records's billing state, i.e. if it was charged or not.
     */
    billingState?: BillingStateResponse | undefined;
    /**
     * The usage product consumed. Can either be a usage service or a non-traceable physical good
     */
    usageProduct?: UsageProduct | undefined;
    /**
     * The termed or one-time service through which usage was consumed.
     */
    service?:
      | ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsService
      | undefined;
    /**
     * Organisation consuming usage
     */
    organisation?:
      | ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsOrganisation
      | undefined;
    /**
     * The usage service's measurement unit.
     */
    measurementUnit?:
      | ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsMeasurementUnit
      | undefined;
    /**
     * The invoice related to the usage record
     */
    invoice?:
      | ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsInvoice
      | undefined;
  };

/**
 * OK
 */
export type ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsResponse =
  {
    paging?:
      | ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsPaging
      | undefined;
    content?:
      | Array<
        ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsContent
      >
      | undefined;
  };

/** @internal */
export const QueryParamBillingDirective$outboundSchema: z.ZodMiniEnum<
  typeof QueryParamBillingDirective
> = z.enum(QueryParamBillingDirective);

/** @internal */
export const QueryParamBillingState$outboundSchema: z.ZodMiniEnum<
  typeof QueryParamBillingState
> = z.enum(QueryParamBillingState);

/** @internal */
export const CreatedDate$outboundSchema: z.ZodMiniEnum<typeof CreatedDate> = z
  .enum(CreatedDate);

/** @internal */
export const UsageTimestamp$outboundSchema: z.ZodMiniEnum<
  typeof UsageTimestamp
> = z.enum(UsageTimestamp);

/** @internal */
export const ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsOrder$outboundSchema:
  z.ZodMiniEnum<
    typeof ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsOrder
  > = z.enum(
    ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsOrder,
  );

/** @internal */
export type ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsRequest$Outbound =
  {
    id: string;
    billing_directive?: string | undefined;
    billing_state?: string | undefined;
    created_date?: string | undefined;
    credit_note_id?: string | undefined;
    invoice_id?: string | undefined;
    organisation_id?: string | undefined;
    service_id?: string | undefined;
    subscription_id?: string | undefined;
    usage_service_id?: string | undefined;
    usage_timestamp?: string | undefined;
    order: string;
    page: number;
    size: number;
    sort: string;
  };

/** @internal */
export const ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsRequest$outboundSchema:
  z.ZodMiniType<
    ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsRequest$Outbound,
    ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsRequest
  > = z.pipe(
    z.object({
      id: z.string(),
      billingDirective: z.optional(QueryParamBillingDirective$outboundSchema),
      billingState: z.optional(QueryParamBillingState$outboundSchema),
      createdDate: z.optional(CreatedDate$outboundSchema),
      creditNoteId: z.optional(z.string()),
      invoiceId: z.optional(z.string()),
      organisationId: z.optional(z.string()),
      serviceId: z.optional(z.string()),
      subscriptionId: z.optional(z.string()),
      usageServiceId: z.optional(z.string()),
      usageTimestamp: z.optional(UsageTimestamp$outboundSchema),
      order: z._default(
        ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsOrder$outboundSchema,
        "DESC",
      ),
      page: z._default(z.int(), 1),
      size: z._default(z.int(), 10),
      sort: z._default(z.string(), "CREATED_DATE"),
    }),
    z.transform((v) => {
      return remap$(v, {
        billingDirective: "billing_directive",
        billingState: "billing_state",
        createdDate: "created_date",
        creditNoteId: "credit_note_id",
        invoiceId: "invoice_id",
        organisationId: "organisation_id",
        serviceId: "service_id",
        subscriptionId: "subscription_id",
        usageServiceId: "usage_service_id",
        usageTimestamp: "usage_timestamp",
      });
    }),
  );

export function comCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsRequestToJSON(
  comCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsRequest:
    ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsRequest,
): string {
  return JSON.stringify(
    ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsRequest$outboundSchema
      .parse(
        comCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsRequest,
      ),
  );
}

/** @internal */
export const ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsPaging$inboundSchema:
  z.ZodMiniType<
    ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsPaging,
    unknown
  > = z.pipe(
    z.object({
      page: types.optional(types.number()),
      size: types.optional(types.number()),
      total: types.optional(types.number()),
      has_more: types.optional(types.boolean()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "has_more": "hasMore",
      });
    }),
  );

export function comCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsPagingFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsPaging,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsPaging$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsPaging' from JSON`,
  );
}

/** @internal */
export const ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsCurrencyCode$inboundSchema:
  z.ZodMiniType<
    ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsCurrencyCode,
    unknown
  > = openEnums.inboundSchema(
    ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsCurrencyCode,
  );

/** @internal */
export const ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsState$inboundSchema:
  z.ZodMiniType<
    ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsState,
    unknown
  > = openEnums.inboundSchema(
    ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsState,
  );

/** @internal */
export const BillingDirectiveResponse$inboundSchema: z.ZodMiniType<
  BillingDirectiveResponse,
  unknown
> = openEnums.inboundSchema(BillingDirectiveResponse);

/** @internal */
export const BillingStateResponse$inboundSchema: z.ZodMiniType<
  BillingStateResponse,
  unknown
> = openEnums.inboundSchema(BillingStateResponse);

/** @internal */
export const UsageProduct$inboundSchema: z.ZodMiniType<UsageProduct, unknown> =
  z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    sku: types.optional(types.string()),
  });

export function usageProductFromJSON(
  jsonString: string,
): SafeParseResult<UsageProduct, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UsageProduct$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UsageProduct' from JSON`,
  );
}

/** @internal */
export const ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsService$inboundSchema:
  z.ZodMiniType<
    ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsService,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    sku: types.optional(types.string()),
  });

export function comCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsServiceFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsService,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsService$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsService' from JSON`,
  );
}

/** @internal */
export const ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsOrganisation$inboundSchema:
  z.ZodMiniType<
    ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsOrganisation,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
  });

export function comCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsOrganisationFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsOrganisation,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsOrganisation$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsOrganisation' from JSON`,
  );
}

/** @internal */
export const ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsMeasurementUnit$inboundSchema:
  z.ZodMiniType<
    ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsMeasurementUnit,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      name: types.optional(types.string()),
      display_name: types.optional(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "display_name": "displayName",
      });
    }),
  );

export function comCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsMeasurementUnitFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsMeasurementUnit,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsMeasurementUnit$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsMeasurementUnit' from JSON`,
  );
}

/** @internal */
export const ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsInvoice$inboundSchema:
  z.ZodMiniType<
    ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsInvoice,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      number: types.optional(types.string()),
      reference_number: types.optional(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "reference_number": "referenceNumber",
      });
    }),
  );

export function comCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsInvoiceFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsInvoice,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsInvoice$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsInvoice' from JSON`,
  );
}

/** @internal */
export const ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsContent$inboundSchema:
  z.ZodMiniType<
    ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsContent,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      usage_amount: types.optional(types.number()),
      usage_timestamp: types.optional(types.number()),
      created_date: types.optional(types.number()),
      charged_amount: types.optional(types.number()),
      currency_code: types.optional(
        ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsCurrencyCode$inboundSchema,
      ),
      billed_amount: types.optional(types.number()),
      state: types.optional(
        ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsState$inboundSchema,
      ),
      billing_directive: types.optional(BillingDirectiveResponse$inboundSchema),
      billing_state: types.optional(BillingStateResponse$inboundSchema),
      usage_product: types.optional(z.lazy(() => UsageProduct$inboundSchema)),
      service: types.optional(z.lazy(() =>
        ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsService$inboundSchema
      )),
      organisation: types.optional(z.lazy(() =>
        ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsOrganisation$inboundSchema
      )),
      measurement_unit: types.optional(z.lazy(() =>
        ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsMeasurementUnit$inboundSchema
      )),
      invoice: types.optional(z.lazy(() =>
        ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsInvoice$inboundSchema
      )),
    }),
    z.transform((v) => {
      return remap$(v, {
        "usage_amount": "usageAmount",
        "usage_timestamp": "usageTimestamp",
        "created_date": "createdDate",
        "charged_amount": "chargedAmount",
        "currency_code": "currencyCode",
        "billed_amount": "billedAmount",
        "billing_directive": "billingDirective",
        "billing_state": "billingState",
        "usage_product": "usageProduct",
        "measurement_unit": "measurementUnit",
      });
    }),
  );

export function comCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsContentFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsContent$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsContent' from JSON`,
  );
}

/** @internal */
export const ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsResponse$inboundSchema:
  z.ZodMiniType<
    ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsResponse,
    unknown
  > = z.object({
    paging: types.optional(
      z.lazy(() =>
        ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsPaging$inboundSchema
      ),
    ),
    content: types.optional(
      z.array(z.lazy(() =>
        ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsContent$inboundSchema
      )),
    ),
  });

export function comCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsResponse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmUsageDetailRecordSelfServiceResourceListUsageDetailRecordsResponse' from JSON`,
  );
}
