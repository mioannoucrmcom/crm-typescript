/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 * @generated-id: 6303b2fa8825
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

/**
 * Currency code based on ISO 4217 standard
 */
export const ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceCurrencyCodeRequest =
  {
    Aed: "AED",
    Afn: "AFN",
    All: "ALL",
    Amd: "AMD",
    Ang: "ANG",
    Aoa: "AOA",
    Ars: "ARS",
    Aud: "AUD",
    Awg: "AWG",
    Azn: "AZN",
    Bam: "BAM",
    Bbd: "BBD",
    Bdt: "BDT",
    Bgn: "BGN",
    Bhd: "BHD",
    Bif: "BIF",
    Bmd: "BMD",
    Bnd: "BND",
    Bob: "BOB",
    Brl: "BRL",
    Bsd: "BSD",
    Btn: "BTN",
    Bwp: "BWP",
    Byr: "BYR",
    Bzd: "BZD",
    Cad: "CAD",
    Cdf: "CDF",
    Chf: "CHF",
    Clp: "CLP",
    Cny: "CNY",
    Cop: "COP",
    Crc: "CRC",
    Cuc: "CUC",
    Cup: "CUP",
    Cve: "CVE",
    Czk: "CZK",
    Djf: "DJF",
    Dkk: "DKK",
    Dop: "DOP",
    Dzd: "DZD",
    Egp: "EGP",
    Ern: "ERN",
    Etb: "ETB",
    Eur: "EUR",
    Fjd: "FJD",
    Fkp: "FKP",
    Gbp: "GBP",
    Gel: "GEL",
    Ggp: "GGP",
    Ghs: "GHS",
    Gip: "GIP",
    Gmd: "GMD",
    Gnf: "GNF",
    Gtq: "GTQ",
    Gyd: "GYD",
    Hkd: "HKD",
    Hnl: "HNL",
    Hrk: "HRK",
    Htg: "HTG",
    Huf: "HUF",
    Idr: "IDR",
    Ils: "ILS",
    Imp: "IMP",
    Inr: "INR",
    Iqd: "IQD",
    Irr: "IRR",
    Isk: "ISK",
    Jep: "JEP",
    Jmd: "JMD",
    Jod: "JOD",
    Jpy: "JPY",
    Kes: "KES",
    Kgs: "KGS",
    Khr: "KHR",
    Kmf: "KMF",
    Kpw: "KPW",
    Krw: "KRW",
    Kwd: "KWD",
    Kyd: "KYD",
    Kzt: "KZT",
    Lak: "LAK",
    Lbp: "LBP",
    Lkr: "LKR",
    Lrd: "LRD",
    Lsl: "LSL",
    Lyd: "LYD",
    Mad: "MAD",
    Mdl: "MDL",
    Mga: "MGA",
    Mkd: "MKD",
    Mmk: "MMK",
    Mnt: "MNT",
    Mop: "MOP",
    Mro: "MRO",
    Mur: "MUR",
    Mvr: "MVR",
    Mwk: "MWK",
    Mxn: "MXN",
    Myr: "MYR",
    Mzn: "MZN",
    Nad: "NAD",
    Ngn: "NGN",
    Nio: "NIO",
    Nok: "NOK",
    Npr: "NPR",
    Nzd: "NZD",
    Omr: "OMR",
    Pab: "PAB",
    Pen: "PEN",
    Pgk: "PGK",
    Php: "PHP",
    Pkr: "PKR",
    Pln: "PLN",
    Pyg: "PYG",
    Qar: "QAR",
    Ron: "RON",
    Rsd: "RSD",
    Rub: "RUB",
    Rwf: "RWF",
    Sar: "SAR",
    Sbd: "SBD",
    Scr: "SCR",
    Sdg: "SDG",
    Sek: "SEK",
    Sgd: "SGD",
    Shp: "SHP",
    Sll: "SLL",
    Sos: "SOS",
    Spl: "SPL",
    Srd: "SRD",
    Std: "STD",
    Svc: "SVC",
    Syp: "SYP",
    Szl: "SZL",
    Thb: "THB",
    Tjs: "TJS",
    Tmt: "TMT",
    Tnd: "TND",
    Top: "TOP",
    Try: "TRY",
    Ttd: "TTD",
    Tvd: "TVD",
    Twd: "TWD",
    Tzs: "TZS",
    Uah: "UAH",
    Ugx: "UGX",
    Usd: "USD",
    Uyu: "UYU",
    Uzs: "UZS",
    Vef: "VEF",
    Vnd: "VND",
    Vuv: "VUV",
    Wst: "WST",
    Xaf: "XAF",
    Xcd: "XCD",
    Xdr: "XDR",
    Xof: "XOF",
    Xpf: "XPF",
    Yer: "YER",
    Zar: "ZAR",
    Zmw: "ZMW",
    Zwd: "ZWD",
    Pts: "PTS",
  } as const;
/**
 * Currency code based on ISO 4217 standard
 */
export type ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceCurrencyCodeRequest =
  ClosedEnum<
    typeof ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceCurrencyCodeRequest
  >;

/**
 * The contact (identifier) that will be authorised
 */
export const ClassificationRequest = {
  TermedService: "TERMED_SERVICE",
  UsageService: "USAGE_SERVICE",
  OneTimeService: "ONE_TIME_SERVICE",
  TraceablePhysicalGood: "TRACEABLE_PHYSICAL_GOOD",
  NonTraceablePhysicalGood: "NON_TRACEABLE_PHYSICAL_GOOD",
  ExpensesService: "EXPENSES_SERVICE",
} as const;
/**
 * The contact (identifier) that will be authorised
 */
export type ClassificationRequest = ClosedEnum<typeof ClassificationRequest>;

/**
 * The identifier of the service through which usage is consumed. If not specified, then the response will include all termed and one-time services that allow the specified contact to consume usage. In the latter case, one-time services which are expired or fully consumed are not returned. For termed services, only non-cancelled ones are returned
 */
export type ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceRequest =
  {
    /**
     * The unique identifier of the service
     */
    id: string;
    /**
     * The contact (identifier) that will be authorised
     */
    classification: ClassificationRequest;
  };

/**
 * The usage product to be consumed (either a usage service or a non-traceable physical good)
 */
export type ProductRequest = {
  /**
   * The product id (product id and product sku are semi-optional)
   */
  id: string | null;
  /**
   * The product sku (product id and product sku are semi-optional)
   */
  sku: string | null;
};

export type Usage = {
  /**
   * The usage product to be consumed (either a usage service or a non-traceable physical good)
   */
  product?: ProductRequest | undefined;
  /**
   * The usage amount to be consumed. Either usage amount or cash amount should be specified
   */
  usageAmount?: number | undefined;
  /**
   * The cash amount to be consumed. Either usage amount or cash amount should be specified
   */
  cashAmount?: number | undefined;
};

export type ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRequest =
  {
    /**
     * The contact consuming usage
     */
    contactId?: string | undefined;
    /**
     * The community owner (contact identifier) that the contact performed such usage is a member to and has usage allowance to spend (applicable and required when the contact of the usage is a member to multiple communities and wants to use usage allowance from a specific community
     */
    communityId?: string | undefined;
    accountId?: string | undefined;
    /**
     * The organisation at which usage is consumed
     */
    organisationId?: string | undefined;
    /**
     * Currency code based on ISO 4217 standard
     */
    currencyCode?:
      | ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceCurrencyCodeRequest
      | undefined;
    /**
     * The identifier of the service through which usage is consumed. If not specified, then the response will include all termed and one-time services that allow the specified contact to consume usage. In the latter case, one-time services which are expired or fully consumed are not returned. For termed services, only non-cancelled ones are returned
     */
    service?:
      | ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceRequest
      | undefined;
    /**
     * When set to True, the requested usage that is requested to be consumed is blocked up until the contact actually confirms its cunsumption. This means that usage is blocked for a period of time until an Add Usage Record Web API is triggered to reduce the remaining allowance (if any).
     */
    blockUsage?: boolean | undefined;
    /**
     * An estimation id already obtained by previous calls to the same Web API. To be used during the adding usage flow and in cases where the same API is triggered multiple times since the user modifies usage items. So the same estimation id can be reused in subsequent calls for estimating the same usage
     */
    estimationId?: string | undefined;
    /**
     * The cash amount to be consumed. Either usage or cash amount should be specified
     */
    cashAmount?: number | undefined;
    /**
     * The usage to be consumed. Multiple usage products can be specified. Either usage or cash amount should be specified
     */
    usage?: Array<Usage> | undefined;
  };

/**
 * The currency code used in usage allowance cash amount limits
 */
export const ServiceCurrencyCode = {
  Aed: "AED",
  Afn: "AFN",
  All: "ALL",
  Amd: "AMD",
  Ang: "ANG",
  Aoa: "AOA",
  Ars: "ARS",
  Aud: "AUD",
  Awg: "AWG",
  Azn: "AZN",
  Bam: "BAM",
  Bbd: "BBD",
  Bdt: "BDT",
  Bgn: "BGN",
  Bhd: "BHD",
  Bif: "BIF",
  Bmd: "BMD",
  Bnd: "BND",
  Bob: "BOB",
  Brl: "BRL",
  Bsd: "BSD",
  Btn: "BTN",
  Bwp: "BWP",
  Byr: "BYR",
  Bzd: "BZD",
  Cad: "CAD",
  Cdf: "CDF",
  Chf: "CHF",
  Clp: "CLP",
  Cny: "CNY",
  Cop: "COP",
  Crc: "CRC",
  Cuc: "CUC",
  Cup: "CUP",
  Cve: "CVE",
  Czk: "CZK",
  Djf: "DJF",
  Dkk: "DKK",
  Dop: "DOP",
  Dzd: "DZD",
  Egp: "EGP",
  Ern: "ERN",
  Etb: "ETB",
  Eur: "EUR",
  Fjd: "FJD",
  Fkp: "FKP",
  Gbp: "GBP",
  Gel: "GEL",
  Ggp: "GGP",
  Ghs: "GHS",
  Gip: "GIP",
  Gmd: "GMD",
  Gnf: "GNF",
  Gtq: "GTQ",
  Gyd: "GYD",
  Hkd: "HKD",
  Hnl: "HNL",
  Hrk: "HRK",
  Htg: "HTG",
  Huf: "HUF",
  Idr: "IDR",
  Ils: "ILS",
  Imp: "IMP",
  Inr: "INR",
  Iqd: "IQD",
  Irr: "IRR",
  Isk: "ISK",
  Jep: "JEP",
  Jmd: "JMD",
  Jod: "JOD",
  Jpy: "JPY",
  Kes: "KES",
  Kgs: "KGS",
  Khr: "KHR",
  Kmf: "KMF",
  Kpw: "KPW",
  Krw: "KRW",
  Kwd: "KWD",
  Kyd: "KYD",
  Kzt: "KZT",
  Lak: "LAK",
  Lbp: "LBP",
  Lkr: "LKR",
  Lrd: "LRD",
  Lsl: "LSL",
  Lyd: "LYD",
  Mad: "MAD",
  Mdl: "MDL",
  Mga: "MGA",
  Mkd: "MKD",
  Mmk: "MMK",
  Mnt: "MNT",
  Mop: "MOP",
  Mro: "MRO",
  Mur: "MUR",
  Mvr: "MVR",
  Mwk: "MWK",
  Mxn: "MXN",
  Myr: "MYR",
  Mzn: "MZN",
  Nad: "NAD",
  Ngn: "NGN",
  Nio: "NIO",
  Nok: "NOK",
  Npr: "NPR",
  Nzd: "NZD",
  Omr: "OMR",
  Pab: "PAB",
  Pen: "PEN",
  Pgk: "PGK",
  Php: "PHP",
  Pkr: "PKR",
  Pln: "PLN",
  Pyg: "PYG",
  Qar: "QAR",
  Ron: "RON",
  Rsd: "RSD",
  Rub: "RUB",
  Rwf: "RWF",
  Sar: "SAR",
  Sbd: "SBD",
  Scr: "SCR",
  Sdg: "SDG",
  Sek: "SEK",
  Sgd: "SGD",
  Shp: "SHP",
  Sll: "SLL",
  Sos: "SOS",
  Spl: "SPL",
  Srd: "SRD",
  Std: "STD",
  Svc: "SVC",
  Syp: "SYP",
  Szl: "SZL",
  Thb: "THB",
  Tjs: "TJS",
  Tmt: "TMT",
  Tnd: "TND",
  Top: "TOP",
  Try: "TRY",
  Ttd: "TTD",
  Tvd: "TVD",
  Twd: "TWD",
  Tzs: "TZS",
  Uah: "UAH",
  Ugx: "UGX",
  Usd: "USD",
  Uyu: "UYU",
  Uzs: "UZS",
  Vef: "VEF",
  Vnd: "VND",
  Vuv: "VUV",
  Wst: "WST",
  Xaf: "XAF",
  Xcd: "XCD",
  Xdr: "XDR",
  Xof: "XOF",
  Xpf: "XPF",
  Yer: "YER",
  Zar: "ZAR",
  Zmw: "ZMW",
  Zwd: "ZWD",
  Pts: "PTS",
} as const;
/**
 * The currency code used in usage allowance cash amount limits
 */
export type ServiceCurrencyCode = OpenEnum<typeof ServiceCurrencyCode>;

/**
 * Product type classification
 */
export const ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceClassificationResponse =
  {
    TermedService: "TERMED_SERVICE",
    UsageService: "USAGE_SERVICE",
    OneTimeService: "ONE_TIME_SERVICE",
    TraceablePhysicalGood: "TRACEABLE_PHYSICAL_GOOD",
    NonTraceablePhysicalGood: "NON_TRACEABLE_PHYSICAL_GOOD",
    ExpensesService: "EXPENSES_SERVICE",
  } as const;
/**
 * Product type classification
 */
export type ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceClassificationResponse =
  OpenEnum<
    typeof ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceClassificationResponse
  >;

export type ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceProduct =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The entity name
     */
    name?: string | undefined;
    /**
     * The entity sku
     */
    sku?: string | undefined;
  };

/**
 * The one-time/termed service through which usage is consumed
 */
export type ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceServiceResponse =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * Product type classification
     */
    classification?:
      | ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceClassificationResponse
      | undefined;
    product?:
      | ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceProduct
      | undefined;
  };

export type CashAmounts = {
  perTransaction?: number | undefined;
  perDay?: number | undefined;
  perBillingCycle?: number | undefined;
};

export type ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceAccumulatedAllowance =
  {
    cashAmounts?: CashAmounts | undefined;
  };

export type ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRemainingCash =
  {
    perTransaction?: number | undefined;
    perDay?: number | undefined;
    perBillingCycle?: number | undefined;
  };

export type ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRemainingUsage =
  {
    perTransaction?: number | undefined;
    perDay?: number | undefined;
    perBillingCycle?: number | undefined;
  };

export type ServiceMeasurementUnit = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  name?: string | undefined;
  displayName?: string | undefined;
};

export type ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceProductsAllowance =
  {
    itemType?: string | undefined;
    itemId?: string | undefined;
    itemCode?: string | undefined;
    name?: string | undefined;
    remainingCash?:
      | ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRemainingCash
      | undefined;
    remainingUsage?:
      | ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRemainingUsage
      | undefined;
    measurementUnit?: ServiceMeasurementUnit | undefined;
  };

export type ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceResponse =
  {
    /**
     * Returned as True if usage can be consumed, i.e. termed/one-time service has remaining allowance. If no usage allowance limits are set, then usage is always authorised.
     */
    authoriseConsumption?: boolean | undefined;
    /**
     * The currency code used in usage allowance cash amount limits
     */
    currencyCode?: ServiceCurrencyCode | undefined;
    /**
     * The one-time/termed service through which usage is consumed
     */
    service?:
      | ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceServiceResponse
      | undefined;
    accumulatedAllowance?:
      | ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceAccumulatedAllowance
      | undefined;
    productsAllowance?:
      | Array<
        ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceProductsAllowance
      >
      | undefined;
  };

/**
 * The usage product to be consumed. Can either be a usage service or a non-traceable physical goods
 */
export type AuthorisedUsageProduct = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
  /**
   * The entity sku
   */
  sku?: string | undefined;
};

/**
 * The usage service's measurement unit
 */
export type AuthorisedUsageMeasurementUnit = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  name?: string | undefined;
  displayName?: string | undefined;
};

/**
 * Product type classification
 */
export const AuthorisedUsageClassification = {
  TermedService: "TERMED_SERVICE",
  UsageService: "USAGE_SERVICE",
  OneTimeService: "ONE_TIME_SERVICE",
  TraceablePhysicalGood: "TRACEABLE_PHYSICAL_GOOD",
  NonTraceablePhysicalGood: "NON_TRACEABLE_PHYSICAL_GOOD",
  ExpensesService: "EXPENSES_SERVICE",
} as const;
/**
 * Product type classification
 */
export type AuthorisedUsageClassification = OpenEnum<
  typeof AuthorisedUsageClassification
>;

export type AuthorisedUsageServiceProduct = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
  /**
   * The entity sku
   */
  sku?: string | undefined;
};

export type AuthorisedUsageService = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * Product type classification
   */
  classification?: AuthorisedUsageClassification | undefined;
  product?: AuthorisedUsageServiceProduct | undefined;
};

export type AuthorisedUsage = {
  amount?: number | undefined;
  usage?: number | undefined;
  /**
   * The usage product to be consumed. Can either be a usage service or a non-traceable physical goods
   */
  product?: AuthorisedUsageProduct | undefined;
  /**
   * The usage service's measurement unit
   */
  measurementUnit?: AuthorisedUsageMeasurementUnit | undefined;
  /**
   * Unique list of services that provide usage allowance to the contact
   */
  services?: Array<AuthorisedUsageService> | undefined;
};

/**
 * OK
 */
export type ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceResponse =
  {
    /**
     * Includes detailed information of the requested and authorised usage to be consumed. Can be used in a sub-sequent call to add a new usage record with the same usage information
     */
    estimationId?: string | undefined;
    /**
     * List of subscription services that allow the contact to consume usage along with the services' allowed and remaining usage
     */
    services?:
      | Array<
        ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceResponse
      >
      | undefined;
    /**
     * A set of products that have remaining usage allowance. The set includes usage services and non-traceable physical goods. This list includes only the products that still have remaining allowance, across all subscription services. This means that if the same usage products is granded some allowance from more than one services, then the total remaining allowance among all services is returned in a single object.
     */
    authorisedUsage?: Array<AuthorisedUsage> | undefined;
  };

/** @internal */
export const ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceCurrencyCodeRequest$outboundSchema:
  z.ZodMiniEnum<
    typeof ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceCurrencyCodeRequest
  > = z.enum(
    ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceCurrencyCodeRequest,
  );

/** @internal */
export const ClassificationRequest$outboundSchema: z.ZodMiniEnum<
  typeof ClassificationRequest
> = z.enum(ClassificationRequest);

/** @internal */
export type ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceRequest$Outbound =
  {
    id: string;
    classification: string;
  };

/** @internal */
export const ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceRequest$outboundSchema:
  z.ZodMiniType<
    ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceRequest$Outbound,
    ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceRequest
  > = z.object({
    id: z.string(),
    classification: ClassificationRequest$outboundSchema,
  });

export function comCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceRequestToJSON(
  comCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceRequest:
    ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceRequest,
): string {
  return JSON.stringify(
    ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceRequest$outboundSchema
      .parse(
        comCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceRequest,
      ),
  );
}

/** @internal */
export type ProductRequest$Outbound = {
  id: string | null;
  sku: string | null;
};

/** @internal */
export const ProductRequest$outboundSchema: z.ZodMiniType<
  ProductRequest$Outbound,
  ProductRequest
> = z.object({
  id: z.nullable(z.string()),
  sku: z.nullable(z.string()),
});

export function productRequestToJSON(productRequest: ProductRequest): string {
  return JSON.stringify(ProductRequest$outboundSchema.parse(productRequest));
}

/** @internal */
export type Usage$Outbound = {
  product?: ProductRequest$Outbound | undefined;
  usage_amount?: number | undefined;
  cash_amount?: number | undefined;
};

/** @internal */
export const Usage$outboundSchema: z.ZodMiniType<Usage$Outbound, Usage> = z
  .pipe(
    z.object({
      product: z.optional(z.lazy(() => ProductRequest$outboundSchema)),
      usageAmount: z.optional(z.number()),
      cashAmount: z.optional(z.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        usageAmount: "usage_amount",
        cashAmount: "cash_amount",
      });
    }),
  );

export function usageToJSON(usage: Usage): string {
  return JSON.stringify(Usage$outboundSchema.parse(usage));
}

/** @internal */
export type ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRequest$Outbound =
  {
    contact_id?: string | undefined;
    community_id?: string | undefined;
    account_id?: string | undefined;
    organisation_id?: string | undefined;
    currency_code?: string | undefined;
    service?:
      | ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceRequest$Outbound
      | undefined;
    block_usage: boolean;
    estimation_id?: string | undefined;
    cash_amount?: number | undefined;
    usage?: Array<Usage$Outbound> | undefined;
  };

/** @internal */
export const ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRequest$outboundSchema:
  z.ZodMiniType<
    ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRequest$Outbound,
    ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRequest
  > = z.pipe(
    z.object({
      contactId: z.optional(z.string()),
      communityId: z.optional(z.string()),
      accountId: z.optional(z.string()),
      organisationId: z.optional(z.string()),
      currencyCode: z.optional(
        ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceCurrencyCodeRequest$outboundSchema,
      ),
      service: z.optional(z.lazy(() =>
        ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceRequest$outboundSchema
      )),
      blockUsage: z._default(z.boolean(), true),
      estimationId: z.optional(z.string()),
      cashAmount: z.optional(z.number()),
      usage: z.optional(z.array(z.lazy(() =>
        Usage$outboundSchema
      ))),
    }),
    z.transform((v) => {
      return remap$(v, {
        contactId: "contact_id",
        communityId: "community_id",
        accountId: "account_id",
        organisationId: "organisation_id",
        currencyCode: "currency_code",
        blockUsage: "block_usage",
        estimationId: "estimation_id",
        cashAmount: "cash_amount",
      });
    }),
  );

export function comCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRequestToJSON(
  comCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRequest:
    ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRequest,
): string {
  return JSON.stringify(
    ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRequest$outboundSchema
      .parse(
        comCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRequest,
      ),
  );
}

/** @internal */
export const ServiceCurrencyCode$inboundSchema: z.ZodMiniType<
  ServiceCurrencyCode,
  unknown
> = openEnums.inboundSchema(ServiceCurrencyCode);

/** @internal */
export const ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceClassificationResponse$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceClassificationResponse,
    unknown
  > = openEnums.inboundSchema(
    ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceClassificationResponse,
  );

/** @internal */
export const ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceProduct$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceProduct,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    sku: types.optional(types.string()),
  });

export function comCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceProductFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceProduct,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceProduct$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceProduct' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceServiceResponse$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceServiceResponse,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    classification: types.optional(
      ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceClassificationResponse$inboundSchema,
    ),
    product: types.optional(
      z.lazy(() =>
        ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceProduct$inboundSchema
      ),
    ),
  });

export function comCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceServiceResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceServiceResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceServiceResponse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceServiceResponse' from JSON`,
  );
}

/** @internal */
export const CashAmounts$inboundSchema: z.ZodMiniType<CashAmounts, unknown> = z
  .pipe(
    z.object({
      per_transaction: types.optional(types.number()),
      per_day: types.optional(types.number()),
      per_billing_cycle: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "per_transaction": "perTransaction",
        "per_day": "perDay",
        "per_billing_cycle": "perBillingCycle",
      });
    }),
  );

export function cashAmountsFromJSON(
  jsonString: string,
): SafeParseResult<CashAmounts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CashAmounts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CashAmounts' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceAccumulatedAllowance$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceAccumulatedAllowance,
    unknown
  > = z.pipe(
    z.object({
      cash_amounts: types.optional(z.lazy(() => CashAmounts$inboundSchema)),
    }),
    z.transform((v) => {
      return remap$(v, {
        "cash_amounts": "cashAmounts",
      });
    }),
  );

export function comCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceAccumulatedAllowanceFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceAccumulatedAllowance,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceAccumulatedAllowance$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceAccumulatedAllowance' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRemainingCash$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRemainingCash,
    unknown
  > = z.pipe(
    z.object({
      per_transaction: types.optional(types.number()),
      per_day: types.optional(types.number()),
      per_billing_cycle: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "per_transaction": "perTransaction",
        "per_day": "perDay",
        "per_billing_cycle": "perBillingCycle",
      });
    }),
  );

export function comCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRemainingCashFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRemainingCash,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRemainingCash$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRemainingCash' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRemainingUsage$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRemainingUsage,
    unknown
  > = z.pipe(
    z.object({
      per_transaction: types.optional(types.number()),
      per_day: types.optional(types.number()),
      per_billing_cycle: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "per_transaction": "perTransaction",
        "per_day": "perDay",
        "per_billing_cycle": "perBillingCycle",
      });
    }),
  );

export function comCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRemainingUsageFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRemainingUsage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRemainingUsage$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRemainingUsage' from JSON`,
  );
}

/** @internal */
export const ServiceMeasurementUnit$inboundSchema: z.ZodMiniType<
  ServiceMeasurementUnit,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    display_name: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "display_name": "displayName",
    });
  }),
);

export function serviceMeasurementUnitFromJSON(
  jsonString: string,
): SafeParseResult<ServiceMeasurementUnit, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ServiceMeasurementUnit$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ServiceMeasurementUnit' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceProductsAllowance$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceProductsAllowance,
    unknown
  > = z.pipe(
    z.object({
      item_type: types.optional(types.string()),
      item_id: types.optional(types.string()),
      item_code: types.optional(types.string()),
      name: types.optional(types.string()),
      remaining_cash: types.optional(z.lazy(() =>
        ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRemainingCash$inboundSchema
      )),
      remaining_usage: types.optional(z.lazy(() =>
        ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceRemainingUsage$inboundSchema
      )),
      measurement_unit: types.optional(z.lazy(() =>
        ServiceMeasurementUnit$inboundSchema
      )),
    }),
    z.transform((v) => {
      return remap$(v, {
        "item_type": "itemType",
        "item_id": "itemId",
        "item_code": "itemCode",
        "remaining_cash": "remainingCash",
        "remaining_usage": "remainingUsage",
        "measurement_unit": "measurementUnit",
      });
    }),
  );

export function comCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceProductsAllowanceFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceProductsAllowance,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceProductsAllowance$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceProductsAllowance' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceResponse$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceResponse,
    unknown
  > = z.pipe(
    z.object({
      authorise_consumption: types.optional(types.boolean()),
      currency_code: types.optional(ServiceCurrencyCode$inboundSchema),
      service: types.optional(z.lazy(() =>
        ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceServiceResponse$inboundSchema
      )),
      accumulated_allowance: types.optional(z.lazy(() =>
        ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceAccumulatedAllowance$inboundSchema
      )),
      products_allowance: types.optional(z.array(z.lazy(() =>
        ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceProductsAllowance$inboundSchema
      ))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "authorise_consumption": "authoriseConsumption",
        "currency_code": "currencyCode",
        "accumulated_allowance": "accumulatedAllowance",
        "products_allowance": "productsAllowance",
      });
    }),
  );

export function comCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceResponse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceResponse' from JSON`,
  );
}

/** @internal */
export const AuthorisedUsageProduct$inboundSchema: z.ZodMiniType<
  AuthorisedUsageProduct,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
  sku: types.optional(types.string()),
});

export function authorisedUsageProductFromJSON(
  jsonString: string,
): SafeParseResult<AuthorisedUsageProduct, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthorisedUsageProduct$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthorisedUsageProduct' from JSON`,
  );
}

/** @internal */
export const AuthorisedUsageMeasurementUnit$inboundSchema: z.ZodMiniType<
  AuthorisedUsageMeasurementUnit,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    display_name: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "display_name": "displayName",
    });
  }),
);

export function authorisedUsageMeasurementUnitFromJSON(
  jsonString: string,
): SafeParseResult<AuthorisedUsageMeasurementUnit, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthorisedUsageMeasurementUnit$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthorisedUsageMeasurementUnit' from JSON`,
  );
}

/** @internal */
export const AuthorisedUsageClassification$inboundSchema: z.ZodMiniType<
  AuthorisedUsageClassification,
  unknown
> = openEnums.inboundSchema(AuthorisedUsageClassification);

/** @internal */
export const AuthorisedUsageServiceProduct$inboundSchema: z.ZodMiniType<
  AuthorisedUsageServiceProduct,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
  sku: types.optional(types.string()),
});

export function authorisedUsageServiceProductFromJSON(
  jsonString: string,
): SafeParseResult<AuthorisedUsageServiceProduct, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthorisedUsageServiceProduct$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthorisedUsageServiceProduct' from JSON`,
  );
}

/** @internal */
export const AuthorisedUsageService$inboundSchema: z.ZodMiniType<
  AuthorisedUsageService,
  unknown
> = z.object({
  id: types.optional(types.string()),
  classification: types.optional(AuthorisedUsageClassification$inboundSchema),
  product: types.optional(
    z.lazy(() => AuthorisedUsageServiceProduct$inboundSchema),
  ),
});

export function authorisedUsageServiceFromJSON(
  jsonString: string,
): SafeParseResult<AuthorisedUsageService, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthorisedUsageService$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthorisedUsageService' from JSON`,
  );
}

/** @internal */
export const AuthorisedUsage$inboundSchema: z.ZodMiniType<
  AuthorisedUsage,
  unknown
> = z.pipe(
  z.object({
    amount: types.optional(types.number()),
    usage: types.optional(types.number()),
    product: types.optional(z.lazy(() => AuthorisedUsageProduct$inboundSchema)),
    measurement_unit: types.optional(
      z.lazy(() => AuthorisedUsageMeasurementUnit$inboundSchema),
    ),
    services: types.optional(
      z.array(z.lazy(() => AuthorisedUsageService$inboundSchema)),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "measurement_unit": "measurementUnit",
    });
  }),
);

export function authorisedUsageFromJSON(
  jsonString: string,
): SafeParseResult<AuthorisedUsage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthorisedUsage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthorisedUsage' from JSON`,
  );
}

/** @internal */
export const ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceResponse$inboundSchema:
  z.ZodMiniType<
    ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceResponse,
    unknown
  > = z.pipe(
    z.object({
      estimation_id: types.optional(types.string()),
      services: types.optional(z.array(z.lazy(() =>
        ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceServiceResponse$inboundSchema
      ))),
      authorised_usage: types.optional(z.array(z.lazy(() =>
        AuthorisedUsage$inboundSchema
      ))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "estimation_id": "estimationId",
        "authorised_usage": "authorisedUsage",
      });
    }),
  );

export function comCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceResponse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmEstimateAllowanceSelfServiceResourceEstimatesAllowanceResponse' from JSON`,
  );
}
