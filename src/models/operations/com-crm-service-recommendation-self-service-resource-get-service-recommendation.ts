/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 * @generated-id: 1d4f209eba5a
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationSecurity =
  {
    secretAPIKey?: string | undefined;
    authorization?: string | undefined;
  };

/**
 * Defines how the results will be ordered
 */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationOrder =
  {
    Asc: "ASC",
    Desc: "DESC",
  } as const;
/**
 * Defines how the results will be ordered
 */
export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationOrder =
  ClosedEnum<
    typeof ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationOrder
  >;

export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationRequest =
  {
    /**
     * The subscriber's account identifier
     */
    accountId?: string | undefined;
    /**
     * The billing model
     */
    billingModel?: string | undefined;
    /**
     * Billing period duration. If specified, then the period's UOT must also be specified
     */
    billingPeriodDuration?: number | undefined;
    /**
     * Billing period's uot (required when searching for services with a specific billing cycle duration)
     */
    billingPeriodUot?: string | undefined;
    /**
     * The contact identifier. Either a contact or an orgnaisation can be specified
     */
    contactId?: string | undefined;
    /**
     * Defines whether component products will be returned when the recommended service is a flexible bundle or not.
     */
    includeComponents?: boolean | undefined;
    /**
     * Determines whether creatives will also be returned or not. Defaults to false.
     */
    includeCreatives?: boolean | undefined;
    /**
     * The organisation identifier. Either an organisation or a contact should be specified
     */
    organisationId?: string | undefined;
    /**
     * The price identifier selected for a new service. Applicable when a bundle's components will be retrieved to get their differentail prices
     */
    priceTermsId?: string | undefined;
    /**
     * Product identifier whose components will be retrieved. Applicable only for flexible bundles to get their allowed service components
     */
    productId?: string | undefined;
    /**
     * Search for a service based on its SKU, name and description
     */
    searchValue?: string | undefined;
    /**
     * Subscripiton service identifier in cases where the subscriber wants to change a specific service
     */
    serviceId?: string | undefined;
    /**
     * Subscription identifier in cases where the subscriber wants to amend the services of an existing subscription
     */
    subscriptionId?: string | undefined;
    /**
     * The type composition
     */
    typeComposition?: string | undefined;
    /**
     * Determine if a "total" will be returned in paging reference. If set to True, then "total" is also returned but it will return up to 10K value. If set to False, then the "total" in paging is null.
     */
    includeTotal?: boolean | undefined;
    /**
     * Defines how the results will be ordered
     */
    order?:
      | ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationOrder
      | undefined;
    /**
     * The page number that should be retrieved
     */
    page?: number | undefined;
    /**
     * The size (total records) of each page
     */
    size?: number | undefined;
    /**
     * Defines on which attribute the results should be sorted
     */
    sort?: string | undefined;
  };

export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPaging =
  {
    /**
     * The page number
     */
    page?: number | undefined;
    /**
     * The number of records per page
     */
    size?: number | undefined;
    /**
     * The total number of records. If "include_total" is not specified, then this total is null. If "include_total" is specified, total has a value but it is accurate up to 10K records.
     */
    total?: number | undefined;
    /**
     * Shows if there are more records available to fetch
     */
    hasMore?: boolean | undefined;
  };

/**
 * Product Composition
 */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComposition =
  {
    Flat: "FLAT",
    FlexibleBundle: "FLEXIBLE_BUNDLE",
    FixedBundle: "FIXED_BUNDLE",
    Composite: "COMPOSITE",
  } as const;
/**
 * Product Composition
 */
export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComposition =
  OpenEnum<
    typeof ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComposition
  >;

/**
 * Determines whether a service is managed as a single quantity or as separate, independently managed instances on a subscription
 */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationInstanceModel =
  {
    QuantityBased: "QUANTITY_BASED",
    LineBased: "LINE_BASED",
  } as const;
/**
 * Determines whether a service is managed as a single quantity or as separate, independently managed instances on a subscription
 */
export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationInstanceModel =
  OpenEnum<
    typeof ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationInstanceModel
  >;

/**
 * Price model of the price
 */
export const PricePriceModel = {
  Flat: "FLAT",
  Tiered: "TIERED",
  Volume: "VOLUME",
  Stairstep: "STAIRSTEP",
} as const;
/**
 * Price model of the price
 */
export type PricePriceModel = OpenEnum<typeof PricePriceModel>;

/**
 * Currency code based on ISO 4217 standard
 */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceCurrencyCode =
  {
    Aed: "AED",
    Afn: "AFN",
    All: "ALL",
    Amd: "AMD",
    Ang: "ANG",
    Aoa: "AOA",
    Ars: "ARS",
    Aud: "AUD",
    Awg: "AWG",
    Azn: "AZN",
    Bam: "BAM",
    Bbd: "BBD",
    Bdt: "BDT",
    Bgn: "BGN",
    Bhd: "BHD",
    Bif: "BIF",
    Bmd: "BMD",
    Bnd: "BND",
    Bob: "BOB",
    Brl: "BRL",
    Bsd: "BSD",
    Btn: "BTN",
    Bwp: "BWP",
    Byr: "BYR",
    Bzd: "BZD",
    Cad: "CAD",
    Cdf: "CDF",
    Chf: "CHF",
    Clp: "CLP",
    Cny: "CNY",
    Cop: "COP",
    Crc: "CRC",
    Cuc: "CUC",
    Cup: "CUP",
    Cve: "CVE",
    Czk: "CZK",
    Djf: "DJF",
    Dkk: "DKK",
    Dop: "DOP",
    Dzd: "DZD",
    Egp: "EGP",
    Ern: "ERN",
    Etb: "ETB",
    Eur: "EUR",
    Fjd: "FJD",
    Fkp: "FKP",
    Gbp: "GBP",
    Gel: "GEL",
    Ggp: "GGP",
    Ghs: "GHS",
    Gip: "GIP",
    Gmd: "GMD",
    Gnf: "GNF",
    Gtq: "GTQ",
    Gyd: "GYD",
    Hkd: "HKD",
    Hnl: "HNL",
    Hrk: "HRK",
    Htg: "HTG",
    Huf: "HUF",
    Idr: "IDR",
    Ils: "ILS",
    Imp: "IMP",
    Inr: "INR",
    Iqd: "IQD",
    Irr: "IRR",
    Isk: "ISK",
    Jep: "JEP",
    Jmd: "JMD",
    Jod: "JOD",
    Jpy: "JPY",
    Kes: "KES",
    Kgs: "KGS",
    Khr: "KHR",
    Kmf: "KMF",
    Kpw: "KPW",
    Krw: "KRW",
    Kwd: "KWD",
    Kyd: "KYD",
    Kzt: "KZT",
    Lak: "LAK",
    Lbp: "LBP",
    Lkr: "LKR",
    Lrd: "LRD",
    Lsl: "LSL",
    Lyd: "LYD",
    Mad: "MAD",
    Mdl: "MDL",
    Mga: "MGA",
    Mkd: "MKD",
    Mmk: "MMK",
    Mnt: "MNT",
    Mop: "MOP",
    Mro: "MRO",
    Mur: "MUR",
    Mvr: "MVR",
    Mwk: "MWK",
    Mxn: "MXN",
    Myr: "MYR",
    Mzn: "MZN",
    Nad: "NAD",
    Ngn: "NGN",
    Nio: "NIO",
    Nok: "NOK",
    Npr: "NPR",
    Nzd: "NZD",
    Omr: "OMR",
    Pab: "PAB",
    Pen: "PEN",
    Pgk: "PGK",
    Php: "PHP",
    Pkr: "PKR",
    Pln: "PLN",
    Pyg: "PYG",
    Qar: "QAR",
    Ron: "RON",
    Rsd: "RSD",
    Rub: "RUB",
    Rwf: "RWF",
    Sar: "SAR",
    Sbd: "SBD",
    Scr: "SCR",
    Sdg: "SDG",
    Sek: "SEK",
    Sgd: "SGD",
    Shp: "SHP",
    Sll: "SLL",
    Sos: "SOS",
    Spl: "SPL",
    Srd: "SRD",
    Std: "STD",
    Svc: "SVC",
    Syp: "SYP",
    Szl: "SZL",
    Thb: "THB",
    Tjs: "TJS",
    Tmt: "TMT",
    Tnd: "TND",
    Top: "TOP",
    Try: "TRY",
    Ttd: "TTD",
    Tvd: "TVD",
    Twd: "TWD",
    Tzs: "TZS",
    Uah: "UAH",
    Ugx: "UGX",
    Usd: "USD",
    Uyu: "UYU",
    Uzs: "UZS",
    Vef: "VEF",
    Vnd: "VND",
    Vuv: "VUV",
    Wst: "WST",
    Xaf: "XAF",
    Xcd: "XCD",
    Xdr: "XDR",
    Xof: "XOF",
    Xpf: "XPF",
    Yer: "YER",
    Zar: "ZAR",
    Zmw: "ZMW",
    Zwd: "ZWD",
    Pts: "PTS",
  } as const;
/**
 * Currency code based on ISO 4217 standard
 */
export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceCurrencyCode =
  OpenEnum<
    typeof ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceCurrencyCode
  >;

/**
 * Defines whether the price is tax inclusive or not. Defaults to the system's Taxation setting
 */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceTaxModel =
  {
    TaxInclusive: "TAX_INCLUSIVE",
    TaxExclusive: "TAX_EXCLUSIVE",
  } as const;
/**
 * Defines whether the price is tax inclusive or not. Defaults to the system's Taxation setting
 */
export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceTaxModel =
  OpenEnum<
    typeof ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceTaxModel
  >;

/**
 * Defines whether the service is billed in pre-/post-bill mode
 */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationBillingModel =
  {
    PreBill: "PRE_BILL",
    PostBill: "POST_BILL",
  } as const;
/**
 * Defines whether the service is billed in pre-/post-bill mode
 */
export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationBillingModel =
  OpenEnum<
    typeof ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationBillingModel
  >;

/**
 * Period Cycle unit of time
 */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationBillingPeriodUot =
  {
    Second: "SECOND",
    Minute: "MINUTE",
    Hour: "HOUR",
    Day: "DAY",
    Week: "WEEK",
    Month: "MONTH",
    Year: "YEAR",
    Overall: "OVERALL",
  } as const;
/**
 * Period Cycle unit of time
 */
export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationBillingPeriodUot =
  OpenEnum<
    typeof ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationBillingPeriodUot
  >;

/**
 * The service's billing period, i.e. how often it will be billed
 */
export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationBillingPeriod =
  {
    /**
     * Period Cycle duration
     */
    duration?: number | undefined;
    /**
     * Period Cycle unit of time
     */
    uot?:
      | ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationBillingPeriodUot
      | undefined;
  };

/**
 * Period Cycle unit of time
 */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationTrialPeriodUot =
  {
    Second: "SECOND",
    Minute: "MINUTE",
    Hour: "HOUR",
    Day: "DAY",
    Week: "WEEK",
    Month: "MONTH",
    Year: "YEAR",
    Overall: "OVERALL",
  } as const;
/**
 * Period Cycle unit of time
 */
export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationTrialPeriodUot =
  OpenEnum<
    typeof ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationTrialPeriodUot
  >;

/**
 * Shows if the service will get a trial period
 */
export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationTrialPeriod =
  {
    /**
     * Period Cycle duration
     */
    duration?: number | undefined;
    /**
     * Period Cycle unit of time
     */
    uot?:
      | ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationTrialPeriodUot
      | undefined;
  };

/**
 * Period Cycle unit of time
 */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContractPeriodUot =
  {
    Second: "SECOND",
    Minute: "MINUTE",
    Hour: "HOUR",
    Day: "DAY",
    Week: "WEEK",
    Month: "MONTH",
    Year: "YEAR",
    Overall: "OVERALL",
  } as const;
/**
 * Period Cycle unit of time
 */
export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContractPeriodUot =
  OpenEnum<
    typeof ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContractPeriodUot
  >;

/**
 * The service's contract period (if any)
 */
export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContractPeriod =
  {
    /**
     * Period Cycle duration
     */
    duration?: number | undefined;
    /**
     * Period Cycle unit of time
     */
    uot?:
      | ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContractPeriodUot
      | undefined;
  };

/**
 * Price terms
 */
export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceTerms =
  {
    /**
     * Defines whether the service is billed in pre-/post-bill mode
     */
    billingModel?:
      | ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationBillingModel
      | undefined;
    /**
     * The service's billing period, i.e. how often it will be billed
     */
    billingPeriod?:
      | ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationBillingPeriod
      | undefined;
    /**
     * Shows if the service will get a trial period
     */
    trialPeriod?:
      | ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationTrialPeriod
      | undefined;
    /**
     * The service's contract period (if any)
     */
    contractPeriod?:
      | ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContractPeriod
      | undefined;
    /**
     * Set to True if service's terms are automatically renewdd at the end of the termed period. When set to False, the service is expired at the end of the termed period
     */
    autoRenew?: boolean | undefined;
    /**
     * Service's termed period duration. The duration is specified in number of billing cycles
     */
    termedPeriod?: number | undefined;
  };

export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPrice =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The label of the price
     */
    label?: string | undefined;
    /**
     * The default price of the service, when multiple prices are set
     */
    isDefault?: boolean | undefined;
    /**
     * Indicates the price terms already selected for the service. Applicable when the contact is already subscribed to a service and the recommendation Web API suggests other prices terms to which the service can change to
     */
    currentPrice?: boolean | undefined;
    /**
     * Price model of the price
     */
    priceModel?: PricePriceModel | undefined;
    /**
     * Applicable for quantity based models and shows the number of tier levels specified of the service since the recommendation Web API returns the price of the first tier level only
     */
    tiers?: number | undefined;
    /**
     * The first tier level's upper tier
     */
    upperTier?: number | undefined;
    /**
     * Price value
     */
    price?: number | undefined;
    /**
     * The price when the service goes out of contract. Applicable for price terms with contactract period
     */
    outContractPrice?: number | undefined;
    /**
     * Currency code based on ISO 4217 standard
     */
    currencyCode?:
      | ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceCurrencyCode
      | undefined;
    /**
     * Defines whether the price is tax inclusive or not. Defaults to the system's Taxation setting
     */
    taxModel?:
      | ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceTaxModel
      | undefined;
    /**
     * Price terms
     */
    priceTerms?:
      | ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceTerms
      | undefined;
  };

/**
 * Allowed components can be individual products or products of a specific type, family, component set or category
 */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationItemType =
  {
    Product: "PRODUCT",
    Family: "FAMILY",
    Type: "TYPE",
    Category: "CATEGORY",
    ComponentSet: "COMPONENT_SET",
  } as const;
/**
 * Allowed components can be individual products or products of a specific type, family, component set or category
 */
export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationItemType =
  OpenEnum<
    typeof ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationItemType
  >;

/**
 * Currency code based on ISO 4217 standard
 */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponentPriceCurrencyCode =
  {
    Aed: "AED",
    Afn: "AFN",
    All: "ALL",
    Amd: "AMD",
    Ang: "ANG",
    Aoa: "AOA",
    Ars: "ARS",
    Aud: "AUD",
    Awg: "AWG",
    Azn: "AZN",
    Bam: "BAM",
    Bbd: "BBD",
    Bdt: "BDT",
    Bgn: "BGN",
    Bhd: "BHD",
    Bif: "BIF",
    Bmd: "BMD",
    Bnd: "BND",
    Bob: "BOB",
    Brl: "BRL",
    Bsd: "BSD",
    Btn: "BTN",
    Bwp: "BWP",
    Byr: "BYR",
    Bzd: "BZD",
    Cad: "CAD",
    Cdf: "CDF",
    Chf: "CHF",
    Clp: "CLP",
    Cny: "CNY",
    Cop: "COP",
    Crc: "CRC",
    Cuc: "CUC",
    Cup: "CUP",
    Cve: "CVE",
    Czk: "CZK",
    Djf: "DJF",
    Dkk: "DKK",
    Dop: "DOP",
    Dzd: "DZD",
    Egp: "EGP",
    Ern: "ERN",
    Etb: "ETB",
    Eur: "EUR",
    Fjd: "FJD",
    Fkp: "FKP",
    Gbp: "GBP",
    Gel: "GEL",
    Ggp: "GGP",
    Ghs: "GHS",
    Gip: "GIP",
    Gmd: "GMD",
    Gnf: "GNF",
    Gtq: "GTQ",
    Gyd: "GYD",
    Hkd: "HKD",
    Hnl: "HNL",
    Hrk: "HRK",
    Htg: "HTG",
    Huf: "HUF",
    Idr: "IDR",
    Ils: "ILS",
    Imp: "IMP",
    Inr: "INR",
    Iqd: "IQD",
    Irr: "IRR",
    Isk: "ISK",
    Jep: "JEP",
    Jmd: "JMD",
    Jod: "JOD",
    Jpy: "JPY",
    Kes: "KES",
    Kgs: "KGS",
    Khr: "KHR",
    Kmf: "KMF",
    Kpw: "KPW",
    Krw: "KRW",
    Kwd: "KWD",
    Kyd: "KYD",
    Kzt: "KZT",
    Lak: "LAK",
    Lbp: "LBP",
    Lkr: "LKR",
    Lrd: "LRD",
    Lsl: "LSL",
    Lyd: "LYD",
    Mad: "MAD",
    Mdl: "MDL",
    Mga: "MGA",
    Mkd: "MKD",
    Mmk: "MMK",
    Mnt: "MNT",
    Mop: "MOP",
    Mro: "MRO",
    Mur: "MUR",
    Mvr: "MVR",
    Mwk: "MWK",
    Mxn: "MXN",
    Myr: "MYR",
    Mzn: "MZN",
    Nad: "NAD",
    Ngn: "NGN",
    Nio: "NIO",
    Nok: "NOK",
    Npr: "NPR",
    Nzd: "NZD",
    Omr: "OMR",
    Pab: "PAB",
    Pen: "PEN",
    Pgk: "PGK",
    Php: "PHP",
    Pkr: "PKR",
    Pln: "PLN",
    Pyg: "PYG",
    Qar: "QAR",
    Ron: "RON",
    Rsd: "RSD",
    Rub: "RUB",
    Rwf: "RWF",
    Sar: "SAR",
    Sbd: "SBD",
    Scr: "SCR",
    Sdg: "SDG",
    Sek: "SEK",
    Sgd: "SGD",
    Shp: "SHP",
    Sll: "SLL",
    Sos: "SOS",
    Spl: "SPL",
    Srd: "SRD",
    Std: "STD",
    Svc: "SVC",
    Syp: "SYP",
    Szl: "SZL",
    Thb: "THB",
    Tjs: "TJS",
    Tmt: "TMT",
    Tnd: "TND",
    Top: "TOP",
    Try: "TRY",
    Ttd: "TTD",
    Tvd: "TVD",
    Twd: "TWD",
    Tzs: "TZS",
    Uah: "UAH",
    Ugx: "UGX",
    Usd: "USD",
    Uyu: "UYU",
    Uzs: "UZS",
    Vef: "VEF",
    Vnd: "VND",
    Vuv: "VUV",
    Wst: "WST",
    Xaf: "XAF",
    Xcd: "XCD",
    Xdr: "XDR",
    Xof: "XOF",
    Xpf: "XPF",
    Yer: "YER",
    Zar: "ZAR",
    Zmw: "ZMW",
    Zwd: "ZWD",
    Pts: "PTS",
  } as const;
/**
 * Currency code based on ISO 4217 standard
 */
export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponentPriceCurrencyCode =
  OpenEnum<
    typeof ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponentPriceCurrencyCode
  >;

/**
 * Price model
 */
export const ComponentPricePriceModel = {
  Flat: "FLAT",
  Tiered: "TIERED",
  Volume: "VOLUME",
  Stairstep: "STAIRSTEP",
} as const;
/**
 * Price model
 */
export type ComponentPricePriceModel = OpenEnum<
  typeof ComponentPricePriceModel
>;

/**
 * Defines whether the price is tax inclusive or not. Defaults to the system's Taxation setting
 */
export const ComponentPriceTaxModel = {
  TaxInclusive: "TAX_INCLUSIVE",
  TaxExclusive: "TAX_EXCLUSIVE",
} as const;
/**
 * Defines whether the price is tax inclusive or not. Defaults to the system's Taxation setting
 */
export type ComponentPriceTaxModel = OpenEnum<typeof ComponentPriceTaxModel>;

/**
 * The component's price. Required when the component's price is not inclusive
 */
export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponentPrice =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The price value
     */
    price?: number | undefined;
    /**
     * Price when service goes out goes out of contract. Applicable only when setting up a price for a termed service and as long as its price terms include a contract period. If not specified, then the service will still be invoiced with the same price when it goes out of contract
     */
    outContractPrice?: number | undefined;
    /**
     * Currency code based on ISO 4217 standard
     */
    currencyCode?:
      | ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponentPriceCurrencyCode
      | undefined;
    /**
     * Price model
     */
    priceModel?: ComponentPricePriceModel | undefined;
    /**
     * Number of tiers in the component's price
     */
    tiers?: number | undefined;
    /**
     * The first tier level's upper tier
     */
    upperTier?: number | undefined;
    /**
     * Defines whether the price is tax inclusive or not. Defaults to the system's Taxation setting
     */
    taxModel?: ComponentPriceTaxModel | undefined;
    /**
     * The label of the price
     */
    label?: string | undefined;
  };

/**
 * Currency code based on ISO 4217 standard
 */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationProductCurrencyCode =
  {
    Aed: "AED",
    Afn: "AFN",
    All: "ALL",
    Amd: "AMD",
    Ang: "ANG",
    Aoa: "AOA",
    Ars: "ARS",
    Aud: "AUD",
    Awg: "AWG",
    Azn: "AZN",
    Bam: "BAM",
    Bbd: "BBD",
    Bdt: "BDT",
    Bgn: "BGN",
    Bhd: "BHD",
    Bif: "BIF",
    Bmd: "BMD",
    Bnd: "BND",
    Bob: "BOB",
    Brl: "BRL",
    Bsd: "BSD",
    Btn: "BTN",
    Bwp: "BWP",
    Byr: "BYR",
    Bzd: "BZD",
    Cad: "CAD",
    Cdf: "CDF",
    Chf: "CHF",
    Clp: "CLP",
    Cny: "CNY",
    Cop: "COP",
    Crc: "CRC",
    Cuc: "CUC",
    Cup: "CUP",
    Cve: "CVE",
    Czk: "CZK",
    Djf: "DJF",
    Dkk: "DKK",
    Dop: "DOP",
    Dzd: "DZD",
    Egp: "EGP",
    Ern: "ERN",
    Etb: "ETB",
    Eur: "EUR",
    Fjd: "FJD",
    Fkp: "FKP",
    Gbp: "GBP",
    Gel: "GEL",
    Ggp: "GGP",
    Ghs: "GHS",
    Gip: "GIP",
    Gmd: "GMD",
    Gnf: "GNF",
    Gtq: "GTQ",
    Gyd: "GYD",
    Hkd: "HKD",
    Hnl: "HNL",
    Hrk: "HRK",
    Htg: "HTG",
    Huf: "HUF",
    Idr: "IDR",
    Ils: "ILS",
    Imp: "IMP",
    Inr: "INR",
    Iqd: "IQD",
    Irr: "IRR",
    Isk: "ISK",
    Jep: "JEP",
    Jmd: "JMD",
    Jod: "JOD",
    Jpy: "JPY",
    Kes: "KES",
    Kgs: "KGS",
    Khr: "KHR",
    Kmf: "KMF",
    Kpw: "KPW",
    Krw: "KRW",
    Kwd: "KWD",
    Kyd: "KYD",
    Kzt: "KZT",
    Lak: "LAK",
    Lbp: "LBP",
    Lkr: "LKR",
    Lrd: "LRD",
    Lsl: "LSL",
    Lyd: "LYD",
    Mad: "MAD",
    Mdl: "MDL",
    Mga: "MGA",
    Mkd: "MKD",
    Mmk: "MMK",
    Mnt: "MNT",
    Mop: "MOP",
    Mro: "MRO",
    Mur: "MUR",
    Mvr: "MVR",
    Mwk: "MWK",
    Mxn: "MXN",
    Myr: "MYR",
    Mzn: "MZN",
    Nad: "NAD",
    Ngn: "NGN",
    Nio: "NIO",
    Nok: "NOK",
    Npr: "NPR",
    Nzd: "NZD",
    Omr: "OMR",
    Pab: "PAB",
    Pen: "PEN",
    Pgk: "PGK",
    Php: "PHP",
    Pkr: "PKR",
    Pln: "PLN",
    Pyg: "PYG",
    Qar: "QAR",
    Ron: "RON",
    Rsd: "RSD",
    Rub: "RUB",
    Rwf: "RWF",
    Sar: "SAR",
    Sbd: "SBD",
    Scr: "SCR",
    Sdg: "SDG",
    Sek: "SEK",
    Sgd: "SGD",
    Shp: "SHP",
    Sll: "SLL",
    Sos: "SOS",
    Spl: "SPL",
    Srd: "SRD",
    Std: "STD",
    Svc: "SVC",
    Syp: "SYP",
    Szl: "SZL",
    Thb: "THB",
    Tjs: "TJS",
    Tmt: "TMT",
    Tnd: "TND",
    Top: "TOP",
    Try: "TRY",
    Ttd: "TTD",
    Tvd: "TVD",
    Twd: "TWD",
    Tzs: "TZS",
    Uah: "UAH",
    Ugx: "UGX",
    Usd: "USD",
    Uyu: "UYU",
    Uzs: "UZS",
    Vef: "VEF",
    Vnd: "VND",
    Vuv: "VUV",
    Wst: "WST",
    Xaf: "XAF",
    Xcd: "XCD",
    Xdr: "XDR",
    Xof: "XOF",
    Xpf: "XPF",
    Yer: "YER",
    Zar: "ZAR",
    Zmw: "ZMW",
    Zwd: "ZWD",
    Pts: "PTS",
  } as const;
/**
 * Currency code based on ISO 4217 standard
 */
export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationProductCurrencyCode =
  OpenEnum<
    typeof ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationProductCurrencyCode
  >;

/**
 * Price model
 */
export const ComponentProductPriceModel = {
  Flat: "FLAT",
  Tiered: "TIERED",
  Volume: "VOLUME",
  Stairstep: "STAIRSTEP",
} as const;
/**
 * Price model
 */
export type ComponentProductPriceModel = OpenEnum<
  typeof ComponentProductPriceModel
>;

/**
 * Defines whether the price is tax inclusive or not. Defaults to the system's Taxation setting
 */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationProductTaxModel =
  {
    TaxInclusive: "TAX_INCLUSIVE",
    TaxExclusive: "TAX_EXCLUSIVE",
  } as const;
/**
 * Defines whether the price is tax inclusive or not. Defaults to the system's Taxation setting
 */
export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationProductTaxModel =
  OpenEnum<
    typeof ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationProductTaxModel
  >;

/**
 * The component's pricing
 */
export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPricing =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The price value
     */
    price?: number | undefined;
    /**
     * Price when service goes out goes out of contract. Applicable only when setting up a price for a termed service and as long as its price terms include a contract period. If not specified, then the service will still be invoiced with the same price when it goes out of contract
     */
    outContractPrice?: number | undefined;
    /**
     * Currency code based on ISO 4217 standard
     */
    currencyCode?:
      | ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationProductCurrencyCode
      | undefined;
    /**
     * Price model
     */
    priceModel?: ComponentProductPriceModel | undefined;
    /**
     * Number of tiers in the component's price
     */
    tiers?: number | undefined;
    /**
     * The first tier level's upper tier
     */
    upperTier?: number | undefined;
    /**
     * Defines whether the price is tax inclusive or not. Defaults to the system's Taxation setting
     */
    taxModel?:
      | ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationProductTaxModel
      | undefined;
    /**
     * The label of the price
     */
    label?: string | undefined;
  };

export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationProduct =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * Product SKU
     */
    sku?: string | undefined;
    /**
     * Product name
     */
    name?: string | undefined;
    /**
     * Product description
     */
    description?: string | undefined;
    /**
     * In cases of changing an existing service bundle, the recommendation Web API also returns the list of components arelady included in the bundle in order to provide the ability to the subscriber to remove the components
     */
    isIncluded?: boolean | undefined;
    /**
     * The component's pricing
     */
    pricing?:
      | ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPricing
      | undefined;
    /**
     * Applicable only if the component is a Components Set. Indicates that the returned product is mandatory and must be included in a subscription ordering flow
     */
    mandatory?: boolean | undefined;
    /**
     * Applicable only if the component is a Components Set. Indicates that the returned product is the default and is preselected but can be removed
     */
    isDefault?: boolean | undefined;
  };

export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponent =
  {
    /**
     * Allowed components can be individual products or products of a specific type, family, component set or category
     */
    itemType?:
      | ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationItemType
      | undefined;
    /**
     * The component type's identifier. The identifier depends on the value of the "item_type" field
     */
    itemId?: string | undefined;
    /**
     * Name of product or product type/family/category/component set depending on item_type selection
     */
    name?: string | undefined;
    /**
     * The display name
     */
    displayName?: string | undefined;
    /**
     * Shows if the specified item is always included in the composition and can never be removed.
     */
    mandatory?: boolean | undefined;
    /**
     * Indicates whether the component will be billed once added to the subscription (if its price is not inclusive). When price is icnlusive, then the component's price/cost is included in the bundle's cost
     */
    priceInclusive?: boolean | undefined;
    /**
     * The minimum quantity of items added as components. Applicalbe if the item type is a product type/family/category or component set
     */
    minimumQuantity?: number | undefined;
    /**
     * The maximum allowed quantity of items added as components. Applicalbe if the item type is a product type/family/category or component set
     */
    maximumQuantity?: number | undefined;
    /**
     * The component's price. Required when the component's price is not inclusive
     */
    price?:
      | ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponentPrice
      | undefined;
    /**
     * Product SKU, applicable when the component's type is PRODUCT
     */
    sku?: string | undefined;
    /**
     * The component's description (e.g.. the product's description).
     */
    description?: string | undefined;
    /**
     * In cases of changing an existing service bundle, the recommendation Web API also returns the list of components arelady included in the bundle in order to provide the ability to the subscriber to remove the components
     */
    isIncluded?: boolean | undefined;
    /**
     * List of products that can be included in the flexible bundle. Applicable when the bundle's composition includes a type, family, category or component set. In such cases, the actual list of products having the composition's type is provided as a recommendation
     */
    products?:
      | Array<
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationProduct
      >
      | undefined;
  };

/**
 * Information about the creative type
 */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationUsageType =
  {
    Logo: "LOGO",
    Background: "BACKGROUND",
    Avatar: "AVATAR",
    Hero: "HERO",
    Marketing: "MARKETING",
    Attachment: "ATTACHMENT",
    Profileimage: "PROFILEIMAGE",
    AppleLockscreenIcon: "APPLE_LOCKSCREEN_ICON",
    AppleLogoImage: "APPLE_LOGO_IMAGE",
    AppleStripImage: "APPLE_STRIP_IMAGE",
    GoogleLogoImage: "GOOGLE_LOGO_IMAGE",
    GoogleStripImage: "GOOGLE_STRIP_IMAGE",
    LandingPageLogoImage: "LANDING_PAGE_LOGO_IMAGE",
    LandingPageHeaderImage: "LANDING_PAGE_HEADER_IMAGE",
    LandingPageBackgroundImage: "LANDING_PAGE_BACKGROUND_IMAGE",
    DeliveryImage: "DELIVERY_IMAGE",
    PickupImage: "PICKUP_IMAGE",
    DirectSaleImage: "DIRECT_SALE_IMAGE",
    WalletImage: "WALLET_IMAGE",
    LandingPageImage: "LANDING_PAGE_IMAGE",
    AppLogo: "APP_LOGO",
    PartnerLogo: "PARTNER_LOGO",
    Carousel: "CAROUSEL",
    Shortcut: "SHORTCUT",
    ShortcutImage: "SHORTCUT_IMAGE",
    EmbeddedLinkImage: "EMBEDDED_LINK_IMAGE",
    Image: "IMAGE",
    AppLoaderImage: "APP_LOADER_IMAGE",
    MobileBackgroundImage: "MOBILE_BACKGROUND_IMAGE",
  } as const;
/**
 * Information about the creative type
 */
export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationUsageType =
  OpenEnum<
    typeof ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationUsageType
  >;

export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationMedia =
  {
    /**
     * The transformed creative width
     */
    width?: number | undefined;
    /**
     * The transformed creative height
     */
    height?: number | undefined;
    /**
     * The transformed creative URL
     */
    url?: string | undefined;
  };

export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationCreative =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * the identifier of media
     */
    mediaGroupId?: string | undefined;
    /**
     * Information about the creative type
     */
    usageType?:
      | ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationUsageType
      | undefined;
    /**
     * The creative width
     */
    width?: number | undefined;
    /**
     * The creative height
     */
    height?: number | undefined;
    /**
     * The creative format
     */
    format?: string | undefined;
    /**
     * The creative content URL
     */
    url?: string | undefined;
    /**
     * The creative public identifier
     */
    publicId?: string | undefined;
    /**
     * The media identifier
     */
    mediaId?: string | undefined;
    /**
     * The creative caption used in cases where usage_type=CAROUSEL
     */
    caption?: string | undefined;
    /**
     * The creative sort order used in cases where usage_type=CAROUSEL
     */
    sortOrder?: number | undefined;
    /**
     * Information about the creative transformations
     */
    media?:
      | Array<
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationMedia
      >
      | undefined;
  };

export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationIncludedOneTimeService =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * The entity name
     */
    name?: string | undefined;
    /**
     * The entity sku
     */
    sku?: string | undefined;
  };

export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContent =
  {
    /**
     * The entity identifier
     */
    id?: string | undefined;
    /**
     * Product SKU
     */
    sku?: string | undefined;
    /**
     * Product name
     */
    name?: string | undefined;
    /**
     * Product descriptiption
     */
    description?: string | undefined;
    /**
     * Product Composition
     */
    composition?:
      | ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComposition
      | undefined;
    /**
     * Determines whether a service is managed as a single quantity or as separate, independently managed instances on a subscription
     */
    instanceModel?:
      | ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationInstanceModel
      | undefined;
    /**
     * List of applicable prices for the recommended service
     */
    prices?:
      | Array<
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPrice
      >
      | undefined;
    /**
     * Returned only when the recommended service is classified as a Flexible bundle
     */
    components?:
      | Array<
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponent
      >
      | undefined;
    /**
     * Details about creatives. A creative is an object that contains all the data required for visually rendering an image responsively, such as the initial image and a number of scale versions of it (srcset)
     */
    creatives?:
      | Array<
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationCreative
      >
      | undefined;
    /**
     * A list of one-time services which extend the behaviour of a termed service product so whenever the termed service is added/renewed, then all related one-time service are added to the same subscription. Only one-time services can be specified and applicable only for flat, termed services.
     */
    includedOneTimeServices?:
      | Array<
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationIncludedOneTimeService
      >
      | undefined;
  };

/**
 * OK
 */
export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationResponse =
  {
    paging?:
      | ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPaging
      | undefined;
    content?:
      | Array<
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContent
      >
      | undefined;
  };

/** @internal */
export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationSecurity$Outbound =
  {
    Secret_API_key?: string | undefined;
    authorization?: string | undefined;
  };

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationSecurity$outboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationSecurity$Outbound,
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationSecurity
  > = z.pipe(
    z.object({
      secretAPIKey: z.optional(z.string()),
      authorization: z.optional(z.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        secretAPIKey: "Secret_API_key",
      });
    }),
  );

export function comCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationSecurityToJSON(
  comCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationSecurity:
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationSecurity,
): string {
  return JSON.stringify(
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationSecurity$outboundSchema
      .parse(
        comCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationSecurity,
      ),
  );
}

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationOrder$outboundSchema:
  z.ZodMiniEnum<
    typeof ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationOrder
  > = z.enum(
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationOrder,
  );

/** @internal */
export type ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationRequest$Outbound =
  {
    account_id?: string | undefined;
    billing_model?: string | undefined;
    billing_period_duration?: number | undefined;
    billing_period_uot?: string | undefined;
    contact_id?: string | undefined;
    include_components?: boolean | undefined;
    include_creatives?: boolean | undefined;
    organisation_id?: string | undefined;
    price_terms_id?: string | undefined;
    product_id?: string | undefined;
    search_value?: string | undefined;
    service_id?: string | undefined;
    subscription_id?: string | undefined;
    type_composition?: string | undefined;
    include_total: boolean;
    order: string;
    page: number;
    size: number;
    sort: string;
  };

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationRequest$outboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationRequest$Outbound,
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationRequest
  > = z.pipe(
    z.object({
      accountId: z.optional(z.string()),
      billingModel: z.optional(z.string()),
      billingPeriodDuration: z.optional(z.int()),
      billingPeriodUot: z.optional(z.string()),
      contactId: z.optional(z.string()),
      includeComponents: z.optional(z.boolean()),
      includeCreatives: z.optional(z.boolean()),
      organisationId: z.optional(z.string()),
      priceTermsId: z.optional(z.string()),
      productId: z.optional(z.string()),
      searchValue: z.optional(z.string()),
      serviceId: z.optional(z.string()),
      subscriptionId: z.optional(z.string()),
      typeComposition: z.optional(z.string()),
      includeTotal: z._default(z.boolean(), false),
      order: z._default(
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationOrder$outboundSchema,
        "DESC",
      ),
      page: z._default(z.int(), 1),
      size: z._default(z.int(), 10),
      sort: z._default(z.string(), "CREATED_DATE"),
    }),
    z.transform((v) => {
      return remap$(v, {
        accountId: "account_id",
        billingModel: "billing_model",
        billingPeriodDuration: "billing_period_duration",
        billingPeriodUot: "billing_period_uot",
        contactId: "contact_id",
        includeComponents: "include_components",
        includeCreatives: "include_creatives",
        organisationId: "organisation_id",
        priceTermsId: "price_terms_id",
        productId: "product_id",
        searchValue: "search_value",
        serviceId: "service_id",
        subscriptionId: "subscription_id",
        typeComposition: "type_composition",
        includeTotal: "include_total",
      });
    }),
  );

export function comCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationRequestToJSON(
  comCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationRequest:
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationRequest,
): string {
  return JSON.stringify(
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationRequest$outboundSchema
      .parse(
        comCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationRequest,
      ),
  );
}

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPaging$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPaging,
    unknown
  > = z.pipe(
    z.object({
      page: types.optional(types.number()),
      size: types.optional(types.number()),
      total: types.optional(types.number()),
      has_more: types.optional(types.boolean()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "has_more": "hasMore",
      });
    }),
  );

export function comCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPagingFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPaging,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPaging$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPaging' from JSON`,
  );
}

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComposition$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComposition,
    unknown
  > = openEnums.inboundSchema(
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComposition,
  );

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationInstanceModel$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationInstanceModel,
    unknown
  > = openEnums.inboundSchema(
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationInstanceModel,
  );

/** @internal */
export const PricePriceModel$inboundSchema: z.ZodMiniType<
  PricePriceModel,
  unknown
> = openEnums.inboundSchema(PricePriceModel);

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceCurrencyCode$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceCurrencyCode,
    unknown
  > = openEnums.inboundSchema(
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceCurrencyCode,
  );

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceTaxModel$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceTaxModel,
    unknown
  > = openEnums.inboundSchema(
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceTaxModel,
  );

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationBillingModel$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationBillingModel,
    unknown
  > = openEnums.inboundSchema(
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationBillingModel,
  );

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationBillingPeriodUot$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationBillingPeriodUot,
    unknown
  > = openEnums.inboundSchema(
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationBillingPeriodUot,
  );

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationBillingPeriod$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationBillingPeriod,
    unknown
  > = z.object({
    duration: types.optional(types.number()),
    uot: types.optional(
      ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationBillingPeriodUot$inboundSchema,
    ),
  });

export function comCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationBillingPeriodFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationBillingPeriod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationBillingPeriod$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationBillingPeriod' from JSON`,
  );
}

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationTrialPeriodUot$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationTrialPeriodUot,
    unknown
  > = openEnums.inboundSchema(
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationTrialPeriodUot,
  );

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationTrialPeriod$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationTrialPeriod,
    unknown
  > = z.object({
    duration: types.optional(types.number()),
    uot: types.optional(
      ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationTrialPeriodUot$inboundSchema,
    ),
  });

export function comCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationTrialPeriodFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationTrialPeriod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationTrialPeriod$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationTrialPeriod' from JSON`,
  );
}

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContractPeriodUot$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContractPeriodUot,
    unknown
  > = openEnums.inboundSchema(
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContractPeriodUot,
  );

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContractPeriod$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContractPeriod,
    unknown
  > = z.object({
    duration: types.optional(types.number()),
    uot: types.optional(
      ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContractPeriodUot$inboundSchema,
    ),
  });

export function comCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContractPeriodFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContractPeriod,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContractPeriod$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContractPeriod' from JSON`,
  );
}

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceTerms$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceTerms,
    unknown
  > = z.pipe(
    z.object({
      billing_model: types.optional(
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationBillingModel$inboundSchema,
      ),
      billing_period: types.optional(z.lazy(() =>
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationBillingPeriod$inboundSchema
      )),
      trial_period: types.optional(z.lazy(() =>
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationTrialPeriod$inboundSchema
      )),
      contract_period: types.optional(z.lazy(() =>
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContractPeriod$inboundSchema
      )),
      auto_renew: types.optional(types.boolean()),
      termed_period: types.optional(types.number()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "billing_model": "billingModel",
        "billing_period": "billingPeriod",
        "trial_period": "trialPeriod",
        "contract_period": "contractPeriod",
        "auto_renew": "autoRenew",
        "termed_period": "termedPeriod",
      });
    }),
  );

export function comCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceTermsFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceTerms,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceTerms$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceTerms' from JSON`,
  );
}

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPrice$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPrice,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      label: types.optional(types.string()),
      is_default: types.optional(types.boolean()),
      current_price: types.optional(types.boolean()),
      price_model: types.optional(PricePriceModel$inboundSchema),
      tiers: types.optional(types.number()),
      upper_tier: types.optional(types.number()),
      price: types.optional(types.number()),
      out_contract_price: types.optional(types.number()),
      currency_code: types.optional(
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceCurrencyCode$inboundSchema,
      ),
      tax_model: types.optional(
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceTaxModel$inboundSchema,
      ),
      price_terms: types.optional(z.lazy(() =>
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceTerms$inboundSchema
      )),
    }),
    z.transform((v) => {
      return remap$(v, {
        "is_default": "isDefault",
        "current_price": "currentPrice",
        "price_model": "priceModel",
        "upper_tier": "upperTier",
        "out_contract_price": "outContractPrice",
        "currency_code": "currencyCode",
        "tax_model": "taxModel",
        "price_terms": "priceTerms",
      });
    }),
  );

export function comCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPriceFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPrice,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPrice$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPrice' from JSON`,
  );
}

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationItemType$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationItemType,
    unknown
  > = openEnums.inboundSchema(
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationItemType,
  );

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponentPriceCurrencyCode$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponentPriceCurrencyCode,
    unknown
  > = openEnums.inboundSchema(
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponentPriceCurrencyCode,
  );

/** @internal */
export const ComponentPricePriceModel$inboundSchema: z.ZodMiniType<
  ComponentPricePriceModel,
  unknown
> = openEnums.inboundSchema(ComponentPricePriceModel);

/** @internal */
export const ComponentPriceTaxModel$inboundSchema: z.ZodMiniType<
  ComponentPriceTaxModel,
  unknown
> = openEnums.inboundSchema(ComponentPriceTaxModel);

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponentPrice$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponentPrice,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      price: types.optional(types.number()),
      out_contract_price: types.optional(types.number()),
      currency_code: types.optional(
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponentPriceCurrencyCode$inboundSchema,
      ),
      price_model: types.optional(ComponentPricePriceModel$inboundSchema),
      tiers: types.optional(types.number()),
      upper_tier: types.optional(types.number()),
      tax_model: types.optional(ComponentPriceTaxModel$inboundSchema),
      label: types.optional(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "out_contract_price": "outContractPrice",
        "currency_code": "currencyCode",
        "price_model": "priceModel",
        "upper_tier": "upperTier",
        "tax_model": "taxModel",
      });
    }),
  );

export function comCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponentPriceFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponentPrice,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponentPrice$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponentPrice' from JSON`,
  );
}

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationProductCurrencyCode$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationProductCurrencyCode,
    unknown
  > = openEnums.inboundSchema(
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationProductCurrencyCode,
  );

/** @internal */
export const ComponentProductPriceModel$inboundSchema: z.ZodMiniType<
  ComponentProductPriceModel,
  unknown
> = openEnums.inboundSchema(ComponentProductPriceModel);

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationProductTaxModel$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationProductTaxModel,
    unknown
  > = openEnums.inboundSchema(
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationProductTaxModel,
  );

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPricing$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPricing,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      price: types.optional(types.number()),
      out_contract_price: types.optional(types.number()),
      currency_code: types.optional(
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationProductCurrencyCode$inboundSchema,
      ),
      price_model: types.optional(ComponentProductPriceModel$inboundSchema),
      tiers: types.optional(types.number()),
      upper_tier: types.optional(types.number()),
      tax_model: types.optional(
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationProductTaxModel$inboundSchema,
      ),
      label: types.optional(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "out_contract_price": "outContractPrice",
        "currency_code": "currencyCode",
        "price_model": "priceModel",
        "upper_tier": "upperTier",
        "tax_model": "taxModel",
      });
    }),
  );

export function comCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPricingFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPricing,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPricing$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPricing' from JSON`,
  );
}

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationProduct$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationProduct,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      sku: types.optional(types.string()),
      name: types.optional(types.string()),
      description: types.optional(types.string()),
      is_included: types.optional(types.boolean()),
      pricing: types.optional(z.lazy(() =>
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPricing$inboundSchema
      )),
      mandatory: types.optional(types.boolean()),
      is_default: types.optional(types.boolean()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "is_included": "isIncluded",
        "is_default": "isDefault",
      });
    }),
  );

export function comCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationProductFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationProduct,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationProduct$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationProduct' from JSON`,
  );
}

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponent$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponent,
    unknown
  > = z.pipe(
    z.object({
      item_type: types.optional(
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationItemType$inboundSchema,
      ),
      item_id: types.optional(types.string()),
      name: types.optional(types.string()),
      display_name: types.optional(types.string()),
      mandatory: types.optional(types.boolean()),
      price_inclusive: types.optional(types.boolean()),
      minimum_quantity: types.optional(types.number()),
      maximum_quantity: types.optional(types.number()),
      price: types.optional(z.lazy(() =>
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponentPrice$inboundSchema
      )),
      sku: types.optional(types.string()),
      description: types.optional(types.string()),
      is_included: types.optional(types.boolean()),
      products: types.optional(z.array(z.lazy(() =>
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationProduct$inboundSchema
      ))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "item_type": "itemType",
        "item_id": "itemId",
        "display_name": "displayName",
        "price_inclusive": "priceInclusive",
        "minimum_quantity": "minimumQuantity",
        "maximum_quantity": "maximumQuantity",
        "is_included": "isIncluded",
      });
    }),
  );

export function comCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponentFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponent$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponent' from JSON`,
  );
}

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationUsageType$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationUsageType,
    unknown
  > = openEnums.inboundSchema(
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationUsageType,
  );

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationMedia$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationMedia,
    unknown
  > = z.object({
    width: types.optional(types.number()),
    height: types.optional(types.number()),
    url: types.optional(types.string()),
  });

export function comCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationMediaFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationMedia,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationMedia$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationMedia' from JSON`,
  );
}

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationCreative$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationCreative,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      media_group_id: types.optional(types.string()),
      usage_type: types.optional(
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationUsageType$inboundSchema,
      ),
      width: types.optional(types.number()),
      height: types.optional(types.number()),
      format: types.optional(types.string()),
      url: types.optional(types.string()),
      public_id: types.optional(types.string()),
      media_id: types.optional(types.string()),
      caption: types.optional(types.string()),
      sort_order: types.optional(types.number()),
      media: types.optional(z.array(z.lazy(() =>
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationMedia$inboundSchema
      ))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "media_group_id": "mediaGroupId",
        "usage_type": "usageType",
        "public_id": "publicId",
        "media_id": "mediaId",
        "sort_order": "sortOrder",
      });
    }),
  );

export function comCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationCreativeFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationCreative,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationCreative$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationCreative' from JSON`,
  );
}

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationIncludedOneTimeService$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationIncludedOneTimeService,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    sku: types.optional(types.string()),
  });

export function comCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationIncludedOneTimeServiceFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationIncludedOneTimeService,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationIncludedOneTimeService$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationIncludedOneTimeService' from JSON`,
  );
}

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContent$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContent,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      sku: types.optional(types.string()),
      name: types.optional(types.string()),
      description: types.optional(types.string()),
      composition: types.optional(
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComposition$inboundSchema,
      ),
      instance_model: types.optional(
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationInstanceModel$inboundSchema,
      ),
      prices: types.optional(z.array(z.lazy(() =>
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPrice$inboundSchema
      ))),
      components: types.optional(z.array(z.lazy(() =>
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationComponent$inboundSchema
      ))),
      creatives: types.optional(z.array(z.lazy(() =>
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationCreative$inboundSchema
      ))),
      included_one_time_services: types.optional(z.array(z.lazy(() =>
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationIncludedOneTimeService$inboundSchema
      ))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "instance_model": "instanceModel",
        "included_one_time_services": "includedOneTimeServices",
      });
    }),
  );

export function comCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContentFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContent$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContent' from JSON`,
  );
}

/** @internal */
export const ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationResponse$inboundSchema:
  z.ZodMiniType<
    ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationResponse,
    unknown
  > = z.object({
    paging: types.optional(
      z.lazy(() =>
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationPaging$inboundSchema
      ),
    ),
    content: types.optional(
      z.array(z.lazy(() =>
        ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationContent$inboundSchema
      )),
    ),
  });

export function comCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationResponse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmServiceRecommendationSelfServiceResourceGetServiceRecommendationResponse' from JSON`,
  );
}
