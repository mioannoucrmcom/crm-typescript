/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 * @generated-id: 61a0f3a39aa5
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { ClosedEnum, OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

export type ComCrmApplicationSelfServiceResourceGetApplicationSecurity = {
  publicAPIKey: string;
};

export type ComCrmApplicationSelfServiceResourceGetApplicationRequest = {
  /**
   * Use cloud name to retrieve Web APP settings.
   */
  cloudName?: string | undefined;
  /**
   * The platform application identifier
   */
  platformAppId: string;
  /**
   * The application version number
   */
  version?: string | undefined;
};

/**
 * The application type:
 *
 * @remarks
 *  * `NATIVE` - Mobile Consumer Applications (Apple and Google)
 *  * `NATIVE_MERCHANT` - Mobile Merchant Applications (Apple and Google)
 *  * `WEB` - Web Portal
 *  * `CAPTIVE` - Captive Portal
 *  * `CONSUMER_APP` - Consumer App (Portal and App)
 */
export const ComCrmApplicationSelfServiceResourceGetApplicationType = {
  Native: "NATIVE",
  NativeMerchant: "NATIVE_MERCHANT",
  Web: "WEB",
  Captive: "CAPTIVE",
  ConsumerApp: "CONSUMER_APP",
} as const;
/**
 * The application type:
 *
 * @remarks
 *  * `NATIVE` - Mobile Consumer Applications (Apple and Google)
 *  * `NATIVE_MERCHANT` - Mobile Merchant Applications (Apple and Google)
 *  * `WEB` - Web Portal
 *  * `CAPTIVE` - Captive Portal
 *  * `CONSUMER_APP` - Consumer App (Portal and App)
 */
export type ComCrmApplicationSelfServiceResourceGetApplicationType = OpenEnum<
  typeof ComCrmApplicationSelfServiceResourceGetApplicationType
>;

/**
 * Defines the component on which the color will be applied
 */
export const ColourType = {
  LandingBackground: "LANDING_BACKGROUND",
  LandingCard: "LANDING_CARD",
  LandingText: "LANDING_TEXT",
  ScreenCard: "SCREEN_CARD",
  ScreenButton: "SCREEN_BUTTON",
  ScreenWallet: "SCREEN_WALLET",
  LegacyBackground: "LEGACY_BACKGROUND",
  LegacyButton: "LEGACY_BUTTON",
  LegacyCard: "LEGACY_CARD",
  PrimaryColour: "PRIMARY_COLOUR",
  SecondaryColour: "SECONDARY_COLOUR",
} as const;
/**
 * Defines the component on which the color will be applied
 */
export type ColourType = OpenEnum<typeof ColourType>;

export type Colour = {
  /**
   * Defines the component on which the color will be applied
   */
  type?: ColourType | undefined;
  /**
   * The color (hex) code
   */
  value?: string | undefined;
};

/**
 * Defines the component on which the font will be applied
 */
export const FontType = {
  Text: "TEXT",
} as const;
/**
 * Defines the component on which the font will be applied
 */
export type FontType = ClosedEnum<typeof FontType>;

/**
 * The text font style that will be used by the application
 */
export const FontEnum = {
  SanFrancisco: "San Francisco",
  Roboto: "Roboto",
  Helvetica: "Helvetica",
  OpenSans: "Open Sans",
  Poppins: "Poppins",
  Georgia: "Georgia",
  Gilroy: "Gilroy",
} as const;
/**
 * The text font style that will be used by the application
 */
export type FontEnum = OpenEnum<typeof FontEnum>;

export type Font = {
  /**
   * Defines the component on which the font will be applied
   */
  type?: FontType | undefined;
  /**
   * The text font style that will be used by the application
   */
  font?: FontEnum | undefined;
};

/**
 * The application layout
 */
export const HomepageLayout = {
  Layout1: "LAYOUT1",
  Layout2: "LAYOUT2",
  Layout3: "LAYOUT3",
  Layout4: "LAYOUT4",
  Layout5: "LAYOUT5",
} as const;
/**
 * The application layout
 */
export type HomepageLayout = OpenEnum<typeof HomepageLayout>;

/**
 * The application ordering layout
 */
export const OrderingLayout = {
  Layout1: "LAYOUT1",
  Layout2: "LAYOUT2",
  Layout3: "LAYOUT3",
  Layout4: "LAYOUT4",
  Layout5: "LAYOUT5",
} as const;
/**
 * The application ordering layout
 */
export type OrderingLayout = OpenEnum<typeof OrderingLayout>;

/**
 * JSON scripts contaning specific mapping of existing settings to particular elements of the app. Used in special circumstances to allow fine tuning the app without rebuilding it. This is maintatined solely by front-end integrations and is not visible on the back-end user interface.
 */
export type AdvancedSettings = {
  /**
   * JSON script contaning specific mapping of existing colour settings to particular elements of the app
   */
  colours?: string | undefined;
  /**
   * JSON script contaning specific mapping of existing layout & component settings to particular elements of the app
   */
  layoutComponents?: string | undefined;
};

/**
 * Details about the app appearance
 */
export type Appearance = {
  /**
   * The application color style
   */
  colours?: Array<Colour> | undefined;
  /**
   * The application text font style
   */
  fonts?: Array<Font> | undefined;
  /**
   * The colour scheme of the app
   */
  darkMode: boolean;
  /**
   * The application layout
   */
  homepageLayout: HomepageLayout;
  /**
   * The application ordering layout
   */
  orderingLayout: OrderingLayout;
  /**
   * JSON scripts contaning specific mapping of existing settings to particular elements of the app. Used in special circumstances to allow fine tuning the app without rebuilding it. This is maintatined solely by front-end integrations and is not visible on the back-end user interface.
   */
  advancedSettings?: AdvancedSettings | undefined;
};

/**
 * The content type
 */
export const InformationType = {
  About: "ABOUT",
  TermsConditions: "TERMS_CONDITIONS",
  PrivacyPolicy: "PRIVACY_POLICY",
  Faqs: "FAQS",
} as const;
/**
 * The content type
 */
export type InformationType = OpenEnum<typeof InformationType>;

export type ComCrmApplicationSelfServiceResourceGetApplicationContent = {
  /**
   * The content type
   */
  type?: InformationType | undefined;
  /**
   * The detail URL endpoint (URL or Content is required)
   */
  url?: string | undefined;
  /**
   * The detail rich content (URL or Content is required)
   */
  richContent?: string | undefined;
};

/**
 * The contact us phone number country code
 */
export const ComCrmApplicationSelfServiceResourceGetApplicationCountryCode = {
  Abw: "ABW",
  Afg: "AFG",
  Ago: "AGO",
  Aia: "AIA",
  Ala: "ALA",
  Alb: "ALB",
  And: "AND",
  Ant: "ANT",
  Are: "ARE",
  Arg: "ARG",
  Arm: "ARM",
  Asm: "ASM",
  Ata: "ATA",
  Atf: "ATF",
  Atg: "ATG",
  Aus: "AUS",
  Aut: "AUT",
  Aze: "AZE",
  Bdi: "BDI",
  Bel: "BEL",
  Ben: "BEN",
  Bes: "BES",
  Bfa: "BFA",
  Bgd: "BGD",
  Bgr: "BGR",
  Bhr: "BHR",
  Bhs: "BHS",
  Bih: "BIH",
  Blm: "BLM",
  Blr: "BLR",
  Blz: "BLZ",
  Bmu: "BMU",
  Bol: "BOL",
  Bra: "BRA",
  Brb: "BRB",
  Brn: "BRN",
  Btn: "BTN",
  Bvt: "BVT",
  Bwa: "BWA",
  Caf: "CAF",
  Can: "CAN",
  Cck: "CCK",
  Che: "CHE",
  Chl: "CHL",
  Chn: "CHN",
  Civ: "CIV",
  Cmr: "CMR",
  Cod: "COD",
  Cog: "COG",
  Cok: "COK",
  Col: "COL",
  Com: "COM",
  Cpv: "CPV",
  Cri: "CRI",
  Cub: "CUB",
  Cuw: "CUW",
  Cxr: "CXR",
  Cym: "CYM",
  Cyp: "CYP",
  Cze: "CZE",
  Deu: "DEU",
  Dji: "DJI",
  Dma: "DMA",
  Dnk: "DNK",
  Dom: "DOM",
  Dza: "DZA",
  Ecu: "ECU",
  Egy: "EGY",
  Eri: "ERI",
  Esh: "ESH",
  Esp: "ESP",
  Est: "EST",
  Eth: "ETH",
  Fin: "FIN",
  Fji: "FJI",
  Flk: "FLK",
  Fra: "FRA",
  Fro: "FRO",
  Fsm: "FSM",
  Gab: "GAB",
  Gbr: "GBR",
  Geo: "GEO",
  Ggy: "GGY",
  Gha: "GHA",
  Gib: "GIB",
  Gin: "GIN",
  Glp: "GLP",
  Gmb: "GMB",
  Gnb: "GNB",
  Gnq: "GNQ",
  Grc: "GRC",
  Grd: "GRD",
  Grl: "GRL",
  Gtm: "GTM",
  Guf: "GUF",
  Gum: "GUM",
  Guy: "GUY",
  Hkg: "HKG",
  Hmd: "HMD",
  Hnd: "HND",
  Hrv: "HRV",
  Hti: "HTI",
  Hun: "HUN",
  Idn: "IDN",
  Imn: "IMN",
  Ind: "IND",
  Iot: "IOT",
  Irl: "IRL",
  Irn: "IRN",
  Irq: "IRQ",
  Isl: "ISL",
  Isr: "ISR",
  Ita: "ITA",
  Jam: "JAM",
  Jey: "JEY",
  Jor: "JOR",
  Jpn: "JPN",
  Kaz: "KAZ",
  Ken: "KEN",
  Kgz: "KGZ",
  Khm: "KHM",
  Kir: "KIR",
  Kna: "KNA",
  Kor: "KOR",
  Kwt: "KWT",
  Lao: "LAO",
  Lbn: "LBN",
  Lbr: "LBR",
  Lby: "LBY",
  Lca: "LCA",
  Lie: "LIE",
  Lka: "LKA",
  Lso: "LSO",
  Ltu: "LTU",
  Lux: "LUX",
  Lva: "LVA",
  Mac: "MAC",
  Maf: "MAF",
  Mar: "MAR",
  Mco: "MCO",
  Mda: "MDA",
  Mdg: "MDG",
  Mdv: "MDV",
  Mex: "MEX",
  Mhl: "MHL",
  Mkd: "MKD",
  Mli: "MLI",
  Mlt: "MLT",
  Mmr: "MMR",
  Mne: "MNE",
  Mng: "MNG",
  Mnp: "MNP",
  Moz: "MOZ",
  Mrt: "MRT",
  Msr: "MSR",
  Mtq: "MTQ",
  Mus: "MUS",
  Mwi: "MWI",
  Mys: "MYS",
  Myt: "MYT",
  Nam: "NAM",
  Ncl: "NCL",
  Ner: "NER",
  Nfk: "NFK",
  Nga: "NGA",
  Nic: "NIC",
  Niu: "NIU",
  Nld: "NLD",
  Nor: "NOR",
  Npl: "NPL",
  Nru: "NRU",
  Nzl: "NZL",
  Omn: "OMN",
  Pak: "PAK",
  Pan: "PAN",
  Pcn: "PCN",
  Per: "PER",
  Phl: "PHL",
  Plw: "PLW",
  Png: "PNG",
  Pol: "POL",
  Pri: "PRI",
  Prk: "PRK",
  Prt: "PRT",
  Pry: "PRY",
  Pse: "PSE",
  Pyf: "PYF",
  Qat: "QAT",
  Reu: "REU",
  Rks: "RKS",
  Rou: "ROU",
  Rus: "RUS",
  Rwa: "RWA",
  Sau: "SAU",
  Sdn: "SDN",
  Sen: "SEN",
  Sgp: "SGP",
  Sgs: "SGS",
  Shn: "SHN",
  Sjm: "SJM",
  Slb: "SLB",
  Sle: "SLE",
  Slv: "SLV",
  Smr: "SMR",
  Som: "SOM",
  Spm: "SPM",
  Srb: "SRB",
  Ssd: "SSD",
  Stp: "STP",
  Sur: "SUR",
  Svk: "SVK",
  Svn: "SVN",
  Swe: "SWE",
  Swz: "SWZ",
  Sxm: "SXM",
  Syc: "SYC",
  Syr: "SYR",
  Tca: "TCA",
  Tcd: "TCD",
  Tgo: "TGO",
  Tha: "THA",
  Tjk: "TJK",
  Tkl: "TKL",
  Tkm: "TKM",
  Tls: "TLS",
  Ton: "TON",
  Tto: "TTO",
  Tun: "TUN",
  Tur: "TUR",
  Tuv: "TUV",
  Twn: "TWN",
  Tza: "TZA",
  Uga: "UGA",
  Ukr: "UKR",
  Umi: "UMI",
  Ury: "URY",
  Usa: "USA",
  Uzb: "UZB",
  Vat: "VAT",
  Vct: "VCT",
  Ven: "VEN",
  Vgb: "VGB",
  Vir: "VIR",
  Vnm: "VNM",
  Vut: "VUT",
  Wlf: "WLF",
  Wsm: "WSM",
  Yem: "YEM",
  Zaf: "ZAF",
  Zmb: "ZMB",
  Zwe: "ZWE",
} as const;
/**
 * The contact us phone number country code
 */
export type ComCrmApplicationSelfServiceResourceGetApplicationCountryCode =
  OpenEnum<
    typeof ComCrmApplicationSelfServiceResourceGetApplicationCountryCode
  >;

/**
 * The contact us phone
 */
export type ComCrmApplicationSelfServiceResourceGetApplicationPhone = {
  /**
   * The contact us phone number country code
   */
  countryCode?:
    | ComCrmApplicationSelfServiceResourceGetApplicationCountryCode
    | undefined;
  /**
   * The contact us phone number
   */
  number?: string | null | undefined;
};

/**
 * The application "contact us" details
 */
export type ContactUs = {
  /**
   * The contact us email address
   */
  emailAddress?: string | null | undefined;
  /**
   * The contact us phone
   */
  phone?: ComCrmApplicationSelfServiceResourceGetApplicationPhone | undefined;
  /**
   * The contact us website
   */
  website?: string | null | undefined;
};

/**
 * Defines the app details (about, terms and conditions, privacy policy)
 */
export type Information = {
  /**
   * The application content information
   */
  content?:
    | Array<ComCrmApplicationSelfServiceResourceGetApplicationContent>
    | undefined;
  /**
   * The application "contact us" details
   */
  contactUs?: ContactUs | undefined;
};

/**
 * The contact's wallet code is used to uniquely identify them on front-end devices. This code can be in the form of a barcode or QR code
 */
export const WalletCodeFormat = {
  Barcode: "BARCODE",
  QrCode: "QR_CODE",
} as const;
/**
 * The contact's wallet code is used to uniquely identify them on front-end devices. This code can be in the form of a barcode or QR code
 */
export type WalletCodeFormat = OpenEnum<typeof WalletCodeFormat>;

/**
 * The contact attribute
 */
export const ProfileType = {
  Birthdate: "BIRTHDATE",
  Nameday: "NAMEDAY",
  Gender: "GENDER",
} as const;
/**
 * The contact attribute
 */
export type ProfileType = OpenEnum<typeof ProfileType>;

export type Profile = {
  /**
   * The contact attribute
   */
  type?: ProfileType | undefined;
  /**
   * Defines if the profile attribute is supported or not
   */
  isSupported?: boolean | undefined;
};

/**
 * Defines whether communities (relationships between contacts) features will be available
 */
export type Communities = {
  /**
   * Defines whether communities is supported
   */
  isSupported?: boolean | undefined;
};

export type ComCrmApplicationSelfServiceResourceGetApplicationCountry = {
  country?: string | undefined;
};

/**
 * Name of country
 */
export const ComCrmApplicationSelfServiceResourceGetApplicationCountryCallingCodeCountry =
  {
    Abw: "ABW",
    Afg: "AFG",
    Ago: "AGO",
    Aia: "AIA",
    Ala: "ALA",
    Alb: "ALB",
    And: "AND",
    Ant: "ANT",
    Are: "ARE",
    Arg: "ARG",
    Arm: "ARM",
    Asm: "ASM",
    Ata: "ATA",
    Atf: "ATF",
    Atg: "ATG",
    Aus: "AUS",
    Aut: "AUT",
    Aze: "AZE",
    Bdi: "BDI",
    Bel: "BEL",
    Ben: "BEN",
    Bes: "BES",
    Bfa: "BFA",
    Bgd: "BGD",
    Bgr: "BGR",
    Bhr: "BHR",
    Bhs: "BHS",
    Bih: "BIH",
    Blm: "BLM",
    Blr: "BLR",
    Blz: "BLZ",
    Bmu: "BMU",
    Bol: "BOL",
    Bra: "BRA",
    Brb: "BRB",
    Brn: "BRN",
    Btn: "BTN",
    Bvt: "BVT",
    Bwa: "BWA",
    Caf: "CAF",
    Can: "CAN",
    Cck: "CCK",
    Che: "CHE",
    Chl: "CHL",
    Chn: "CHN",
    Civ: "CIV",
    Cmr: "CMR",
    Cod: "COD",
    Cog: "COG",
    Cok: "COK",
    Col: "COL",
    Com: "COM",
    Cpv: "CPV",
    Cri: "CRI",
    Cub: "CUB",
    Cuw: "CUW",
    Cxr: "CXR",
    Cym: "CYM",
    Cyp: "CYP",
    Cze: "CZE",
    Deu: "DEU",
    Dji: "DJI",
    Dma: "DMA",
    Dnk: "DNK",
    Dom: "DOM",
    Dza: "DZA",
    Ecu: "ECU",
    Egy: "EGY",
    Eri: "ERI",
    Esh: "ESH",
    Esp: "ESP",
    Est: "EST",
    Eth: "ETH",
    Fin: "FIN",
    Fji: "FJI",
    Flk: "FLK",
    Fra: "FRA",
    Fro: "FRO",
    Fsm: "FSM",
    Gab: "GAB",
    Gbr: "GBR",
    Geo: "GEO",
    Ggy: "GGY",
    Gha: "GHA",
    Gib: "GIB",
    Gin: "GIN",
    Glp: "GLP",
    Gmb: "GMB",
    Gnb: "GNB",
    Gnq: "GNQ",
    Grc: "GRC",
    Grd: "GRD",
    Grl: "GRL",
    Gtm: "GTM",
    Guf: "GUF",
    Gum: "GUM",
    Guy: "GUY",
    Hkg: "HKG",
    Hmd: "HMD",
    Hnd: "HND",
    Hrv: "HRV",
    Hti: "HTI",
    Hun: "HUN",
    Idn: "IDN",
    Imn: "IMN",
    Ind: "IND",
    Iot: "IOT",
    Irl: "IRL",
    Irn: "IRN",
    Irq: "IRQ",
    Isl: "ISL",
    Isr: "ISR",
    Ita: "ITA",
    Jam: "JAM",
    Jey: "JEY",
    Jor: "JOR",
    Jpn: "JPN",
    Kaz: "KAZ",
    Ken: "KEN",
    Kgz: "KGZ",
    Khm: "KHM",
    Kir: "KIR",
    Kna: "KNA",
    Kor: "KOR",
    Kwt: "KWT",
    Lao: "LAO",
    Lbn: "LBN",
    Lbr: "LBR",
    Lby: "LBY",
    Lca: "LCA",
    Lie: "LIE",
    Lka: "LKA",
    Lso: "LSO",
    Ltu: "LTU",
    Lux: "LUX",
    Lva: "LVA",
    Mac: "MAC",
    Maf: "MAF",
    Mar: "MAR",
    Mco: "MCO",
    Mda: "MDA",
    Mdg: "MDG",
    Mdv: "MDV",
    Mex: "MEX",
    Mhl: "MHL",
    Mkd: "MKD",
    Mli: "MLI",
    Mlt: "MLT",
    Mmr: "MMR",
    Mne: "MNE",
    Mng: "MNG",
    Mnp: "MNP",
    Moz: "MOZ",
    Mrt: "MRT",
    Msr: "MSR",
    Mtq: "MTQ",
    Mus: "MUS",
    Mwi: "MWI",
    Mys: "MYS",
    Myt: "MYT",
    Nam: "NAM",
    Ncl: "NCL",
    Ner: "NER",
    Nfk: "NFK",
    Nga: "NGA",
    Nic: "NIC",
    Niu: "NIU",
    Nld: "NLD",
    Nor: "NOR",
    Npl: "NPL",
    Nru: "NRU",
    Nzl: "NZL",
    Omn: "OMN",
    Pak: "PAK",
    Pan: "PAN",
    Pcn: "PCN",
    Per: "PER",
    Phl: "PHL",
    Plw: "PLW",
    Png: "PNG",
    Pol: "POL",
    Pri: "PRI",
    Prk: "PRK",
    Prt: "PRT",
    Pry: "PRY",
    Pse: "PSE",
    Pyf: "PYF",
    Qat: "QAT",
    Reu: "REU",
    Rks: "RKS",
    Rou: "ROU",
    Rus: "RUS",
    Rwa: "RWA",
    Sau: "SAU",
    Sdn: "SDN",
    Sen: "SEN",
    Sgp: "SGP",
    Sgs: "SGS",
    Shn: "SHN",
    Sjm: "SJM",
    Slb: "SLB",
    Sle: "SLE",
    Slv: "SLV",
    Smr: "SMR",
    Som: "SOM",
    Spm: "SPM",
    Srb: "SRB",
    Ssd: "SSD",
    Stp: "STP",
    Sur: "SUR",
    Svk: "SVK",
    Svn: "SVN",
    Swe: "SWE",
    Swz: "SWZ",
    Sxm: "SXM",
    Syc: "SYC",
    Syr: "SYR",
    Tca: "TCA",
    Tcd: "TCD",
    Tgo: "TGO",
    Tha: "THA",
    Tjk: "TJK",
    Tkl: "TKL",
    Tkm: "TKM",
    Tls: "TLS",
    Ton: "TON",
    Tto: "TTO",
    Tun: "TUN",
    Tur: "TUR",
    Tuv: "TUV",
    Twn: "TWN",
    Tza: "TZA",
    Uga: "UGA",
    Ukr: "UKR",
    Umi: "UMI",
    Ury: "URY",
    Usa: "USA",
    Uzb: "UZB",
    Vat: "VAT",
    Vct: "VCT",
    Ven: "VEN",
    Vgb: "VGB",
    Vir: "VIR",
    Vnm: "VNM",
    Vut: "VUT",
    Wlf: "WLF",
    Wsm: "WSM",
    Yem: "YEM",
    Zaf: "ZAF",
    Zmb: "ZMB",
    Zwe: "ZWE",
  } as const;
/**
 * Name of country
 */
export type ComCrmApplicationSelfServiceResourceGetApplicationCountryCallingCodeCountry =
  OpenEnum<
    typeof ComCrmApplicationSelfServiceResourceGetApplicationCountryCallingCodeCountry
  >;

export type ComCrmApplicationSelfServiceResourceGetApplicationCountryCallingCode =
  {
    /**
     * Name of country
     */
    country?:
      | ComCrmApplicationSelfServiceResourceGetApplicationCountryCallingCodeCountry
      | undefined;
  };

/**
 * Default calling country code for contacts to register and access the front-end applications.
 */
export const ComCrmApplicationSelfServiceResourceGetApplicationDefaultCountryCallingCode =
  {
    Abw: "ABW",
    Afg: "AFG",
    Ago: "AGO",
    Aia: "AIA",
    Ala: "ALA",
    Alb: "ALB",
    And: "AND",
    Ant: "ANT",
    Are: "ARE",
    Arg: "ARG",
    Arm: "ARM",
    Asm: "ASM",
    Ata: "ATA",
    Atf: "ATF",
    Atg: "ATG",
    Aus: "AUS",
    Aut: "AUT",
    Aze: "AZE",
    Bdi: "BDI",
    Bel: "BEL",
    Ben: "BEN",
    Bes: "BES",
    Bfa: "BFA",
    Bgd: "BGD",
    Bgr: "BGR",
    Bhr: "BHR",
    Bhs: "BHS",
    Bih: "BIH",
    Blm: "BLM",
    Blr: "BLR",
    Blz: "BLZ",
    Bmu: "BMU",
    Bol: "BOL",
    Bra: "BRA",
    Brb: "BRB",
    Brn: "BRN",
    Btn: "BTN",
    Bvt: "BVT",
    Bwa: "BWA",
    Caf: "CAF",
    Can: "CAN",
    Cck: "CCK",
    Che: "CHE",
    Chl: "CHL",
    Chn: "CHN",
    Civ: "CIV",
    Cmr: "CMR",
    Cod: "COD",
    Cog: "COG",
    Cok: "COK",
    Col: "COL",
    Com: "COM",
    Cpv: "CPV",
    Cri: "CRI",
    Cub: "CUB",
    Cuw: "CUW",
    Cxr: "CXR",
    Cym: "CYM",
    Cyp: "CYP",
    Cze: "CZE",
    Deu: "DEU",
    Dji: "DJI",
    Dma: "DMA",
    Dnk: "DNK",
    Dom: "DOM",
    Dza: "DZA",
    Ecu: "ECU",
    Egy: "EGY",
    Eri: "ERI",
    Esh: "ESH",
    Esp: "ESP",
    Est: "EST",
    Eth: "ETH",
    Fin: "FIN",
    Fji: "FJI",
    Flk: "FLK",
    Fra: "FRA",
    Fro: "FRO",
    Fsm: "FSM",
    Gab: "GAB",
    Gbr: "GBR",
    Geo: "GEO",
    Ggy: "GGY",
    Gha: "GHA",
    Gib: "GIB",
    Gin: "GIN",
    Glp: "GLP",
    Gmb: "GMB",
    Gnb: "GNB",
    Gnq: "GNQ",
    Grc: "GRC",
    Grd: "GRD",
    Grl: "GRL",
    Gtm: "GTM",
    Guf: "GUF",
    Gum: "GUM",
    Guy: "GUY",
    Hkg: "HKG",
    Hmd: "HMD",
    Hnd: "HND",
    Hrv: "HRV",
    Hti: "HTI",
    Hun: "HUN",
    Idn: "IDN",
    Imn: "IMN",
    Ind: "IND",
    Iot: "IOT",
    Irl: "IRL",
    Irn: "IRN",
    Irq: "IRQ",
    Isl: "ISL",
    Isr: "ISR",
    Ita: "ITA",
    Jam: "JAM",
    Jey: "JEY",
    Jor: "JOR",
    Jpn: "JPN",
    Kaz: "KAZ",
    Ken: "KEN",
    Kgz: "KGZ",
    Khm: "KHM",
    Kir: "KIR",
    Kna: "KNA",
    Kor: "KOR",
    Kwt: "KWT",
    Lao: "LAO",
    Lbn: "LBN",
    Lbr: "LBR",
    Lby: "LBY",
    Lca: "LCA",
    Lie: "LIE",
    Lka: "LKA",
    Lso: "LSO",
    Ltu: "LTU",
    Lux: "LUX",
    Lva: "LVA",
    Mac: "MAC",
    Maf: "MAF",
    Mar: "MAR",
    Mco: "MCO",
    Mda: "MDA",
    Mdg: "MDG",
    Mdv: "MDV",
    Mex: "MEX",
    Mhl: "MHL",
    Mkd: "MKD",
    Mli: "MLI",
    Mlt: "MLT",
    Mmr: "MMR",
    Mne: "MNE",
    Mng: "MNG",
    Mnp: "MNP",
    Moz: "MOZ",
    Mrt: "MRT",
    Msr: "MSR",
    Mtq: "MTQ",
    Mus: "MUS",
    Mwi: "MWI",
    Mys: "MYS",
    Myt: "MYT",
    Nam: "NAM",
    Ncl: "NCL",
    Ner: "NER",
    Nfk: "NFK",
    Nga: "NGA",
    Nic: "NIC",
    Niu: "NIU",
    Nld: "NLD",
    Nor: "NOR",
    Npl: "NPL",
    Nru: "NRU",
    Nzl: "NZL",
    Omn: "OMN",
    Pak: "PAK",
    Pan: "PAN",
    Pcn: "PCN",
    Per: "PER",
    Phl: "PHL",
    Plw: "PLW",
    Png: "PNG",
    Pol: "POL",
    Pri: "PRI",
    Prk: "PRK",
    Prt: "PRT",
    Pry: "PRY",
    Pse: "PSE",
    Pyf: "PYF",
    Qat: "QAT",
    Reu: "REU",
    Rks: "RKS",
    Rou: "ROU",
    Rus: "RUS",
    Rwa: "RWA",
    Sau: "SAU",
    Sdn: "SDN",
    Sen: "SEN",
    Sgp: "SGP",
    Sgs: "SGS",
    Shn: "SHN",
    Sjm: "SJM",
    Slb: "SLB",
    Sle: "SLE",
    Slv: "SLV",
    Smr: "SMR",
    Som: "SOM",
    Spm: "SPM",
    Srb: "SRB",
    Ssd: "SSD",
    Stp: "STP",
    Sur: "SUR",
    Svk: "SVK",
    Svn: "SVN",
    Swe: "SWE",
    Swz: "SWZ",
    Sxm: "SXM",
    Syc: "SYC",
    Syr: "SYR",
    Tca: "TCA",
    Tcd: "TCD",
    Tgo: "TGO",
    Tha: "THA",
    Tjk: "TJK",
    Tkl: "TKL",
    Tkm: "TKM",
    Tls: "TLS",
    Ton: "TON",
    Tto: "TTO",
    Tun: "TUN",
    Tur: "TUR",
    Tuv: "TUV",
    Twn: "TWN",
    Tza: "TZA",
    Uga: "UGA",
    Ukr: "UKR",
    Umi: "UMI",
    Ury: "URY",
    Usa: "USA",
    Uzb: "UZB",
    Vat: "VAT",
    Vct: "VCT",
    Ven: "VEN",
    Vgb: "VGB",
    Vir: "VIR",
    Vnm: "VNM",
    Vut: "VUT",
    Wlf: "WLF",
    Wsm: "WSM",
    Yem: "YEM",
    Zaf: "ZAF",
    Zmb: "ZMB",
    Zwe: "ZWE",
  } as const;
/**
 * Default calling country code for contacts to register and access the front-end applications.
 */
export type ComCrmApplicationSelfServiceResourceGetApplicationDefaultCountryCallingCode =
  OpenEnum<
    typeof ComCrmApplicationSelfServiceResourceGetApplicationDefaultCountryCallingCode
  >;

/**
 * Defines the supported contact features
 */
export type FeaturesContactContact = {
  /**
   * Defines whether business contact features should be available
   */
  isSupported?: boolean | undefined;
  /**
   * The contact's wallet code is used to uniquely identify them on front-end devices. This code can be in the form of a barcode or QR code
   */
  walletCodeFormat?: WalletCodeFormat | undefined;
  /**
   * Defines whether on register the question for existing customer should be available
   */
  enableExistingCustomerFlow?: boolean | undefined;
  /**
   * Defines the details that a contact can provide
   */
  profile?: Array<Profile> | undefined;
  /**
   * Defines whether communities (relationships between contacts) features will be available
   */
  communities?: Communities | undefined;
  /**
   * Defines the countries where usage of app will be applicable
   */
  countries?:
    | Array<ComCrmApplicationSelfServiceResourceGetApplicationCountry>
    | undefined;
  /**
   * Contacts with phone numbers from these countries can register and access the front-end applications.
   */
  countryCallingCodes?:
    | Array<
      ComCrmApplicationSelfServiceResourceGetApplicationCountryCallingCode
    >
    | undefined;
  /**
   * Default calling country code for contacts to register and access the front-end applications.
   */
  defaultCountryCallingCode?:
    | ComCrmApplicationSelfServiceResourceGetApplicationDefaultCountryCallingCode
    | undefined;
  /**
   * Preferred application language. 2-character language code based on ISO 639-1
   */
  preferredLanguageCode?: string | undefined;
};

/**
 * Defines whether multitenancy features will be available
 */
export type Multitenancy = {
  /**
   * Defines whether multitenancy is supported
   */
  isSupported?: boolean | undefined;
};

/**
 * Defines the supported business network features
 */
export type BusinessNetwork = {
  /**
   * Defines whether business network features should be available
   */
  isSupported: boolean;
  /**
   * Defines whether multitenancy features will be available
   */
  multitenancy?: Multitenancy | undefined;
};

/**
 * Defines the supported service request features
 */
export type ServiceRequests = {
  /**
   * Defines whether contacts will be able to create service requests
   */
  isSupported?: boolean | undefined;
};

/**
 * Defines the supported crm features
 */
export type Crm = {
  /**
   * Defines whether contact features should be available
   */
  isSupported: boolean;
  /**
   * Defines the supported service request features
   */
  serviceRequests?: ServiceRequests | undefined;
};

export type TopUpCommercePool = {
  /**
   * The commerce pool identifier
   */
  id?: string | undefined;
  /**
   * The commerce pool name
   */
  name?: string | undefined;
  /**
   * The commerce pool description
   */
  description?: string | undefined;
};

/**
 * The pass supplementary attribute type
 */
export const PassAttributeType = {
  Code: "CODE",
  Pin: "PIN",
} as const;
/**
 * The pass supplementary attribute type
 */
export type PassAttributeType = OpenEnum<typeof PassAttributeType>;

export type PassAttribute = {
  /**
   * The pass supplementary attribute type
   */
  type?: PassAttributeType | undefined;
};

/**
 * Defines the supported redeem pass features
 */
export type RedeemPass = {
  /**
   * Defines whether contacts will be able to redeem a pass
   */
  isSupported?: boolean | undefined;
  /**
   * If set to True, contacts will also be able to redeem their pass through the registration screen. In that case, the required pass info during registration (code and optionally the PIN) depend on the pass’s attributes specified in app settings. If set to False, then contacts can only redeem passes only after sign in
   */
  enableOnRegistration?: boolean | undefined;
  /**
   * Defines whether pass redemption should be supported by other attributes
   */
  passAttributes?: Array<PassAttribute> | undefined;
};

export const TransferEntity = {
  Account: "ACCOUNT",
  Wallet: "WALLET",
} as const;
export type TransferEntity = OpenEnum<typeof TransferEntity>;

export const TransferRestriction = {
  Open: "OPEN",
  Commerce: "COMMERCE",
} as const;
export type TransferRestriction = OpenEnum<typeof TransferRestriction>;

export type ComCrmApplicationSelfServiceResourceGetApplicationCommercePool = {
  /**
   * The commerce pool identifier
   */
  id?: string | undefined;
  /**
   * The commerce pool name
   */
  name?: string | undefined;
  /**
   * The commerce pool description
   */
  description?: string | undefined;
};

/**
 * Defines the supported transfer features
 */
export type ComCrmApplicationSelfServiceResourceGetApplicationTransfer = {
  /**
   * Defines whether transfer is supported or not
   */
  isSupported?: boolean | undefined;
  /**
   * Defines on which entity the transfer will be issued against (wallet and/or account)
   */
  transferEntity?: Array<TransferEntity> | undefined;
  /**
   * Defines whether wallet transfers will be applied on open and/or commerce balances (applicable & required only when wallet transfers are enabled)
   */
  transferRestrictions?: Array<TransferRestriction> | undefined;
  /**
   * Defines which commerce pools will be allowed for wallet transfers (applicable & required only when wallet transfers against commerce balance are enabled)
   */
  commercePools?:
    | Array<ComCrmApplicationSelfServiceResourceGetApplicationCommercePool>
    | undefined;
};

/**
 * Indicates whether the donations feature is supported
 */
export type Donations = {
  /**
   * If there is at least one valid reward offer enabled then the 'true' is returned
   */
  isSupported?: boolean | undefined;
};

/**
 * Currency code the top up amounts, will be displayed on the Application screen
 */
export const ComCrmApplicationSelfServiceResourceGetApplicationCurrencyCode = {
  Aed: "AED",
  Afn: "AFN",
  All: "ALL",
  Amd: "AMD",
  Ang: "ANG",
  Aoa: "AOA",
  Ars: "ARS",
  Aud: "AUD",
  Awg: "AWG",
  Azn: "AZN",
  Bam: "BAM",
  Bbd: "BBD",
  Bdt: "BDT",
  Bgn: "BGN",
  Bhd: "BHD",
  Bif: "BIF",
  Bmd: "BMD",
  Bnd: "BND",
  Bob: "BOB",
  Brl: "BRL",
  Bsd: "BSD",
  Btn: "BTN",
  Bwp: "BWP",
  Byr: "BYR",
  Bzd: "BZD",
  Cad: "CAD",
  Cdf: "CDF",
  Chf: "CHF",
  Clp: "CLP",
  Cny: "CNY",
  Cop: "COP",
  Crc: "CRC",
  Cuc: "CUC",
  Cup: "CUP",
  Cve: "CVE",
  Czk: "CZK",
  Djf: "DJF",
  Dkk: "DKK",
  Dop: "DOP",
  Dzd: "DZD",
  Egp: "EGP",
  Ern: "ERN",
  Etb: "ETB",
  Eur: "EUR",
  Fjd: "FJD",
  Fkp: "FKP",
  Gbp: "GBP",
  Gel: "GEL",
  Ggp: "GGP",
  Ghs: "GHS",
  Gip: "GIP",
  Gmd: "GMD",
  Gnf: "GNF",
  Gtq: "GTQ",
  Gyd: "GYD",
  Hkd: "HKD",
  Hnl: "HNL",
  Hrk: "HRK",
  Htg: "HTG",
  Huf: "HUF",
  Idr: "IDR",
  Ils: "ILS",
  Imp: "IMP",
  Inr: "INR",
  Iqd: "IQD",
  Irr: "IRR",
  Isk: "ISK",
  Jep: "JEP",
  Jmd: "JMD",
  Jod: "JOD",
  Jpy: "JPY",
  Kes: "KES",
  Kgs: "KGS",
  Khr: "KHR",
  Kmf: "KMF",
  Kpw: "KPW",
  Krw: "KRW",
  Kwd: "KWD",
  Kyd: "KYD",
  Kzt: "KZT",
  Lak: "LAK",
  Lbp: "LBP",
  Lkr: "LKR",
  Lrd: "LRD",
  Lsl: "LSL",
  Lyd: "LYD",
  Mad: "MAD",
  Mdl: "MDL",
  Mga: "MGA",
  Mkd: "MKD",
  Mmk: "MMK",
  Mnt: "MNT",
  Mop: "MOP",
  Mro: "MRO",
  Mur: "MUR",
  Mvr: "MVR",
  Mwk: "MWK",
  Mxn: "MXN",
  Myr: "MYR",
  Mzn: "MZN",
  Nad: "NAD",
  Ngn: "NGN",
  Nio: "NIO",
  Nok: "NOK",
  Npr: "NPR",
  Nzd: "NZD",
  Omr: "OMR",
  Pab: "PAB",
  Pen: "PEN",
  Pgk: "PGK",
  Php: "PHP",
  Pkr: "PKR",
  Pln: "PLN",
  Pyg: "PYG",
  Qar: "QAR",
  Ron: "RON",
  Rsd: "RSD",
  Rub: "RUB",
  Rwf: "RWF",
  Sar: "SAR",
  Sbd: "SBD",
  Scr: "SCR",
  Sdg: "SDG",
  Sek: "SEK",
  Sgd: "SGD",
  Shp: "SHP",
  Sll: "SLL",
  Sos: "SOS",
  Spl: "SPL",
  Srd: "SRD",
  Std: "STD",
  Svc: "SVC",
  Syp: "SYP",
  Szl: "SZL",
  Thb: "THB",
  Tjs: "TJS",
  Tmt: "TMT",
  Tnd: "TND",
  Top: "TOP",
  Try: "TRY",
  Ttd: "TTD",
  Tvd: "TVD",
  Twd: "TWD",
  Tzs: "TZS",
  Uah: "UAH",
  Ugx: "UGX",
  Usd: "USD",
  Uyu: "UYU",
  Uzs: "UZS",
  Vef: "VEF",
  Vnd: "VND",
  Vuv: "VUV",
  Wst: "WST",
  Xaf: "XAF",
  Xcd: "XCD",
  Xdr: "XDR",
  Xof: "XOF",
  Xpf: "XPF",
  Yer: "YER",
  Zar: "ZAR",
  Zmw: "ZMW",
  Zwd: "ZWD",
  Pts: "PTS",
} as const;
/**
 * Currency code the top up amounts, will be displayed on the Application screen
 */
export type ComCrmApplicationSelfServiceResourceGetApplicationCurrencyCode =
  OpenEnum<
    typeof ComCrmApplicationSelfServiceResourceGetApplicationCurrencyCode
  >;

export type TopupAmount = {
  /**
   * Currency code the top up amounts, will be displayed on the Application screen
   */
  currencyCode?:
    | ComCrmApplicationSelfServiceResourceGetApplicationCurrencyCode
    | undefined;
  /**
   * The top up amount options
   */
  amounts?: Array<number> | undefined;
};

/**
 * Defines the supported finance features
 */
export type Finance = {
  /**
   * Defines whether finance features should be available
   */
  isSupported: boolean;
  /**
   * Defines whether contacts will be able to top up their wallets
   */
  walletTopUp?: boolean | undefined;
  /**
   * Defines which commerce pools will be allowed for wallet TOP-UPS (applicable only when wallet top-ups are enabled)
   */
  topUpCommercePools?: Array<TopUpCommercePool> | undefined;
  /**
   * Defines whether contacts will be able to payout their wallets
   */
  walletPayout?: boolean | undefined;
  /**
   * Defines the supported redeem pass features
   */
  redeemPass?: RedeemPass | undefined;
  /**
   * Defines the supported transfer features
   */
  transfer?:
    | ComCrmApplicationSelfServiceResourceGetApplicationTransfer
    | undefined;
  /**
   * Indicates whether the donations feature is supported
   */
  donations?: Donations | undefined;
  /**
   * The different top up options the application supports
   */
  topupAmounts?: Array<TopupAmount> | undefined;
  /**
   * The redeem method supported by the application
   */
  redeemMethod?: string | undefined;
  /**
   * If returned as True, then this means that the app supports the purchase of eGifts since there's at least on electronic Gift Pass plan configured in the backend.
   */
  egiftsEnabled?: boolean | undefined;
  /**
   * If returned as True, it means business has enable the auto top up feature for their customers.
   */
  autoTopupEnabled?: boolean | undefined;
  /**
   * Subject to the business’s wallet settings: If set to ‘true’, the Contact’s CRM.COM Wallet code is dynamically regenerated at regular intervals for enhanced security. When set to ‘false’, the wallet code remains static. Wallet codes are typically used when a contact checks in or generates an OTP to spend when purchasing via the Contact App.
   */
  dynamicWalletCode?: boolean | undefined;
};

/**
 * Defines the details for pick up as supply method
 */
export type PickUp = {
  /**
   * Is pick-up supply method available?
   */
  isSupported: boolean;
  /**
   * Order queue identifier for pick-up supply method
   */
  queueId?: string | undefined;
  /**
   * Order queue name for pick-up supply method
   */
  queueName?: string | undefined;
};

/**
 * Defines the details for delivery as supply method
 */
export type Delivery = {
  /**
   * Is delivery supply method available?
   */
  isSupported: boolean;
  /**
   * Order queue identifier for delivery supply method
   */
  queueId?: string | undefined;
  /**
   * Order queue name for delivery supply method
   */
  queueName?: string | undefined;
};

/**
 * Defines the details for direct sale as supply method
 */
export type DirectSale = {
  /**
   * Is direct sale supply method available?
   */
  isSupported: boolean;
  /**
   * Order queue identifier for direct-sale supply method
   */
  queueId?: string | undefined;
  /**
   * Order queue name for direct-sale supply method
   */
  queueName?: string | undefined;
};

/**
 * Defines the consumer ordering model
 */
export const Model = {
  Marketplace: "MARKETPLACE",
  SingleBusiness: "SINGLE_BUSINESS",
} as const;
/**
 * Defines the consumer ordering model
 */
export type Model = OpenEnum<typeof Model>;

export type OrderCatalogue = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The entity name
   */
  name?: string | undefined;
  /**
   * Determines whether the order’s catalogue set up will be presented as a pricing table in front-end apps or not.
   */
  isPricingTable?: boolean | undefined;
};

/**
 * Defines whether contact can pay for order using wallet funds
 */
export type UseWalletFunds = {
  /**
   * Defines whether contact can pay for order using wallet funds
   */
  isSupported: boolean;
  /**
   * Defines whether contacts can specific the wallet funds amount to use on orders
   */
  specificFundsAmount?: boolean | undefined;
  /**
   * Defines whether the wallet fund amount must cover the full basket amount
   */
  coverFullBasket?: boolean | undefined;
};

/**
 * Settings that determine the order’s behaviour and how it will be fulfilled by the business and/or the merchants/service provides in the Business Network
 */
export type FulfilmentFlows = {
  /**
   * Determines whether the Order will be fulfilled by a single merhcant/service provider that a contact selects OR the Order will be fulfilled by multiple merchants/service providers based on the contact’s selection of products in the basket. * `SINGLE_MERCHANT` - A single specific merchant
   *
   * @remarks
   *  * `MULTI_MERCHANT` - Multiple merchants
   */
  fulfilmentFlow: string;
  /**
   * When true, customers can select from multiple delivery venues instead of being assigned to the closest one.
   */
  allowDeliverySelection?: boolean | undefined;
};

/**
 * Defines the supported ordering features
 */
export type ComCrmApplicationSelfServiceResourceGetApplicationOrder = {
  /**
   * Defines whether order features should be available
   */
  isSupported: boolean;
  /**
   * Defines the details for pick up as supply method
   */
  pickUp?: PickUp | undefined;
  /**
   * Defines the details for delivery as supply method
   */
  delivery?: Delivery | undefined;
  /**
   * Defines the details for direct sale as supply method
   */
  directSale?: DirectSale | undefined;
  /**
   * Defines the consumer ordering model
   */
  model?: Model | undefined;
  /**
   * Defines whether contact can set preferred organisation for ordering
   */
  preferredOrganisation?: boolean | undefined;
  /**
   * Defines a list of order catalogs that should filter available products to order
   */
  orderCatalogues?: Array<OrderCatalogue> | undefined;
  /**
   * Defines whether contact can pay for order using wallet funds
   */
  useWalletFunds?: UseWalletFunds | undefined;
  /**
   * Allow the contact's account funds to be used for order payments?
   */
  useAccountFunds: boolean;
  /**
   * Settings that determine the order’s behaviour and how it will be fulfilled by the business and/or the merchants/service provides in the Business Network
   */
  fulfilmentFlows?: FulfilmentFlows | undefined;
  /**
   * Defines if there will be additional notes for each product at the time of ordering
   */
  supportProductAdditionalNotes?: boolean | undefined;
};

export const ReferMethod = {
  Email: "EMAIL",
  Sms: "SMS",
} as const;
export type ReferMethod = OpenEnum<typeof ReferMethod>;

/**
 * Defines the supported refer a friend features
 */
export type ReferFriend = {
  /**
   * Defines whether refer a friend will be supported
   */
  isSupported?: boolean | undefined;
  /**
   * Defines the communication method that should be used for refer a friend
   */
  referMethods?: Array<ReferMethod> | undefined;
};

/**
 * The alternative token code format. This code can be in the form of a barcode or QR code
 */
export const ComCrmApplicationSelfServiceResourceGetApplicationCodeFormat = {
  Barcode: "BARCODE",
  QrCode: "QR_CODE",
} as const;
/**
 * The alternative token code format. This code can be in the form of a barcode or QR code
 */
export type ComCrmApplicationSelfServiceResourceGetApplicationCodeFormat =
  OpenEnum<typeof ComCrmApplicationSelfServiceResourceGetApplicationCodeFormat>;

/**
 * The type of supplementary attribute
 */
export const SpendAttributeType = {
  Amount: "AMOUNT",
} as const;
/**
 * The type of supplementary attribute
 */
export type SpendAttributeType = ClosedEnum<typeof SpendAttributeType>;

export type SpendAttribute = {
  /**
   * The type of supplementary attribute
   */
  type?: SpendAttributeType | undefined;
};

/**
 * Defines the supported OTP spend features
 */
export type OtpSpend = {
  /**
   * Defines whether OTP spend will be supported
   */
  isSupported?: boolean | undefined;
  /**
   * The alternative token code format. This code can be in the form of a barcode or QR code
   */
  codeFormat?:
    | ComCrmApplicationSelfServiceResourceGetApplicationCodeFormat
    | undefined;
  /**
   * Defines the supplementary attributes that will be supported for OTP spends (required when OTP spend is enabled)
   */
  spendAttributes?: Array<SpendAttribute> | undefined;
};

export const SelfSubmitMethod = {
  Barcode: "BARCODE",
  TrxCode: "TRX_CODE",
} as const;
export type SelfSubmitMethod = OpenEnum<typeof SelfSubmitMethod>;

/**
 * Defines the supported contact self-submit purchase events features
 */
export type SelfSubmitPurchases = {
  /**
   * Defines whether contact can self-submit purchase events
   */
  isSupported: boolean;
  /**
   * Defines how reclaim purchase identification will be made (required when contact self-submit purchase is enabled)
   */
  selfSubmitMethods?: Array<SelfSubmitMethod> | undefined;
};

/**
 * Defines the supported rewards features
 */
export type Reward = {
  /**
   * Defines whether reward features should be available
   */
  isSupported: boolean;
  /**
   * Defines whether reward tiering will be supported
   */
  tiering?: boolean | undefined;
  /**
   * Defines whether contact can select his/her preferred organisation for rewards
   */
  preferredOrganisation?: boolean | undefined;
  /**
   * Defines the supported refer a friend features
   */
  referFriend?: ReferFriend | undefined;
  /**
   * Defines the supported OTP spend features
   */
  otpSpend?: OtpSpend | undefined;
  /**
   * Defines the supported contact self-submit purchase events features
   */
  selfSubmitPurchases?: SelfSubmitPurchases | undefined;
};

/**
 * 2-character language code based on ISO 639-1
 */
export const MarketingLanguageCode = {
  En: "EN",
  Gr: "GR",
} as const;
/**
 * 2-character language code based on ISO 639-1
 */
export type MarketingLanguageCode = OpenEnum<typeof MarketingLanguageCode>;

/**
 * Information about the creative type
 */
export const MarketingUsageType = {
  Marketing: "MARKETING",
} as const;
/**
 * Information about the creative type
 */
export type MarketingUsageType = ClosedEnum<typeof MarketingUsageType>;

export type MarketingMedia = {
  /**
   * The transformed creative width
   */
  width?: number | undefined;
  /**
   * The transformed creative height
   */
  height?: number | undefined;
  /**
   * The transformed creative URL
   */
  url?: string | undefined;
};

export type MarketingCreative = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * the identifier of media
   */
  mediaGroupId?: string | undefined;
  /**
   * Information about the creative type
   */
  usageType?: MarketingUsageType | undefined;
  /**
   * The creative width
   */
  width?: number | undefined;
  /**
   * The creative height
   */
  height?: number | undefined;
  /**
   * The creative format
   */
  format?: string | undefined;
  /**
   * The creative content URL
   */
  url?: string | undefined;
  /**
   * The creative public identifier
   */
  publicId?: string | undefined;
  /**
   * The media identifier
   */
  mediaId?: string | undefined;
  /**
   * Information about the creative transformations
   */
  media?: Array<MarketingMedia> | undefined;
};

export type ComCrmApplicationSelfServiceResourceGetApplicationEmbeddedLink = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * Defines the title of the link
   */
  title?: string | undefined;
  /**
   * Defines the url of the link
   */
  url?: string | undefined;
  /**
   * Defines the order of the links, according to User input
   */
  sortOrder?: number | undefined;
  /**
   * 2-character language code based on ISO 639-1
   */
  languageCode?: MarketingLanguageCode | undefined;
  /**
   * Details about creatives. A creative is an object that contains all the data required for visually rendering an image responsively, such as the initial image and a number of scale versions of it (srcset)
   */
  creatives?: Array<MarketingCreative> | undefined;
};

/**
 * Defines the supported marketing content features
 */
export type Marketing = {
  /**
   * Defines whether marketing content should be available
   */
  isSupported: boolean;
  /**
   * Define links for embedded browser in front-end systems
   */
  embeddedLinks?:
    | Array<ComCrmApplicationSelfServiceResourceGetApplicationEmbeddedLink>
    | undefined;
};

/**
 * Shortcuts valid types (for front-end applications)
 */
export const ShortcutType = {
  ContactCode: "CONTACT_CODE",
  Locations: "LOCATIONS",
  OtpToSpend: "OTP_TO_SPEND",
  ReclaimPurchase: "RECLAIM_PURCHASE",
  TopUpWallet: "TOP_UP_WALLET",
  ReferAFriend: "REFER_A_FRIEND",
  ServiceRequest: "SERVICE_REQUEST",
  RedeemAPass: "REDEEM_A_PASS",
  RequestMoney: "REQUEST_MONEY",
  SendMoney: "SEND_MONEY",
  Communities: "COMMUNITIES",
  Order: "ORDER",
  Donate: "DONATE",
  ElectronicGiftPass: "ELECTRONIC_GIFT_PASS",
} as const;
/**
 * Shortcuts valid types (for front-end applications)
 */
export type ShortcutType = OpenEnum<typeof ShortcutType>;

/**
 * 2-character language code based on ISO 639-1
 */
export const ShortcutLanguageCode = {
  En: "EN",
  Gr: "GR",
} as const;
/**
 * 2-character language code based on ISO 639-1
 */
export type ShortcutLanguageCode = OpenEnum<typeof ShortcutLanguageCode>;

/**
 * Information about the creative type
 */
export const ShortcutUsageType = {
  Shortcut: "SHORTCUT",
} as const;
/**
 * Information about the creative type
 */
export type ShortcutUsageType = ClosedEnum<typeof ShortcutUsageType>;

export type ShortcutMedia = {
  /**
   * The transformed creative width
   */
  width?: number | undefined;
  /**
   * The transformed creative height
   */
  height?: number | undefined;
  /**
   * The transformed creative URL
   */
  url?: string | undefined;
};

export type ShortcutCreative = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * the identifier of media
   */
  mediaGroupId?: string | undefined;
  /**
   * Information about the creative type
   */
  usageType?: ShortcutUsageType | undefined;
  /**
   * The creative width
   */
  width?: number | undefined;
  /**
   * The creative height
   */
  height?: number | undefined;
  /**
   * The creative format
   */
  format?: string | undefined;
  /**
   * The creative content URL
   */
  url?: string | undefined;
  /**
   * The creative public identifier
   */
  publicId?: string | undefined;
  /**
   * The media identifier
   */
  mediaId?: string | undefined;
  /**
   * Information about the creative transformations
   */
  media?: Array<ShortcutMedia> | undefined;
};

export type Shortcut = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * Order in which shortcut will appear
   */
  sortOrder?: number | undefined;
  /**
   * Shortcuts valid types (for front-end applications)
   */
  type?: ShortcutType | undefined;
  /**
   * Shortcut label (as it will appear on the front-end UI), 'label and 'creatives' are semi-optional - either both or either one of the two can be provided
   */
  label?: string | undefined;
  /**
   * 2-character language code based on ISO 639-1
   */
  languageCode?: ShortcutLanguageCode | undefined;
  /**
   * Details about creatives. A creative is an object that contains all the data required for visually rendering an image responsively, such as the initial image and a number of scale versions of it (srcset)
   */
  creatives?: Array<ShortcutCreative> | undefined;
};

/**
 * Defines the supported shortcuts features
 */
export type Shortcuts = {
  /**
   * Are shortcuts enabled?
   */
  isSupported: boolean;
  /**
   * Configured shortcuts
   */
  shortcuts?: Array<Shortcut> | undefined;
};

export const ComCrmApplicationSelfServiceResourceGetApplicationSubscription = {
  ChangeBillingDay: "CHANGE_BILLING_DAY",
  ChangePaymentMethod: "CHANGE_PAYMENT_METHOD",
} as const;
export type ComCrmApplicationSelfServiceResourceGetApplicationSubscription =
  OpenEnum<
    typeof ComCrmApplicationSelfServiceResourceGetApplicationSubscription
  >;

export const SubscriptionsScheduledAction = {
  Update: "UPDATE",
  Cancel: "CANCEL",
} as const;
export type SubscriptionsScheduledAction = OpenEnum<
  typeof SubscriptionsScheduledAction
>;

export const ComCrmApplicationSelfServiceResourceGetApplicationService = {
  Activate: "ACTIVATE",
  Deactivate: "DEACTIVATE",
  Pause: "PAUSE",
  Resume: "RESUME",
  Change: "CHANGE",
  Regret: "REGRET",
  Cancel: "CANCEL",
} as const;
export type ComCrmApplicationSelfServiceResourceGetApplicationService =
  OpenEnum<typeof ComCrmApplicationSelfServiceResourceGetApplicationService>;

/**
 * Subscription and service actions permitted by front-end users
 */
export type Actions = {
  /**
   * Subscription actions permitted via the front-end
   */
  subscriptions?:
    | Array<ComCrmApplicationSelfServiceResourceGetApplicationSubscription>
    | undefined;
  /**
   * Allowed amendments on scheduled subscription actions
   */
  subscriptionsScheduledActions?:
    | Array<SubscriptionsScheduledAction>
    | undefined;
  /**
   * Actions permitted against subscription services
   */
  services?:
    | Array<ComCrmApplicationSelfServiceResourceGetApplicationService>
    | undefined;
};

/**
 * Subscription settings for application
 */
export type Subscriptions = {
  /**
   * Are subscriptions enabled?
   */
  isSupported: boolean;
  /**
   * Subscription and service actions permitted by front-end users
   */
  actions?: Actions | undefined;
};

/**
 * Defines the supported mobile pass features
 */
export type MobilePass = {
  /**
   * Defines whether mobile pass should be available
   */
  isSupported?: boolean | undefined;
};

/**
 * The contact features that will be supported by the application
 */
export type FeaturesContact = {
  /**
   * Defines the supported contact features
   */
  contact?: FeaturesContactContact | undefined;
  /**
   * Defines the supported business network features
   */
  businessNetwork?: BusinessNetwork | undefined;
  /**
   * Defines the supported crm features
   */
  crm?: Crm | undefined;
  /**
   * Defines the supported finance features
   */
  finance?: Finance | undefined;
  /**
   * Defines the supported ordering features
   */
  order?: ComCrmApplicationSelfServiceResourceGetApplicationOrder | undefined;
  /**
   * Defines the supported rewards features
   */
  reward?: Reward | undefined;
  /**
   * Defines the supported marketing content features
   */
  marketing?: Marketing | undefined;
  /**
   * Defines the supported shortcuts features
   */
  shortcuts?: Shortcuts | undefined;
  /**
   * Subscription settings for application
   */
  subscriptions?: Subscriptions | undefined;
  /**
   * Defines the supported mobile pass features
   */
  mobilePass?: MobilePass | undefined;
};

/**
 * Defines the supported purchase event features
 */
export type ComCrmApplicationSelfServiceResourceGetApplicationPurchase = {
  /**
   * The merchant app user manually enters the amount to be spent
   */
  manualSpend?: boolean | undefined;
  /**
   * Spend using an amount specified by the contact through a front-end application or subject to available wallet funds
   */
  automaticSpend?: boolean | undefined;
  /**
   * The whole purchase amount is to be paid using the CRM.COM Wallet
   */
  spendFullPurchaseAmount?: boolean | undefined;
  /**
   * This option applies to 'automatic_spend' and 'spend_full_purchase_amount' options only. When enabled, a purchase will only be successfully posted if the amount to be spent is fully covered by the funds in the CRM.COM  Wallet.
   */
  restrictFullyCovered?: boolean | undefined;
};

/**
 * The merchant features that will be supported by the application
 */
export type Merchant = {
  /**
   * Defines the supported purchase event features
   */
  purchase?:
    | ComCrmApplicationSelfServiceResourceGetApplicationPurchase
    | undefined;
};

/**
 * Details about the features that will be supported by the app
 */
export type Features = {
  /**
   * The contact features that will be supported by the application
   */
  contact?: FeaturesContact | undefined;
  /**
   * The merchant features that will be supported by the application
   */
  merchant?: Merchant | undefined;
};

/**
 * The platform on which the application will be published
 */
export const ComCrmApplicationSelfServiceResourceGetApplicationPlatformEnum = {
  Apple: "APPLE",
  Google: "GOOGLE",
  Web: "WEB",
} as const;
/**
 * The platform on which the application will be published
 */
export type ComCrmApplicationSelfServiceResourceGetApplicationPlatformEnum =
  OpenEnum<
    typeof ComCrmApplicationSelfServiceResourceGetApplicationPlatformEnum
  >;

export type ComCrmApplicationSelfServiceResourceGetApplicationPlatform = {
  /**
   * The platform on which the application will be published
   */
  platform?:
    | ComCrmApplicationSelfServiceResourceGetApplicationPlatformEnum
    | undefined;
  /**
   * The application id of each platform
   */
  platformId?: string | null | undefined;
  /**
   * DNS Cloud name for the Web URL
   */
  cloudName?: string | null | undefined;
  /**
   * The application version
   */
  version?: string | null | undefined;
  /**
   * The deeplinks configuration json
   */
  deeplinksConfig?: string | null | undefined;
};

/**
 * Defines whether contacts can register & sign-in based on Facebook (including Facebook authentication details)
 */
export type Facebook = {
  /**
   * Defines whether Facebook authentication is enabled or not
   */
  isSupported: boolean;
  /**
   * Facebook App ID required for FB authentication
   */
  appId?: string | null | undefined;
};

export type Google = {
  /**
   * Defines whether Google authentication is supported or not
   */
  isSupported?: boolean | undefined;
};

/**
 * The contact that will be assigned as demo contact (required only if demo contact is enabled)
 */
export type DemoContactContact = {
  /**
   * The (demo) contact identifier
   */
  id?: string | undefined;
  /**
   * The (demo) contact full name
   */
  name?: string | undefined;
};

/**
 * The contact assigned as demo contact (used for app store verification purposes)
 */
export type DemoContact = {
  /**
   * Defines whether demo contact is supported or not
   */
  isSupported: boolean;
  /**
   * The contact that will be assigned as demo contact (required only if demo contact is enabled)
   */
  contact?: DemoContactContact | undefined;
  /**
   * The one-time password that will be accepted for sign-in purposes (required only if demo contact is enabled)
   */
  otp?: string | undefined;
};

/**
 * The contact that will be assigned as guest contact (required only if guest contact is enabled)
 */
export type GuestContactContact = {
  /**
   * The (guest) contact identifier
   */
  id?: string | undefined;
  /**
   * The (guest) contact full name
   */
  name?: string | undefined;
};

/**
 * The contact assigned as guest contact (used for continuing as guest in app)
 */
export type GuestContact = {
  /**
   * Defines whether guest contact is supported or not
   */
  isSupported: boolean;
  /**
   * The contact that will be assigned as guest contact (required only if guest contact is enabled)
   */
  contact?: GuestContactContact | undefined;
};

/**
 * Support contacts authentication using an Open ID Connect provider (that enables single-sign-on)
 */
export type Sso = {
  /**
   * Defines whether OpenID connect is supported or not
   */
  isSupported: boolean;
};

/**
 * Details on how customers can auth by the app
 */
export type Authentication = {
  /**
   * Supported authentication based on email and password
   */
  emailPassword?: boolean | undefined;
  /**
   * Supported authentication based on email and one time password
   */
  emailOtp?: boolean | null | undefined;
  /**
   * Supported authentication based on one time password
   */
  smsOtp?: boolean | undefined;
  /**
   * Defines whether contacts can register & sign-in based on Facebook (including Facebook authentication details)
   */
  facebook?: Facebook | undefined;
  google?: Google | undefined;
  /**
   * The contact assigned as demo contact (used for app store verification purposes)
   */
  demoContact?: DemoContact | undefined;
  /**
   * The contact assigned as guest contact (used for continuing as guest in app)
   */
  guestContact?: GuestContact | undefined;
  /**
   * Support contacts authentication using an Open ID Connect provider (that enables single-sign-on)
   */
  sso?: Sso | undefined;
};

/**
 * Information about the creative type
 */
export const ComCrmApplicationSelfServiceResourceGetApplicationCreativeUsageType =
  {
    WalletImage: "WALLET_IMAGE",
    DirectSaleImage: "DIRECT_SALE_IMAGE",
    DeliveryImage: "DELIVERY_IMAGE",
    LandingPageImage: "LANDING_PAGE_IMAGE",
    PickupImage: "PICKUP_IMAGE",
    AppLogo: "APP_LOGO",
    Carousel: "CAROUSEL",
    PartnerLogo: "PARTNER_LOGO",
  } as const;
/**
 * Information about the creative type
 */
export type ComCrmApplicationSelfServiceResourceGetApplicationCreativeUsageType =
  OpenEnum<
    typeof ComCrmApplicationSelfServiceResourceGetApplicationCreativeUsageType
  >;

export type ComCrmApplicationSelfServiceResourceGetApplicationCreativeMedia = {
  /**
   * The transformed creative width
   */
  width?: number | undefined;
  /**
   * The transformed creative height
   */
  height?: number | undefined;
  /**
   * The transformed creative URL
   */
  url?: string | undefined;
};

export type ComCrmApplicationSelfServiceResourceGetApplicationCreative = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * the identifier of media
   */
  mediaGroupId?: string | undefined;
  /**
   * Information about the creative type
   */
  usageType?:
    | ComCrmApplicationSelfServiceResourceGetApplicationCreativeUsageType
    | undefined;
  /**
   * The creative width
   */
  width?: number | undefined;
  /**
   * The creative height
   */
  height?: number | undefined;
  /**
   * The creative format
   */
  format?: string | undefined;
  /**
   * The creative content URL
   */
  url?: string | undefined;
  /**
   * The creative public identifier
   */
  publicId?: string | undefined;
  /**
   * The media identifier
   */
  mediaId?: string | undefined;
  /**
   * Information about the creative transformations
   */
  media?:
    | Array<ComCrmApplicationSelfServiceResourceGetApplicationCreativeMedia>
    | undefined;
  /**
   * Order in which the caousel image will appear
   */
  sortOrder?: number | undefined;
  /**
   * The creative caption used in cases where usage_type=CAROUSEL
   */
  caption?: string | undefined;
};

export type FirebaseConfig = {
  config?: string | undefined;
  vapidKey?: string | undefined;
};

export type CustomizationConfig = {
  extension?: string | undefined;
};

/**
 * OK
 */
export type ComCrmApplicationSelfServiceResourceGetApplicationResponse = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The application name
   */
  name?: string | undefined;
  /**
   * The application description
   */
  description?: string | undefined;
  /**
   * The business name shown in app front-end
   */
  brandName?: string | undefined;
  /**
   * The application type:
   *
   * @remarks
   *  * `NATIVE` - Mobile Consumer Applications (Apple and Google)
   *  * `NATIVE_MERCHANT` - Mobile Merchant Applications (Apple and Google)
   *  * `WEB` - Web Portal
   *  * `CAPTIVE` - Captive Portal
   *  * `CONSUMER_APP` - Consumer App (Portal and App)
   */
  type?: ComCrmApplicationSelfServiceResourceGetApplicationType | undefined;
  /**
   * Details about the app appearance
   */
  appearance?: Appearance | undefined;
  /**
   * Defines the app details (about, terms and conditions, privacy policy)
   */
  information?: Information | undefined;
  /**
   * Details about the features that will be supported by the app
   */
  features?: Features | undefined;
  /**
   * Details about the application identifiers per supported platform
   */
  platforms?:
    | Array<ComCrmApplicationSelfServiceResourceGetApplicationPlatform>
    | undefined;
  /**
   * Details on how customers can auth by the app
   */
  authentication?: Authentication | undefined;
  publicKey?: string | undefined;
  /**
   * Creatives images for marketing includes the primary image and scaled versions to create a srcset
   */
  creatives?:
    | Array<ComCrmApplicationSelfServiceResourceGetApplicationCreative>
    | undefined;
  firebaseConfig?: FirebaseConfig | undefined;
  customizationConfig?: CustomizationConfig | undefined;
  showRecommendations?: boolean | undefined;
  showBestSelling?: boolean | undefined;
};

/** @internal */
export type ComCrmApplicationSelfServiceResourceGetApplicationSecurity$Outbound =
  {
    Public_API_key: string;
  };

/** @internal */
export const ComCrmApplicationSelfServiceResourceGetApplicationSecurity$outboundSchema:
  z.ZodMiniType<
    ComCrmApplicationSelfServiceResourceGetApplicationSecurity$Outbound,
    ComCrmApplicationSelfServiceResourceGetApplicationSecurity
  > = z.pipe(
    z.object({
      publicAPIKey: z.string(),
    }),
    z.transform((v) => {
      return remap$(v, {
        publicAPIKey: "Public_API_key",
      });
    }),
  );

export function comCrmApplicationSelfServiceResourceGetApplicationSecurityToJSON(
  comCrmApplicationSelfServiceResourceGetApplicationSecurity:
    ComCrmApplicationSelfServiceResourceGetApplicationSecurity,
): string {
  return JSON.stringify(
    ComCrmApplicationSelfServiceResourceGetApplicationSecurity$outboundSchema
      .parse(comCrmApplicationSelfServiceResourceGetApplicationSecurity),
  );
}

/** @internal */
export type ComCrmApplicationSelfServiceResourceGetApplicationRequest$Outbound =
  {
    cloud_name?: string | undefined;
    platform_app_id: string;
    version?: string | undefined;
  };

/** @internal */
export const ComCrmApplicationSelfServiceResourceGetApplicationRequest$outboundSchema:
  z.ZodMiniType<
    ComCrmApplicationSelfServiceResourceGetApplicationRequest$Outbound,
    ComCrmApplicationSelfServiceResourceGetApplicationRequest
  > = z.pipe(
    z.object({
      cloudName: z.optional(z.string()),
      platformAppId: z.string(),
      version: z.optional(z.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        cloudName: "cloud_name",
        platformAppId: "platform_app_id",
      });
    }),
  );

export function comCrmApplicationSelfServiceResourceGetApplicationRequestToJSON(
  comCrmApplicationSelfServiceResourceGetApplicationRequest:
    ComCrmApplicationSelfServiceResourceGetApplicationRequest,
): string {
  return JSON.stringify(
    ComCrmApplicationSelfServiceResourceGetApplicationRequest$outboundSchema
      .parse(comCrmApplicationSelfServiceResourceGetApplicationRequest),
  );
}

/** @internal */
export const ComCrmApplicationSelfServiceResourceGetApplicationType$inboundSchema:
  z.ZodMiniType<
    ComCrmApplicationSelfServiceResourceGetApplicationType,
    unknown
  > = openEnums.inboundSchema(
    ComCrmApplicationSelfServiceResourceGetApplicationType,
  );

/** @internal */
export const ColourType$inboundSchema: z.ZodMiniType<ColourType, unknown> =
  openEnums.inboundSchema(ColourType);

/** @internal */
export const Colour$inboundSchema: z.ZodMiniType<Colour, unknown> = z.object({
  type: types.optional(ColourType$inboundSchema),
  value: types.optional(types.string()),
});

export function colourFromJSON(
  jsonString: string,
): SafeParseResult<Colour, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Colour$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Colour' from JSON`,
  );
}

/** @internal */
export const FontType$inboundSchema: z.ZodMiniEnum<typeof FontType> = z.enum(
  FontType,
);

/** @internal */
export const FontEnum$inboundSchema: z.ZodMiniType<FontEnum, unknown> =
  openEnums.inboundSchema(FontEnum);

/** @internal */
export const Font$inboundSchema: z.ZodMiniType<Font, unknown> = z.object({
  type: types.optional(FontType$inboundSchema),
  font: types.optional(FontEnum$inboundSchema),
});

export function fontFromJSON(
  jsonString: string,
): SafeParseResult<Font, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Font$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Font' from JSON`,
  );
}

/** @internal */
export const HomepageLayout$inboundSchema: z.ZodMiniType<
  HomepageLayout,
  unknown
> = openEnums.inboundSchema(HomepageLayout);

/** @internal */
export const OrderingLayout$inboundSchema: z.ZodMiniType<
  OrderingLayout,
  unknown
> = openEnums.inboundSchema(OrderingLayout);

/** @internal */
export const AdvancedSettings$inboundSchema: z.ZodMiniType<
  AdvancedSettings,
  unknown
> = z.pipe(
  z.object({
    colours: types.optional(types.string()),
    layout_components: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "layout_components": "layoutComponents",
    });
  }),
);

export function advancedSettingsFromJSON(
  jsonString: string,
): SafeParseResult<AdvancedSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AdvancedSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AdvancedSettings' from JSON`,
  );
}

/** @internal */
export const Appearance$inboundSchema: z.ZodMiniType<Appearance, unknown> = z
  .pipe(
    z.object({
      colours: types.optional(z.array(z.lazy(() => Colour$inboundSchema))),
      fonts: types.optional(z.array(z.lazy(() => Font$inboundSchema))),
      dark_mode: z._default(types.boolean(), false),
      homepage_layout: z._default(HomepageLayout$inboundSchema, "LAYOUT1"),
      ordering_layout: z._default(OrderingLayout$inboundSchema, "LAYOUT1"),
      advanced_settings: types.optional(
        z.lazy(() => AdvancedSettings$inboundSchema),
      ),
    }),
    z.transform((v) => {
      return remap$(v, {
        "dark_mode": "darkMode",
        "homepage_layout": "homepageLayout",
        "ordering_layout": "orderingLayout",
        "advanced_settings": "advancedSettings",
      });
    }),
  );

export function appearanceFromJSON(
  jsonString: string,
): SafeParseResult<Appearance, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Appearance$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Appearance' from JSON`,
  );
}

/** @internal */
export const InformationType$inboundSchema: z.ZodMiniType<
  InformationType,
  unknown
> = openEnums.inboundSchema(InformationType);

/** @internal */
export const ComCrmApplicationSelfServiceResourceGetApplicationContent$inboundSchema:
  z.ZodMiniType<
    ComCrmApplicationSelfServiceResourceGetApplicationContent,
    unknown
  > = z.pipe(
    z.object({
      type: types.optional(InformationType$inboundSchema),
      url: types.optional(types.string()),
      rich_content: types.optional(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "rich_content": "richContent",
      });
    }),
  );

export function comCrmApplicationSelfServiceResourceGetApplicationContentFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmApplicationSelfServiceResourceGetApplicationContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmApplicationSelfServiceResourceGetApplicationContent$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmApplicationSelfServiceResourceGetApplicationContent' from JSON`,
  );
}

/** @internal */
export const ComCrmApplicationSelfServiceResourceGetApplicationCountryCode$inboundSchema:
  z.ZodMiniType<
    ComCrmApplicationSelfServiceResourceGetApplicationCountryCode,
    unknown
  > = openEnums.inboundSchema(
    ComCrmApplicationSelfServiceResourceGetApplicationCountryCode,
  );

/** @internal */
export const ComCrmApplicationSelfServiceResourceGetApplicationPhone$inboundSchema:
  z.ZodMiniType<
    ComCrmApplicationSelfServiceResourceGetApplicationPhone,
    unknown
  > = z.pipe(
    z.object({
      country_code: types.optional(
        ComCrmApplicationSelfServiceResourceGetApplicationCountryCode$inboundSchema,
      ),
      number: z.optional(z.nullable(types.string())),
    }),
    z.transform((v) => {
      return remap$(v, {
        "country_code": "countryCode",
      });
    }),
  );

export function comCrmApplicationSelfServiceResourceGetApplicationPhoneFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmApplicationSelfServiceResourceGetApplicationPhone,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmApplicationSelfServiceResourceGetApplicationPhone$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmApplicationSelfServiceResourceGetApplicationPhone' from JSON`,
  );
}

/** @internal */
export const ContactUs$inboundSchema: z.ZodMiniType<ContactUs, unknown> = z
  .pipe(
    z.object({
      email_address: z.optional(z.nullable(types.string())),
      phone: types.optional(z.lazy(() =>
        ComCrmApplicationSelfServiceResourceGetApplicationPhone$inboundSchema
      )),
      website: z.optional(z.nullable(types.string())),
    }),
    z.transform((v) => {
      return remap$(v, {
        "email_address": "emailAddress",
      });
    }),
  );

export function contactUsFromJSON(
  jsonString: string,
): SafeParseResult<ContactUs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContactUs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContactUs' from JSON`,
  );
}

/** @internal */
export const Information$inboundSchema: z.ZodMiniType<Information, unknown> = z
  .pipe(
    z.object({
      content: types.optional(z.array(z.lazy(() =>
        ComCrmApplicationSelfServiceResourceGetApplicationContent$inboundSchema
      ))),
      contact_us: types.optional(z.lazy(() =>
        ContactUs$inboundSchema
      )),
    }),
    z.transform((v) => {
      return remap$(v, {
        "contact_us": "contactUs",
      });
    }),
  );

export function informationFromJSON(
  jsonString: string,
): SafeParseResult<Information, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Information$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Information' from JSON`,
  );
}

/** @internal */
export const WalletCodeFormat$inboundSchema: z.ZodMiniType<
  WalletCodeFormat,
  unknown
> = openEnums.inboundSchema(WalletCodeFormat);

/** @internal */
export const ProfileType$inboundSchema: z.ZodMiniType<ProfileType, unknown> =
  openEnums.inboundSchema(ProfileType);

/** @internal */
export const Profile$inboundSchema: z.ZodMiniType<Profile, unknown> = z.pipe(
  z.object({
    type: types.optional(ProfileType$inboundSchema),
    is_supported: types.optional(types.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_supported": "isSupported",
    });
  }),
);

export function profileFromJSON(
  jsonString: string,
): SafeParseResult<Profile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Profile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Profile' from JSON`,
  );
}

/** @internal */
export const Communities$inboundSchema: z.ZodMiniType<Communities, unknown> = z
  .pipe(
    z.object({
      is_supported: types.optional(types.boolean()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "is_supported": "isSupported",
      });
    }),
  );

export function communitiesFromJSON(
  jsonString: string,
): SafeParseResult<Communities, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Communities$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Communities' from JSON`,
  );
}

/** @internal */
export const ComCrmApplicationSelfServiceResourceGetApplicationCountry$inboundSchema:
  z.ZodMiniType<
    ComCrmApplicationSelfServiceResourceGetApplicationCountry,
    unknown
  > = z.object({
    country: types.optional(types.string()),
  });

export function comCrmApplicationSelfServiceResourceGetApplicationCountryFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmApplicationSelfServiceResourceGetApplicationCountry,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmApplicationSelfServiceResourceGetApplicationCountry$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmApplicationSelfServiceResourceGetApplicationCountry' from JSON`,
  );
}

/** @internal */
export const ComCrmApplicationSelfServiceResourceGetApplicationCountryCallingCodeCountry$inboundSchema:
  z.ZodMiniType<
    ComCrmApplicationSelfServiceResourceGetApplicationCountryCallingCodeCountry,
    unknown
  > = openEnums.inboundSchema(
    ComCrmApplicationSelfServiceResourceGetApplicationCountryCallingCodeCountry,
  );

/** @internal */
export const ComCrmApplicationSelfServiceResourceGetApplicationCountryCallingCode$inboundSchema:
  z.ZodMiniType<
    ComCrmApplicationSelfServiceResourceGetApplicationCountryCallingCode,
    unknown
  > = z.object({
    country: types.optional(
      ComCrmApplicationSelfServiceResourceGetApplicationCountryCallingCodeCountry$inboundSchema,
    ),
  });

export function comCrmApplicationSelfServiceResourceGetApplicationCountryCallingCodeFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmApplicationSelfServiceResourceGetApplicationCountryCallingCode,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmApplicationSelfServiceResourceGetApplicationCountryCallingCode$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmApplicationSelfServiceResourceGetApplicationCountryCallingCode' from JSON`,
  );
}

/** @internal */
export const ComCrmApplicationSelfServiceResourceGetApplicationDefaultCountryCallingCode$inboundSchema:
  z.ZodMiniType<
    ComCrmApplicationSelfServiceResourceGetApplicationDefaultCountryCallingCode,
    unknown
  > = openEnums.inboundSchema(
    ComCrmApplicationSelfServiceResourceGetApplicationDefaultCountryCallingCode,
  );

/** @internal */
export const FeaturesContactContact$inboundSchema: z.ZodMiniType<
  FeaturesContactContact,
  unknown
> = z.pipe(
  z.object({
    is_supported: types.optional(types.boolean()),
    wallet_code_format: types.optional(WalletCodeFormat$inboundSchema),
    enable_existing_customer_flow: types.optional(types.boolean()),
    profile: types.optional(z.array(z.lazy(() => Profile$inboundSchema))),
    communities: types.optional(z.lazy(() => Communities$inboundSchema)),
    countries: types.optional(z.array(z.lazy(() =>
      ComCrmApplicationSelfServiceResourceGetApplicationCountry$inboundSchema
    ))),
    country_calling_codes: types.optional(z.array(z.lazy(() =>
      ComCrmApplicationSelfServiceResourceGetApplicationCountryCallingCode$inboundSchema
    ))),
    default_country_calling_code: types.optional(
      ComCrmApplicationSelfServiceResourceGetApplicationDefaultCountryCallingCode$inboundSchema,
    ),
    preferred_language_code: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_supported": "isSupported",
      "wallet_code_format": "walletCodeFormat",
      "enable_existing_customer_flow": "enableExistingCustomerFlow",
      "country_calling_codes": "countryCallingCodes",
      "default_country_calling_code": "defaultCountryCallingCode",
      "preferred_language_code": "preferredLanguageCode",
    });
  }),
);

export function featuresContactContactFromJSON(
  jsonString: string,
): SafeParseResult<FeaturesContactContact, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FeaturesContactContact$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FeaturesContactContact' from JSON`,
  );
}

/** @internal */
export const Multitenancy$inboundSchema: z.ZodMiniType<Multitenancy, unknown> =
  z.pipe(
    z.object({
      is_supported: types.optional(types.boolean()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "is_supported": "isSupported",
      });
    }),
  );

export function multitenancyFromJSON(
  jsonString: string,
): SafeParseResult<Multitenancy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Multitenancy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Multitenancy' from JSON`,
  );
}

/** @internal */
export const BusinessNetwork$inboundSchema: z.ZodMiniType<
  BusinessNetwork,
  unknown
> = z.pipe(
  z.object({
    is_supported: z._default(types.boolean(), false),
    multitenancy: types.optional(z.lazy(() => Multitenancy$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_supported": "isSupported",
    });
  }),
);

export function businessNetworkFromJSON(
  jsonString: string,
): SafeParseResult<BusinessNetwork, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BusinessNetwork$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BusinessNetwork' from JSON`,
  );
}

/** @internal */
export const ServiceRequests$inboundSchema: z.ZodMiniType<
  ServiceRequests,
  unknown
> = z.pipe(
  z.object({
    is_supported: types.optional(types.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_supported": "isSupported",
    });
  }),
);

export function serviceRequestsFromJSON(
  jsonString: string,
): SafeParseResult<ServiceRequests, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ServiceRequests$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ServiceRequests' from JSON`,
  );
}

/** @internal */
export const Crm$inboundSchema: z.ZodMiniType<Crm, unknown> = z.pipe(
  z.object({
    is_supported: z._default(types.boolean(), false),
    service_requests: types.optional(
      z.lazy(() => ServiceRequests$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_supported": "isSupported",
      "service_requests": "serviceRequests",
    });
  }),
);

export function crmFromJSON(
  jsonString: string,
): SafeParseResult<Crm, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Crm$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Crm' from JSON`,
  );
}

/** @internal */
export const TopUpCommercePool$inboundSchema: z.ZodMiniType<
  TopUpCommercePool,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
  description: types.optional(types.string()),
});

export function topUpCommercePoolFromJSON(
  jsonString: string,
): SafeParseResult<TopUpCommercePool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopUpCommercePool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopUpCommercePool' from JSON`,
  );
}

/** @internal */
export const PassAttributeType$inboundSchema: z.ZodMiniType<
  PassAttributeType,
  unknown
> = openEnums.inboundSchema(PassAttributeType);

/** @internal */
export const PassAttribute$inboundSchema: z.ZodMiniType<
  PassAttribute,
  unknown
> = z.object({
  type: types.optional(PassAttributeType$inboundSchema),
});

export function passAttributeFromJSON(
  jsonString: string,
): SafeParseResult<PassAttribute, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PassAttribute$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PassAttribute' from JSON`,
  );
}

/** @internal */
export const RedeemPass$inboundSchema: z.ZodMiniType<RedeemPass, unknown> = z
  .pipe(
    z.object({
      is_supported: types.optional(types.boolean()),
      enable_on_registration: types.optional(types.boolean()),
      pass_attributes: types.optional(
        z.array(z.lazy(() => PassAttribute$inboundSchema)),
      ),
    }),
    z.transform((v) => {
      return remap$(v, {
        "is_supported": "isSupported",
        "enable_on_registration": "enableOnRegistration",
        "pass_attributes": "passAttributes",
      });
    }),
  );

export function redeemPassFromJSON(
  jsonString: string,
): SafeParseResult<RedeemPass, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RedeemPass$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RedeemPass' from JSON`,
  );
}

/** @internal */
export const TransferEntity$inboundSchema: z.ZodMiniType<
  TransferEntity,
  unknown
> = openEnums.inboundSchema(TransferEntity);

/** @internal */
export const TransferRestriction$inboundSchema: z.ZodMiniType<
  TransferRestriction,
  unknown
> = openEnums.inboundSchema(TransferRestriction);

/** @internal */
export const ComCrmApplicationSelfServiceResourceGetApplicationCommercePool$inboundSchema:
  z.ZodMiniType<
    ComCrmApplicationSelfServiceResourceGetApplicationCommercePool,
    unknown
  > = z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    description: types.optional(types.string()),
  });

export function comCrmApplicationSelfServiceResourceGetApplicationCommercePoolFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmApplicationSelfServiceResourceGetApplicationCommercePool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmApplicationSelfServiceResourceGetApplicationCommercePool$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmApplicationSelfServiceResourceGetApplicationCommercePool' from JSON`,
  );
}

/** @internal */
export const ComCrmApplicationSelfServiceResourceGetApplicationTransfer$inboundSchema:
  z.ZodMiniType<
    ComCrmApplicationSelfServiceResourceGetApplicationTransfer,
    unknown
  > = z.pipe(
    z.object({
      is_supported: types.optional(types.boolean()),
      transfer_entity: types.optional(z.array(TransferEntity$inboundSchema)),
      transfer_restrictions: types.optional(
        z.array(TransferRestriction$inboundSchema),
      ),
      commerce_pools: types.optional(z.array(z.lazy(() =>
        ComCrmApplicationSelfServiceResourceGetApplicationCommercePool$inboundSchema
      ))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "is_supported": "isSupported",
        "transfer_entity": "transferEntity",
        "transfer_restrictions": "transferRestrictions",
        "commerce_pools": "commercePools",
      });
    }),
  );

export function comCrmApplicationSelfServiceResourceGetApplicationTransferFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmApplicationSelfServiceResourceGetApplicationTransfer,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmApplicationSelfServiceResourceGetApplicationTransfer$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmApplicationSelfServiceResourceGetApplicationTransfer' from JSON`,
  );
}

/** @internal */
export const Donations$inboundSchema: z.ZodMiniType<Donations, unknown> = z
  .pipe(
    z.object({
      is_supported: types.optional(types.boolean()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "is_supported": "isSupported",
      });
    }),
  );

export function donationsFromJSON(
  jsonString: string,
): SafeParseResult<Donations, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Donations$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Donations' from JSON`,
  );
}

/** @internal */
export const ComCrmApplicationSelfServiceResourceGetApplicationCurrencyCode$inboundSchema:
  z.ZodMiniType<
    ComCrmApplicationSelfServiceResourceGetApplicationCurrencyCode,
    unknown
  > = openEnums.inboundSchema(
    ComCrmApplicationSelfServiceResourceGetApplicationCurrencyCode,
  );

/** @internal */
export const TopupAmount$inboundSchema: z.ZodMiniType<TopupAmount, unknown> = z
  .pipe(
    z.object({
      currency_code: types.optional(
        ComCrmApplicationSelfServiceResourceGetApplicationCurrencyCode$inboundSchema,
      ),
      amounts: types.optional(z.array(types.number())),
    }),
    z.transform((v) => {
      return remap$(v, {
        "currency_code": "currencyCode",
      });
    }),
  );

export function topupAmountFromJSON(
  jsonString: string,
): SafeParseResult<TopupAmount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopupAmount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopupAmount' from JSON`,
  );
}

/** @internal */
export const Finance$inboundSchema: z.ZodMiniType<Finance, unknown> = z.pipe(
  z.object({
    is_supported: z._default(types.boolean(), false),
    wallet_top_up: types.optional(types.boolean()),
    top_up_commerce_pools: types.optional(z.array(z.lazy(() =>
      TopUpCommercePool$inboundSchema
    ))),
    wallet_payout: types.optional(types.boolean()),
    redeem_pass: types.optional(z.lazy(() => RedeemPass$inboundSchema)),
    transfer: types.optional(z.lazy(() =>
      ComCrmApplicationSelfServiceResourceGetApplicationTransfer$inboundSchema
    )),
    donations: types.optional(z.lazy(() =>
      Donations$inboundSchema
    )),
    topup_amounts: types.optional(z.array(z.lazy(() =>
      TopupAmount$inboundSchema
    ))),
    redeem_method: types.optional(types.string()),
    egifts_enabled: types.optional(types.boolean()),
    auto_topup_enabled: types.optional(types.boolean()),
    dynamic_wallet_code: types.optional(types.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_supported": "isSupported",
      "wallet_top_up": "walletTopUp",
      "top_up_commerce_pools": "topUpCommercePools",
      "wallet_payout": "walletPayout",
      "redeem_pass": "redeemPass",
      "topup_amounts": "topupAmounts",
      "redeem_method": "redeemMethod",
      "egifts_enabled": "egiftsEnabled",
      "auto_topup_enabled": "autoTopupEnabled",
      "dynamic_wallet_code": "dynamicWalletCode",
    });
  }),
);

export function financeFromJSON(
  jsonString: string,
): SafeParseResult<Finance, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Finance$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Finance' from JSON`,
  );
}

/** @internal */
export const PickUp$inboundSchema: z.ZodMiniType<PickUp, unknown> = z.pipe(
  z.object({
    is_supported: z._default(types.boolean(), false),
    queue_id: types.optional(types.string()),
    queue_name: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_supported": "isSupported",
      "queue_id": "queueId",
      "queue_name": "queueName",
    });
  }),
);

export function pickUpFromJSON(
  jsonString: string,
): SafeParseResult<PickUp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PickUp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PickUp' from JSON`,
  );
}

/** @internal */
export const Delivery$inboundSchema: z.ZodMiniType<Delivery, unknown> = z.pipe(
  z.object({
    is_supported: z._default(types.boolean(), false),
    queue_id: types.optional(types.string()),
    queue_name: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_supported": "isSupported",
      "queue_id": "queueId",
      "queue_name": "queueName",
    });
  }),
);

export function deliveryFromJSON(
  jsonString: string,
): SafeParseResult<Delivery, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Delivery$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Delivery' from JSON`,
  );
}

/** @internal */
export const DirectSale$inboundSchema: z.ZodMiniType<DirectSale, unknown> = z
  .pipe(
    z.object({
      is_supported: z._default(types.boolean(), false),
      queue_id: types.optional(types.string()),
      queue_name: types.optional(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "is_supported": "isSupported",
        "queue_id": "queueId",
        "queue_name": "queueName",
      });
    }),
  );

export function directSaleFromJSON(
  jsonString: string,
): SafeParseResult<DirectSale, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DirectSale$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DirectSale' from JSON`,
  );
}

/** @internal */
export const Model$inboundSchema: z.ZodMiniType<Model, unknown> = openEnums
  .inboundSchema(Model);

/** @internal */
export const OrderCatalogue$inboundSchema: z.ZodMiniType<
  OrderCatalogue,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    name: types.optional(types.string()),
    is_pricing_table: types.optional(types.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_pricing_table": "isPricingTable",
    });
  }),
);

export function orderCatalogueFromJSON(
  jsonString: string,
): SafeParseResult<OrderCatalogue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrderCatalogue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrderCatalogue' from JSON`,
  );
}

/** @internal */
export const UseWalletFunds$inboundSchema: z.ZodMiniType<
  UseWalletFunds,
  unknown
> = z.pipe(
  z.object({
    is_supported: z._default(types.boolean(), false),
    specific_funds_amount: types.optional(types.boolean()),
    cover_full_basket: types.optional(types.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_supported": "isSupported",
      "specific_funds_amount": "specificFundsAmount",
      "cover_full_basket": "coverFullBasket",
    });
  }),
);

export function useWalletFundsFromJSON(
  jsonString: string,
): SafeParseResult<UseWalletFunds, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UseWalletFunds$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UseWalletFunds' from JSON`,
  );
}

/** @internal */
export const FulfilmentFlows$inboundSchema: z.ZodMiniType<
  FulfilmentFlows,
  unknown
> = z.pipe(
  z.object({
    fulfilment_flow: types.string(),
    allow_delivery_selection: types.optional(types.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "fulfilment_flow": "fulfilmentFlow",
      "allow_delivery_selection": "allowDeliverySelection",
    });
  }),
);

export function fulfilmentFlowsFromJSON(
  jsonString: string,
): SafeParseResult<FulfilmentFlows, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FulfilmentFlows$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FulfilmentFlows' from JSON`,
  );
}

/** @internal */
export const ComCrmApplicationSelfServiceResourceGetApplicationOrder$inboundSchema:
  z.ZodMiniType<
    ComCrmApplicationSelfServiceResourceGetApplicationOrder,
    unknown
  > = z.pipe(
    z.object({
      is_supported: z._default(types.boolean(), false),
      pick_up: types.optional(z.lazy(() => PickUp$inboundSchema)),
      delivery: types.optional(z.lazy(() => Delivery$inboundSchema)),
      direct_sale: types.optional(z.lazy(() => DirectSale$inboundSchema)),
      model: types.optional(Model$inboundSchema),
      preferred_organisation: types.optional(types.boolean()),
      order_catalogues: types.optional(
        z.array(z.lazy(() => OrderCatalogue$inboundSchema)),
      ),
      use_wallet_funds: types.optional(
        z.lazy(() => UseWalletFunds$inboundSchema),
      ),
      use_account_funds: z._default(types.boolean(), false),
      fulfilment_flows: types.optional(
        z.lazy(() => FulfilmentFlows$inboundSchema),
      ),
      support_product_additional_notes: types.optional(types.boolean()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "is_supported": "isSupported",
        "pick_up": "pickUp",
        "direct_sale": "directSale",
        "preferred_organisation": "preferredOrganisation",
        "order_catalogues": "orderCatalogues",
        "use_wallet_funds": "useWalletFunds",
        "use_account_funds": "useAccountFunds",
        "fulfilment_flows": "fulfilmentFlows",
        "support_product_additional_notes": "supportProductAdditionalNotes",
      });
    }),
  );

export function comCrmApplicationSelfServiceResourceGetApplicationOrderFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmApplicationSelfServiceResourceGetApplicationOrder,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmApplicationSelfServiceResourceGetApplicationOrder$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmApplicationSelfServiceResourceGetApplicationOrder' from JSON`,
  );
}

/** @internal */
export const ReferMethod$inboundSchema: z.ZodMiniType<ReferMethod, unknown> =
  openEnums.inboundSchema(ReferMethod);

/** @internal */
export const ReferFriend$inboundSchema: z.ZodMiniType<ReferFriend, unknown> = z
  .pipe(
    z.object({
      is_supported: types.optional(types.boolean()),
      refer_methods: types.optional(z.array(ReferMethod$inboundSchema)),
    }),
    z.transform((v) => {
      return remap$(v, {
        "is_supported": "isSupported",
        "refer_methods": "referMethods",
      });
    }),
  );

export function referFriendFromJSON(
  jsonString: string,
): SafeParseResult<ReferFriend, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ReferFriend$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ReferFriend' from JSON`,
  );
}

/** @internal */
export const ComCrmApplicationSelfServiceResourceGetApplicationCodeFormat$inboundSchema:
  z.ZodMiniType<
    ComCrmApplicationSelfServiceResourceGetApplicationCodeFormat,
    unknown
  > = openEnums.inboundSchema(
    ComCrmApplicationSelfServiceResourceGetApplicationCodeFormat,
  );

/** @internal */
export const SpendAttributeType$inboundSchema: z.ZodMiniEnum<
  typeof SpendAttributeType
> = z.enum(SpendAttributeType);

/** @internal */
export const SpendAttribute$inboundSchema: z.ZodMiniType<
  SpendAttribute,
  unknown
> = z.object({
  type: types.optional(SpendAttributeType$inboundSchema),
});

export function spendAttributeFromJSON(
  jsonString: string,
): SafeParseResult<SpendAttribute, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SpendAttribute$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SpendAttribute' from JSON`,
  );
}

/** @internal */
export const OtpSpend$inboundSchema: z.ZodMiniType<OtpSpend, unknown> = z.pipe(
  z.object({
    is_supported: types.optional(types.boolean()),
    code_format: types.optional(
      ComCrmApplicationSelfServiceResourceGetApplicationCodeFormat$inboundSchema,
    ),
    spend_attributes: types.optional(z.array(z.lazy(() =>
      SpendAttribute$inboundSchema
    ))),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_supported": "isSupported",
      "code_format": "codeFormat",
      "spend_attributes": "spendAttributes",
    });
  }),
);

export function otpSpendFromJSON(
  jsonString: string,
): SafeParseResult<OtpSpend, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OtpSpend$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OtpSpend' from JSON`,
  );
}

/** @internal */
export const SelfSubmitMethod$inboundSchema: z.ZodMiniType<
  SelfSubmitMethod,
  unknown
> = openEnums.inboundSchema(SelfSubmitMethod);

/** @internal */
export const SelfSubmitPurchases$inboundSchema: z.ZodMiniType<
  SelfSubmitPurchases,
  unknown
> = z.pipe(
  z.object({
    is_supported: z._default(types.boolean(), false),
    self_submit_methods: types.optional(
      z.array(SelfSubmitMethod$inboundSchema),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_supported": "isSupported",
      "self_submit_methods": "selfSubmitMethods",
    });
  }),
);

export function selfSubmitPurchasesFromJSON(
  jsonString: string,
): SafeParseResult<SelfSubmitPurchases, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SelfSubmitPurchases$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SelfSubmitPurchases' from JSON`,
  );
}

/** @internal */
export const Reward$inboundSchema: z.ZodMiniType<Reward, unknown> = z.pipe(
  z.object({
    is_supported: z._default(types.boolean(), false),
    tiering: types.optional(types.boolean()),
    preferred_organisation: types.optional(types.boolean()),
    refer_friend: types.optional(z.lazy(() => ReferFriend$inboundSchema)),
    otp_spend: types.optional(z.lazy(() => OtpSpend$inboundSchema)),
    self_submit_purchases: types.optional(z.lazy(() =>
      SelfSubmitPurchases$inboundSchema
    )),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_supported": "isSupported",
      "preferred_organisation": "preferredOrganisation",
      "refer_friend": "referFriend",
      "otp_spend": "otpSpend",
      "self_submit_purchases": "selfSubmitPurchases",
    });
  }),
);

export function rewardFromJSON(
  jsonString: string,
): SafeParseResult<Reward, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Reward$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Reward' from JSON`,
  );
}

/** @internal */
export const MarketingLanguageCode$inboundSchema: z.ZodMiniType<
  MarketingLanguageCode,
  unknown
> = openEnums.inboundSchema(MarketingLanguageCode);

/** @internal */
export const MarketingUsageType$inboundSchema: z.ZodMiniEnum<
  typeof MarketingUsageType
> = z.enum(MarketingUsageType);

/** @internal */
export const MarketingMedia$inboundSchema: z.ZodMiniType<
  MarketingMedia,
  unknown
> = z.object({
  width: types.optional(types.number()),
  height: types.optional(types.number()),
  url: types.optional(types.string()),
});

export function marketingMediaFromJSON(
  jsonString: string,
): SafeParseResult<MarketingMedia, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MarketingMedia$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MarketingMedia' from JSON`,
  );
}

/** @internal */
export const MarketingCreative$inboundSchema: z.ZodMiniType<
  MarketingCreative,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    media_group_id: types.optional(types.string()),
    usage_type: types.optional(MarketingUsageType$inboundSchema),
    width: types.optional(types.number()),
    height: types.optional(types.number()),
    format: types.optional(types.string()),
    url: types.optional(types.string()),
    public_id: types.optional(types.string()),
    media_id: types.optional(types.string()),
    media: types.optional(z.array(z.lazy(() => MarketingMedia$inboundSchema))),
  }),
  z.transform((v) => {
    return remap$(v, {
      "media_group_id": "mediaGroupId",
      "usage_type": "usageType",
      "public_id": "publicId",
      "media_id": "mediaId",
    });
  }),
);

export function marketingCreativeFromJSON(
  jsonString: string,
): SafeParseResult<MarketingCreative, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MarketingCreative$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MarketingCreative' from JSON`,
  );
}

/** @internal */
export const ComCrmApplicationSelfServiceResourceGetApplicationEmbeddedLink$inboundSchema:
  z.ZodMiniType<
    ComCrmApplicationSelfServiceResourceGetApplicationEmbeddedLink,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      title: types.optional(types.string()),
      url: types.optional(types.string()),
      sort_order: types.optional(types.number()),
      language_code: types.optional(MarketingLanguageCode$inboundSchema),
      creatives: types.optional(
        z.array(z.lazy(() => MarketingCreative$inboundSchema)),
      ),
    }),
    z.transform((v) => {
      return remap$(v, {
        "sort_order": "sortOrder",
        "language_code": "languageCode",
      });
    }),
  );

export function comCrmApplicationSelfServiceResourceGetApplicationEmbeddedLinkFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmApplicationSelfServiceResourceGetApplicationEmbeddedLink,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmApplicationSelfServiceResourceGetApplicationEmbeddedLink$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmApplicationSelfServiceResourceGetApplicationEmbeddedLink' from JSON`,
  );
}

/** @internal */
export const Marketing$inboundSchema: z.ZodMiniType<Marketing, unknown> = z
  .pipe(
    z.object({
      is_supported: z._default(types.boolean(), false),
      embedded_links: types.optional(z.array(z.lazy(() =>
        ComCrmApplicationSelfServiceResourceGetApplicationEmbeddedLink$inboundSchema
      ))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "is_supported": "isSupported",
        "embedded_links": "embeddedLinks",
      });
    }),
  );

export function marketingFromJSON(
  jsonString: string,
): SafeParseResult<Marketing, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Marketing$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Marketing' from JSON`,
  );
}

/** @internal */
export const ShortcutType$inboundSchema: z.ZodMiniType<ShortcutType, unknown> =
  openEnums.inboundSchema(ShortcutType);

/** @internal */
export const ShortcutLanguageCode$inboundSchema: z.ZodMiniType<
  ShortcutLanguageCode,
  unknown
> = openEnums.inboundSchema(ShortcutLanguageCode);

/** @internal */
export const ShortcutUsageType$inboundSchema: z.ZodMiniEnum<
  typeof ShortcutUsageType
> = z.enum(ShortcutUsageType);

/** @internal */
export const ShortcutMedia$inboundSchema: z.ZodMiniType<
  ShortcutMedia,
  unknown
> = z.object({
  width: types.optional(types.number()),
  height: types.optional(types.number()),
  url: types.optional(types.string()),
});

export function shortcutMediaFromJSON(
  jsonString: string,
): SafeParseResult<ShortcutMedia, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ShortcutMedia$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ShortcutMedia' from JSON`,
  );
}

/** @internal */
export const ShortcutCreative$inboundSchema: z.ZodMiniType<
  ShortcutCreative,
  unknown
> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    media_group_id: types.optional(types.string()),
    usage_type: types.optional(ShortcutUsageType$inboundSchema),
    width: types.optional(types.number()),
    height: types.optional(types.number()),
    format: types.optional(types.string()),
    url: types.optional(types.string()),
    public_id: types.optional(types.string()),
    media_id: types.optional(types.string()),
    media: types.optional(z.array(z.lazy(() => ShortcutMedia$inboundSchema))),
  }),
  z.transform((v) => {
    return remap$(v, {
      "media_group_id": "mediaGroupId",
      "usage_type": "usageType",
      "public_id": "publicId",
      "media_id": "mediaId",
    });
  }),
);

export function shortcutCreativeFromJSON(
  jsonString: string,
): SafeParseResult<ShortcutCreative, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ShortcutCreative$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ShortcutCreative' from JSON`,
  );
}

/** @internal */
export const Shortcut$inboundSchema: z.ZodMiniType<Shortcut, unknown> = z.pipe(
  z.object({
    id: types.optional(types.string()),
    sort_order: types.optional(types.number()),
    type: types.optional(ShortcutType$inboundSchema),
    label: types.optional(types.string()),
    language_code: types.optional(ShortcutLanguageCode$inboundSchema),
    creatives: types.optional(z.array(z.lazy(() =>
      ShortcutCreative$inboundSchema
    ))),
  }),
  z.transform((v) => {
    return remap$(v, {
      "sort_order": "sortOrder",
      "language_code": "languageCode",
    });
  }),
);

export function shortcutFromJSON(
  jsonString: string,
): SafeParseResult<Shortcut, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Shortcut$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Shortcut' from JSON`,
  );
}

/** @internal */
export const Shortcuts$inboundSchema: z.ZodMiniType<Shortcuts, unknown> = z
  .pipe(
    z.object({
      is_supported: z._default(types.boolean(), false),
      shortcuts: types.optional(z.array(z.lazy(() => Shortcut$inboundSchema))),
    }),
    z.transform((v) => {
      return remap$(v, {
        "is_supported": "isSupported",
      });
    }),
  );

export function shortcutsFromJSON(
  jsonString: string,
): SafeParseResult<Shortcuts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Shortcuts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Shortcuts' from JSON`,
  );
}

/** @internal */
export const ComCrmApplicationSelfServiceResourceGetApplicationSubscription$inboundSchema:
  z.ZodMiniType<
    ComCrmApplicationSelfServiceResourceGetApplicationSubscription,
    unknown
  > = openEnums.inboundSchema(
    ComCrmApplicationSelfServiceResourceGetApplicationSubscription,
  );

/** @internal */
export const SubscriptionsScheduledAction$inboundSchema: z.ZodMiniType<
  SubscriptionsScheduledAction,
  unknown
> = openEnums.inboundSchema(SubscriptionsScheduledAction);

/** @internal */
export const ComCrmApplicationSelfServiceResourceGetApplicationService$inboundSchema:
  z.ZodMiniType<
    ComCrmApplicationSelfServiceResourceGetApplicationService,
    unknown
  > = openEnums.inboundSchema(
    ComCrmApplicationSelfServiceResourceGetApplicationService,
  );

/** @internal */
export const Actions$inboundSchema: z.ZodMiniType<Actions, unknown> = z.pipe(
  z.object({
    subscriptions: types.optional(
      z.array(
        ComCrmApplicationSelfServiceResourceGetApplicationSubscription$inboundSchema,
      ),
    ),
    subscriptions_scheduled_actions: types.optional(
      z.array(SubscriptionsScheduledAction$inboundSchema),
    ),
    services: types.optional(
      z.array(
        ComCrmApplicationSelfServiceResourceGetApplicationService$inboundSchema,
      ),
    ),
  }),
  z.transform((v) => {
    return remap$(v, {
      "subscriptions_scheduled_actions": "subscriptionsScheduledActions",
    });
  }),
);

export function actionsFromJSON(
  jsonString: string,
): SafeParseResult<Actions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Actions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Actions' from JSON`,
  );
}

/** @internal */
export const Subscriptions$inboundSchema: z.ZodMiniType<
  Subscriptions,
  unknown
> = z.pipe(
  z.object({
    is_supported: z._default(types.boolean(), false),
    actions: types.optional(z.lazy(() => Actions$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_supported": "isSupported",
    });
  }),
);

export function subscriptionsFromJSON(
  jsonString: string,
): SafeParseResult<Subscriptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Subscriptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Subscriptions' from JSON`,
  );
}

/** @internal */
export const MobilePass$inboundSchema: z.ZodMiniType<MobilePass, unknown> = z
  .pipe(
    z.object({
      is_supported: types.optional(types.boolean()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "is_supported": "isSupported",
      });
    }),
  );

export function mobilePassFromJSON(
  jsonString: string,
): SafeParseResult<MobilePass, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MobilePass$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MobilePass' from JSON`,
  );
}

/** @internal */
export const FeaturesContact$inboundSchema: z.ZodMiniType<
  FeaturesContact,
  unknown
> = z.pipe(
  z.object({
    contact: types.optional(z.lazy(() => FeaturesContactContact$inboundSchema)),
    business_network: types.optional(
      z.lazy(() => BusinessNetwork$inboundSchema),
    ),
    crm: types.optional(z.lazy(() => Crm$inboundSchema)),
    finance: types.optional(z.lazy(() => Finance$inboundSchema)),
    order: types.optional(
      z.lazy(() =>
        ComCrmApplicationSelfServiceResourceGetApplicationOrder$inboundSchema
      ),
    ),
    reward: types.optional(z.lazy(() => Reward$inboundSchema)),
    marketing: types.optional(z.lazy(() => Marketing$inboundSchema)),
    shortcuts: types.optional(z.lazy(() => Shortcuts$inboundSchema)),
    subscriptions: types.optional(z.lazy(() => Subscriptions$inboundSchema)),
    mobile_pass: types.optional(z.lazy(() => MobilePass$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "business_network": "businessNetwork",
      "mobile_pass": "mobilePass",
    });
  }),
);

export function featuresContactFromJSON(
  jsonString: string,
): SafeParseResult<FeaturesContact, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FeaturesContact$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FeaturesContact' from JSON`,
  );
}

/** @internal */
export const ComCrmApplicationSelfServiceResourceGetApplicationPurchase$inboundSchema:
  z.ZodMiniType<
    ComCrmApplicationSelfServiceResourceGetApplicationPurchase,
    unknown
  > = z.pipe(
    z.object({
      manual_spend: types.optional(types.boolean()),
      automatic_spend: types.optional(types.boolean()),
      spend_full_purchase_amount: types.optional(types.boolean()),
      restrict_fully_covered: types.optional(types.boolean()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "manual_spend": "manualSpend",
        "automatic_spend": "automaticSpend",
        "spend_full_purchase_amount": "spendFullPurchaseAmount",
        "restrict_fully_covered": "restrictFullyCovered",
      });
    }),
  );

export function comCrmApplicationSelfServiceResourceGetApplicationPurchaseFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmApplicationSelfServiceResourceGetApplicationPurchase,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmApplicationSelfServiceResourceGetApplicationPurchase$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmApplicationSelfServiceResourceGetApplicationPurchase' from JSON`,
  );
}

/** @internal */
export const Merchant$inboundSchema: z.ZodMiniType<Merchant, unknown> = z
  .object({
    purchase: types.optional(
      z.lazy(() =>
        ComCrmApplicationSelfServiceResourceGetApplicationPurchase$inboundSchema
      ),
    ),
  });

export function merchantFromJSON(
  jsonString: string,
): SafeParseResult<Merchant, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Merchant$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Merchant' from JSON`,
  );
}

/** @internal */
export const Features$inboundSchema: z.ZodMiniType<Features, unknown> = z
  .object({
    contact: types.optional(z.lazy(() => FeaturesContact$inboundSchema)),
    merchant: types.optional(z.lazy(() => Merchant$inboundSchema)),
  });

export function featuresFromJSON(
  jsonString: string,
): SafeParseResult<Features, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Features$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Features' from JSON`,
  );
}

/** @internal */
export const ComCrmApplicationSelfServiceResourceGetApplicationPlatformEnum$inboundSchema:
  z.ZodMiniType<
    ComCrmApplicationSelfServiceResourceGetApplicationPlatformEnum,
    unknown
  > = openEnums.inboundSchema(
    ComCrmApplicationSelfServiceResourceGetApplicationPlatformEnum,
  );

/** @internal */
export const ComCrmApplicationSelfServiceResourceGetApplicationPlatform$inboundSchema:
  z.ZodMiniType<
    ComCrmApplicationSelfServiceResourceGetApplicationPlatform,
    unknown
  > = z.pipe(
    z.object({
      platform: types.optional(
        ComCrmApplicationSelfServiceResourceGetApplicationPlatformEnum$inboundSchema,
      ),
      platform_id: z.optional(z.nullable(types.string())),
      cloud_name: z.optional(z.nullable(types.string())),
      version: z.optional(z.nullable(types.string())),
      deeplinks_config: z.optional(z.nullable(types.string())),
    }),
    z.transform((v) => {
      return remap$(v, {
        "platform_id": "platformId",
        "cloud_name": "cloudName",
        "deeplinks_config": "deeplinksConfig",
      });
    }),
  );

export function comCrmApplicationSelfServiceResourceGetApplicationPlatformFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmApplicationSelfServiceResourceGetApplicationPlatform,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmApplicationSelfServiceResourceGetApplicationPlatform$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmApplicationSelfServiceResourceGetApplicationPlatform' from JSON`,
  );
}

/** @internal */
export const Facebook$inboundSchema: z.ZodMiniType<Facebook, unknown> = z.pipe(
  z.object({
    is_supported: z._default(types.boolean(), false),
    app_id: z.optional(z.nullable(types.string())),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_supported": "isSupported",
      "app_id": "appId",
    });
  }),
);

export function facebookFromJSON(
  jsonString: string,
): SafeParseResult<Facebook, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Facebook$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Facebook' from JSON`,
  );
}

/** @internal */
export const Google$inboundSchema: z.ZodMiniType<Google, unknown> = z.pipe(
  z.object({
    is_supported: types.optional(types.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_supported": "isSupported",
    });
  }),
);

export function googleFromJSON(
  jsonString: string,
): SafeParseResult<Google, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Google$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Google' from JSON`,
  );
}

/** @internal */
export const DemoContactContact$inboundSchema: z.ZodMiniType<
  DemoContactContact,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
});

export function demoContactContactFromJSON(
  jsonString: string,
): SafeParseResult<DemoContactContact, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DemoContactContact$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DemoContactContact' from JSON`,
  );
}

/** @internal */
export const DemoContact$inboundSchema: z.ZodMiniType<DemoContact, unknown> = z
  .pipe(
    z.object({
      is_supported: z._default(types.boolean(), false),
      contact: types.optional(z.lazy(() => DemoContactContact$inboundSchema)),
      otp: types.optional(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "is_supported": "isSupported",
      });
    }),
  );

export function demoContactFromJSON(
  jsonString: string,
): SafeParseResult<DemoContact, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DemoContact$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DemoContact' from JSON`,
  );
}

/** @internal */
export const GuestContactContact$inboundSchema: z.ZodMiniType<
  GuestContactContact,
  unknown
> = z.object({
  id: types.optional(types.string()),
  name: types.optional(types.string()),
});

export function guestContactContactFromJSON(
  jsonString: string,
): SafeParseResult<GuestContactContact, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GuestContactContact$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GuestContactContact' from JSON`,
  );
}

/** @internal */
export const GuestContact$inboundSchema: z.ZodMiniType<GuestContact, unknown> =
  z.pipe(
    z.object({
      is_supported: z._default(types.boolean(), false),
      contact: types.optional(z.lazy(() => GuestContactContact$inboundSchema)),
    }),
    z.transform((v) => {
      return remap$(v, {
        "is_supported": "isSupported",
      });
    }),
  );

export function guestContactFromJSON(
  jsonString: string,
): SafeParseResult<GuestContact, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GuestContact$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GuestContact' from JSON`,
  );
}

/** @internal */
export const Sso$inboundSchema: z.ZodMiniType<Sso, unknown> = z.pipe(
  z.object({
    is_supported: z._default(types.boolean(), false),
  }),
  z.transform((v) => {
    return remap$(v, {
      "is_supported": "isSupported",
    });
  }),
);

export function ssoFromJSON(
  jsonString: string,
): SafeParseResult<Sso, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Sso$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Sso' from JSON`,
  );
}

/** @internal */
export const Authentication$inboundSchema: z.ZodMiniType<
  Authentication,
  unknown
> = z.pipe(
  z.object({
    email_password: types.optional(types.boolean()),
    email_otp: z.optional(z.nullable(types.boolean())),
    sms_otp: types.optional(types.boolean()),
    facebook: types.optional(z.lazy(() => Facebook$inboundSchema)),
    google: types.optional(z.lazy(() => Google$inboundSchema)),
    demo_contact: types.optional(z.lazy(() => DemoContact$inboundSchema)),
    guest_contact: types.optional(z.lazy(() => GuestContact$inboundSchema)),
    sso: types.optional(z.lazy(() => Sso$inboundSchema)),
  }),
  z.transform((v) => {
    return remap$(v, {
      "email_password": "emailPassword",
      "email_otp": "emailOtp",
      "sms_otp": "smsOtp",
      "demo_contact": "demoContact",
      "guest_contact": "guestContact",
    });
  }),
);

export function authenticationFromJSON(
  jsonString: string,
): SafeParseResult<Authentication, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Authentication$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Authentication' from JSON`,
  );
}

/** @internal */
export const ComCrmApplicationSelfServiceResourceGetApplicationCreativeUsageType$inboundSchema:
  z.ZodMiniType<
    ComCrmApplicationSelfServiceResourceGetApplicationCreativeUsageType,
    unknown
  > = openEnums.inboundSchema(
    ComCrmApplicationSelfServiceResourceGetApplicationCreativeUsageType,
  );

/** @internal */
export const ComCrmApplicationSelfServiceResourceGetApplicationCreativeMedia$inboundSchema:
  z.ZodMiniType<
    ComCrmApplicationSelfServiceResourceGetApplicationCreativeMedia,
    unknown
  > = z.object({
    width: types.optional(types.number()),
    height: types.optional(types.number()),
    url: types.optional(types.string()),
  });

export function comCrmApplicationSelfServiceResourceGetApplicationCreativeMediaFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmApplicationSelfServiceResourceGetApplicationCreativeMedia,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmApplicationSelfServiceResourceGetApplicationCreativeMedia$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmApplicationSelfServiceResourceGetApplicationCreativeMedia' from JSON`,
  );
}

/** @internal */
export const ComCrmApplicationSelfServiceResourceGetApplicationCreative$inboundSchema:
  z.ZodMiniType<
    ComCrmApplicationSelfServiceResourceGetApplicationCreative,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      media_group_id: types.optional(types.string()),
      usage_type: types.optional(
        ComCrmApplicationSelfServiceResourceGetApplicationCreativeUsageType$inboundSchema,
      ),
      width: types.optional(types.number()),
      height: types.optional(types.number()),
      format: types.optional(types.string()),
      url: types.optional(types.string()),
      public_id: types.optional(types.string()),
      media_id: types.optional(types.string()),
      media: types.optional(z.array(z.lazy(() =>
        ComCrmApplicationSelfServiceResourceGetApplicationCreativeMedia$inboundSchema
      ))),
      sort_order: types.optional(types.number()),
      caption: types.optional(types.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "media_group_id": "mediaGroupId",
        "usage_type": "usageType",
        "public_id": "publicId",
        "media_id": "mediaId",
        "sort_order": "sortOrder",
      });
    }),
  );

export function comCrmApplicationSelfServiceResourceGetApplicationCreativeFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmApplicationSelfServiceResourceGetApplicationCreative,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmApplicationSelfServiceResourceGetApplicationCreative$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmApplicationSelfServiceResourceGetApplicationCreative' from JSON`,
  );
}

/** @internal */
export const FirebaseConfig$inboundSchema: z.ZodMiniType<
  FirebaseConfig,
  unknown
> = z.pipe(
  z.object({
    config: types.optional(types.string()),
    vapid_key: types.optional(types.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "vapid_key": "vapidKey",
    });
  }),
);

export function firebaseConfigFromJSON(
  jsonString: string,
): SafeParseResult<FirebaseConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FirebaseConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FirebaseConfig' from JSON`,
  );
}

/** @internal */
export const CustomizationConfig$inboundSchema: z.ZodMiniType<
  CustomizationConfig,
  unknown
> = z.object({
  extension: types.optional(types.string()),
});

export function customizationConfigFromJSON(
  jsonString: string,
): SafeParseResult<CustomizationConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomizationConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomizationConfig' from JSON`,
  );
}

/** @internal */
export const ComCrmApplicationSelfServiceResourceGetApplicationResponse$inboundSchema:
  z.ZodMiniType<
    ComCrmApplicationSelfServiceResourceGetApplicationResponse,
    unknown
  > = z.pipe(
    z.object({
      id: types.optional(types.string()),
      name: types.optional(types.string()),
      description: types.optional(types.string()),
      brand_name: types.optional(types.string()),
      type: types.optional(
        ComCrmApplicationSelfServiceResourceGetApplicationType$inboundSchema,
      ),
      appearance: types.optional(z.lazy(() => Appearance$inboundSchema)),
      information: types.optional(z.lazy(() => Information$inboundSchema)),
      features: types.optional(z.lazy(() => Features$inboundSchema)),
      platforms: types.optional(z.array(z.lazy(() =>
        ComCrmApplicationSelfServiceResourceGetApplicationPlatform$inboundSchema
      ))),
      authentication: types.optional(z.lazy(() =>
        Authentication$inboundSchema
      )),
      public_key: types.optional(types.string()),
      creatives: types.optional(z.array(z.lazy(() =>
        ComCrmApplicationSelfServiceResourceGetApplicationCreative$inboundSchema
      ))),
      firebase_config: types.optional(z.lazy(() =>
        FirebaseConfig$inboundSchema
      )),
      customization_config: types.optional(
        z.lazy(() => CustomizationConfig$inboundSchema),
      ),
      show_recommendations: types.optional(types.boolean()),
      show_best_selling: types.optional(types.boolean()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "brand_name": "brandName",
        "public_key": "publicKey",
        "firebase_config": "firebaseConfig",
        "customization_config": "customizationConfig",
        "show_recommendations": "showRecommendations",
        "show_best_selling": "showBestSelling",
      });
    }),
  );

export function comCrmApplicationSelfServiceResourceGetApplicationResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmApplicationSelfServiceResourceGetApplicationResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmApplicationSelfServiceResourceGetApplicationResponse$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ComCrmApplicationSelfServiceResourceGetApplicationResponse' from JSON`,
  );
}
