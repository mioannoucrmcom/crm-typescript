/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 * @generated-id: 29b2f9757e3e
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as types from "../../types/primitives.js";
import { SDKValidationError } from "../errors/sdk-validation-error.js";

export type ComCrmRewardSchemeSelfServiceResourceListRequest = {
  /**
   * Filter based on whether contact has signed up or not
   */
  isSigned?: boolean | undefined;
  /**
   * Filter based on reward scheme name
   */
  name?: string | undefined;
};

/**
 * Defines how contacts can sign up to the reward scheme
 */
export const SignUpOption = {
  AutoSignUp: "AUTO_SIGN_UP",
  SelfSignUp: "SELF_SIGN_UP",
  CloseLoopSignUp: "CLOSE_LOOP_SIGN_UP",
} as const;
/**
 * Defines how contacts can sign up to the reward scheme
 */
export type SignUpOption = OpenEnum<typeof SignUpOption>;

/**
 * Defines how closed loop (controlled) sign ups will be validated against, like specific email domain (required only if sign up option is controlled based sign up)
 */
export const SignUpMethod = {
  EmailDomain: "EMAIL_DOMAIN",
  Code: "CODE",
} as const;
/**
 * Defines how closed loop (controlled) sign ups will be validated against, like specific email domain (required only if sign up option is controlled based sign up)
 */
export type SignUpMethod = OpenEnum<typeof SignUpMethod>;

export type ComCrmRewardSchemeSelfServiceResourceListContent = {
  /**
   * The entity identifier
   */
  id?: string | undefined;
  /**
   * The reward scheme name
   */
  name?: string | undefined;
  /**
   * The reward scheme description
   */
  description?: string | undefined;
  /**
   * Defines how contacts can sign up to the reward scheme
   */
  signUpOption?: SignUpOption | undefined;
  /**
   * Defines how closed loop (controlled) sign ups will be validated against, like specific email domain (required only if sign up option is controlled based sign up)
   */
  signUpMethod?: SignUpMethod | undefined;
  /**
   * The reward scheme terms and conditions
   */
  termsAndConditions?: string | undefined;
  /**
   * Defines whether contact has already signed up to reward scheme
   */
  isSigned?: boolean | undefined;
  emailDomains?: Array<string> | undefined;
};

/**
 * OK
 */
export type ComCrmRewardSchemeSelfServiceResourceListResponse = {
  content?: Array<ComCrmRewardSchemeSelfServiceResourceListContent> | undefined;
};

/** @internal */
export type ComCrmRewardSchemeSelfServiceResourceListRequest$Outbound = {
  is_signed?: boolean | undefined;
  name?: string | undefined;
};

/** @internal */
export const ComCrmRewardSchemeSelfServiceResourceListRequest$outboundSchema:
  z.ZodMiniType<
    ComCrmRewardSchemeSelfServiceResourceListRequest$Outbound,
    ComCrmRewardSchemeSelfServiceResourceListRequest
  > = z.pipe(
    z.object({
      isSigned: z.optional(z.boolean()),
      name: z.optional(z.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        isSigned: "is_signed",
      });
    }),
  );

export function comCrmRewardSchemeSelfServiceResourceListRequestToJSON(
  comCrmRewardSchemeSelfServiceResourceListRequest:
    ComCrmRewardSchemeSelfServiceResourceListRequest,
): string {
  return JSON.stringify(
    ComCrmRewardSchemeSelfServiceResourceListRequest$outboundSchema.parse(
      comCrmRewardSchemeSelfServiceResourceListRequest,
    ),
  );
}

/** @internal */
export const SignUpOption$inboundSchema: z.ZodMiniType<SignUpOption, unknown> =
  openEnums.inboundSchema(SignUpOption);

/** @internal */
export const SignUpMethod$inboundSchema: z.ZodMiniType<SignUpMethod, unknown> =
  openEnums.inboundSchema(SignUpMethod);

/** @internal */
export const ComCrmRewardSchemeSelfServiceResourceListContent$inboundSchema:
  z.ZodMiniType<ComCrmRewardSchemeSelfServiceResourceListContent, unknown> = z
    .pipe(
      z.object({
        id: types.optional(types.string()),
        name: types.optional(types.string()),
        description: types.optional(types.string()),
        sign_up_option: types.optional(SignUpOption$inboundSchema),
        sign_up_method: types.optional(SignUpMethod$inboundSchema),
        terms_and_conditions: types.optional(types.string()),
        is_signed: types.optional(types.boolean()),
        email_domains: types.optional(z.array(types.string())),
      }),
      z.transform((v) => {
        return remap$(v, {
          "sign_up_option": "signUpOption",
          "sign_up_method": "signUpMethod",
          "terms_and_conditions": "termsAndConditions",
          "is_signed": "isSigned",
          "email_domains": "emailDomains",
        });
      }),
    );

export function comCrmRewardSchemeSelfServiceResourceListContentFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmRewardSchemeSelfServiceResourceListContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmRewardSchemeSelfServiceResourceListContent$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmRewardSchemeSelfServiceResourceListContent' from JSON`,
  );
}

/** @internal */
export const ComCrmRewardSchemeSelfServiceResourceListResponse$inboundSchema:
  z.ZodMiniType<ComCrmRewardSchemeSelfServiceResourceListResponse, unknown> = z
    .object({
      content: types.optional(
        z.array(z.lazy(() =>
          ComCrmRewardSchemeSelfServiceResourceListContent$inboundSchema
        )),
      ),
    });

export function comCrmRewardSchemeSelfServiceResourceListResponseFromJSON(
  jsonString: string,
): SafeParseResult<
  ComCrmRewardSchemeSelfServiceResourceListResponse,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ComCrmRewardSchemeSelfServiceResourceListResponse$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ComCrmRewardSchemeSelfServiceResourceListResponse' from JSON`,
  );
}
